diff --git a/display/include/ump.h b/display/include/ump.h
index 005e7af..12a5c8c 100644
--- a/display/include/ump.h
+++ b/display/include/ump.h
@@ -73,8 +73,10 @@ typedef enum
  * Each open is reference counted and must be matched with a call to @ref ump_close "ump_close".
  *
  * @see ump_close
+ *
+ * @return UMP_OK indicates success, UMP_ERROR indicates failure.
  */
-UMP_API_EXPORT void ump_open(void);
+UMP_API_EXPORT ump_result ump_open(void);
 
 
 /**
@@ -143,7 +145,7 @@ UMP_API_EXPORT ump_handle ump_handle_create_from_secure_id(ump_secure_id secure_
  *
  * @return Returns the allocated size of the specified UMP memory, in bytes.
  */
-UMP_API_EXPORT void ump_size_get(ump_handle mem);
+UMP_API_EXPORT unsigned long ump_size_get(ump_handle mem);
 
 
 /**
@@ -214,7 +216,7 @@ UMP_API_EXPORT void * ump_mapped_pointer_get(ump_handle mem);
  *
  * @param mem Handle to UMP memory.
  */
-//UMP_API_EXPORT void ump_mapped_pointer_release(ump_handle mem);
+UMP_API_EXPORT void ump_mapped_pointer_release(ump_handle mem);
 
 
 /**
diff --git a/display/libUMP-shim/Android.mk b/display/libUMP-shim/Android.mk
index 29e592b..b5e7351 100644
--- a/display/libUMP-shim/Android.mk
+++ b/display/libUMP-shim/Android.mk
@@ -21,25 +21,14 @@ include $(CLEAR_VARS)
 LOCAL_PRELINK_MODULE := false
 LOCAL_SHARED_LIBRARIES := liblog libcutils
 
-LOCAL_CFLAGS:= -DLOG_TAG=\"UMP\" -Wa,-mimplicit-it=thumb -Wno-error=return-type
+LOCAL_CFLAGS:= -DLOG_TAG=\"UMP\"
 
 LOCAL_C_INCLUDES:= \
 	$(LOCAL_PATH)/../include \
 	$(LOCAL_PATH)/include
 
-#	arch_011_udd/ump_arch/ump_arch_open.S \
-#	arch_011_udd/ump_frontend/ump_mapped_pointer_get.S \
-#	arch_011_udd/ump_arch/ump_arch_release.S \
-#	arch_011_udd/ump_arch/ump_arch_lock.S \
-
-
 UMP_SRCS := \
-	shim.c \
 	arch_011_udd/ump_frontend.c \
-	arch_011_udd/ump_frontend/hwmem_uku.S \
-	arch_011_udd/ump_frontend/ump_mapped_pointer_release.S \
-	arch_011_udd/ump_frontend/ump_reference_release.S \
-	arch_011_udd/ump_frontend/ump_arch_unlock.S \
 	arch_011_udd/ump_ref_drv.c \
 	arch_011_udd/ump_arch.c \
 	os/linux/ump_uku.c \
@@ -48,6 +37,6 @@ UMP_SRCS := \
 
 LOCAL_SRC_FILES := $(UMP_SRCS)
 
-LOCAL_MODULE := libUMP
+LOCAL_MODULE := libUMP-shim
 LOCAL_MODULE_TAGS := optional
 include $(BUILD_SHARED_LIBRARY)
diff --git a/display/libUMP-shim/arch_011_udd/ump_arch.c b/display/libUMP-shim/arch_011_udd/ump_arch.c
index b10fa39..314efbc 100644
--- a/display/libUMP-shim/arch_011_udd/ump_arch.c
+++ b/display/libUMP-shim/arch_011_udd/ump_arch.c
@@ -38,7 +38,6 @@ static volatile int ump_ref_count = 0;
 /** Lock for critical section in open/close */
 _ump_osu_lock_t * ump_lock_arch = NULL;
 
-#ifdef TEST
 ump_result ump_arch_open(void)
 {
 	ump_result retval = UMP_OK;
@@ -67,7 +66,7 @@ ump_result ump_arch_open(void)
 	{
 		/* We are the first, open the UMP device driver */
 
-		if (_UMP_OSU_ERR_OK != _hwmem_uku_open( &ump_uk_ctx ))
+		if (_UMP_OSU_ERR_OK != _ump_uku_open( &ump_uk_ctx ))
 		{
 			UMP_DEBUG_PRINT(1, ("UMP: ump_arch_open() failed to open UMP device driver\n"));
 			retval = UMP_ERROR;
@@ -80,9 +79,9 @@ ump_result ump_arch_open(void)
 
 	return retval;
 }
-#endif
 
-#ifdef TEST
+
+
 void ump_arch_close(void)
 {
 	_ump_osu_lock_auto_init( &ump_lock_arch, _UMP_OSU_LOCKFLAG_DEFAULT, 0, 0 );
@@ -107,7 +106,7 @@ void ump_arch_close(void)
 		ump_ref_count--;
 		if (0 == ump_ref_count)
 		{
-			_ump_osu_errcode_t retval = _hwmem_uku_close(&ump_uk_ctx);
+			_ump_osu_errcode_t retval = _ump_uku_close(&ump_uk_ctx);
 			UMP_DEBUG_ASSERT(retval == _UMP_OSU_ERR_OK, ("UMP: Failed to close UMP interface"));
 			UMP_IGNORE(retval);
 			ump_uk_ctx = NULL;
@@ -121,13 +120,12 @@ void ump_arch_close(void)
 	/* Signal the lock so someone else can use it */
 	 _ump_osu_lock_signal( ump_lock_arch, _UMP_OSU_LOCKMODE_RW );
 }
-#endif
 
-#if 0
+
+
 ump_secure_id ump_arch_allocate(unsigned long * size, ump_alloc_constraints constraints)
 {
 	_ump_uk_allocate_s call_arg;
-	ALOGD("ump_arch_allocate: test \n");
 
 	if ( NULL == size )
 	{
@@ -166,9 +164,8 @@ ump_secure_id ump_arch_allocate(unsigned long * size, ump_alloc_constraints cons
 
 	return call_arg.secure_id;
 }
-#endif
 
-#if 0
+
 ump_secure_id ump_arch_ion_import(int ion_fd, unsigned long *size, ump_alloc_constraints constraints)
 {
     _ump_uk_ion_import_s call_arg;
@@ -192,7 +189,7 @@ ump_secure_id ump_arch_ion_import(int ion_fd, unsigned long *size, ump_alloc_con
 
     return call_arg.secure_id;
 }
-#endif
+
 
 unsigned long ump_arch_size_get(ump_secure_id secure_id)
 {
@@ -210,27 +207,8 @@ unsigned long ump_arch_size_get(ump_secure_id secure_id)
 	return 0;
 }
 
-#ifdef TEST
-ump_result ump_arch_release(int32_t a1, int32_t a2)
-{
-    if (_hwmem_uku_release(&ump_uk_ctx, a1) == 0) {
-        // if_1bf4_0_true
-        return 0;
-    }
-
-    puts("*********************************************************************");
-    printf("ASSERT EXIT: ");
-    printf("UMP: Failed to release reference to UMP memory");
-    abort();
-
-    // UNREACHABLE
-    return UMP_ERROR;
-}
-#endif
-
 
-#if 0
-void ump_arch_release(ump_secure_id secure_id)
+void ump_arch_reference_release(ump_secure_id secure_id)
 {
 	_ump_uk_release_s dd_release_call_arg;
 	_ump_osu_errcode_t retval;
@@ -244,7 +222,7 @@ void ump_arch_release(ump_secure_id secure_id)
 	UMP_DEBUG_ASSERT(retval == _UMP_OSU_ERR_OK, ("UMP: Failed to release reference to UMP memory"));
 	UMP_IGNORE(retval);
 }
-#endif
+
 
 void* ump_arch_map(ump_secure_id secure_id, unsigned long size, ump_cache_enabled cache, unsigned long *cookie_out)
 {
@@ -334,7 +312,6 @@ int ump_arch_switch_hw_usage( ump_secure_id secure_id, ump_hw_usage new_user )
 	return 1; /* Always success */
 }
 
-#if 0
 int ump_arch_lock( ump_secure_id secure_id, ump_lock_usage lock_usage )
 {
 	_ump_uk_lock_s dd_lock_arg;
@@ -359,4 +336,3 @@ int ump_arch_unlock( ump_secure_id secure_id )
 	_ump_uku_unlock( &dd_unlock_arg );
 	return 1; /* Always success */
 }
-#endif
diff --git a/display/libUMP-shim/arch_011_udd/ump_arch.h b/display/libUMP-shim/arch_011_udd/ump_arch.h
index 1999d14..f7b109c 100644
--- a/display/libUMP-shim/arch_011_udd/ump_arch.h
+++ b/display/libUMP-shim/arch_011_udd/ump_arch.h
@@ -46,7 +46,7 @@ ump_secure_id ump_arch_allocate(unsigned long * size, ump_alloc_constraints cons
 unsigned long ump_arch_size_get(ump_secure_id secure_id);
 
 /** Release a reference from specified UMP memory. */
-//void ump_arch_release(ump_secure_id secure_id);
+void ump_arch_reference_release(ump_secure_id secure_id);
 
 /** Map specified UMP memory into CPU address space */
 void* ump_arch_map(ump_secure_id secure_id, unsigned long size, ump_cache_enabled cache, unsigned long *cookie_out);
@@ -66,10 +66,10 @@ int ump_arch_cache_operations_control(ump_cache_op_control op);
 int ump_arch_switch_hw_usage( ump_secure_id secure_id, ump_hw_usage new_user );
 
 /** Locking buffer. Blocking call if the buffer is already locked. */
-//int ump_arch_lock( ump_secure_id secure_id, ump_lock_usage lock_usage );
+int ump_arch_lock( ump_secure_id secure_id, ump_lock_usage lock_usage );
 
 /** Unlocking buffer. Let other users lock the buffer for their usage */
-//int ump_arch_unlock( ump_secure_id secure_id );
+int ump_arch_unlock( ump_secure_id secure_id );
 
 
 #ifdef __cplusplus
diff --git a/display/libUMP-shim/arch_011_udd/ump_arch/arch.S b/display/libUMP-shim/arch_011_udd/ump_arch/arch.S
deleted file mode 100644
index bb603a9..0000000
--- a/display/libUMP-shim/arch_011_udd/ump_arch/arch.S
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2010-2011, 2013 ARM Limited. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#if 0
-.globl ump_arch_import
-ump_arch_import:
- .1b74: push {r4, r5, r6, lr}
- .1b78: mov r6, r1
- .1b7c: ldr r4, [pc, #64] /* ; .1bc4 <ump_arch_import+0x50> */
- .1b80: sub sp, sp, #16
- .1b84: mov r1, r0
- .1b88: add r4, pc, r4
- .1b8c: ldr r0, [r4]
- .1b90: bl _hwmem_uku_import
- .1b94: mov r1, sp
- .1b98: mov r2, #0
- .1b9c: str r2, [sp, #4]
- .1ba0: mov r5, r0
- .1ba4: ldr r0, [r4]
- .1ba8: str r5, [sp]
- .1bac: bl _hwmem_uku_get_info
- .1bb0: ldr r3, [sp, #4]
- .1bb4: mov r0, r5
- .1bb8: str r3, [r6]
- .1bbc: add sp, sp, #16
- .1bc0: pop {r4, r5, r6, pc}
- .1bc4: andeq r3, r0, r4, asr #9
-#endif
-
-.globl ump_arch_export
-ump_arch_export:
- .1bc8: mov r1, r0
- .1bcc: ldr r0, [pc, #4] /* ; .1bd8 <ump_arch_export+0x10> */
- .1bd0: ldr r0, [pc, r0]
- .1bd4: b _hwmem_uku_export
- .1bd8: andeq r3, r0, ip, ror r4
diff --git a/display/libUMP-shim/arch_011_udd/ump_arch/ump_arch_lock.S b/display/libUMP-shim/arch_011_udd/ump_arch/ump_arch_lock.S
deleted file mode 100644
index f78a0ab..0000000
--- a/display/libUMP-shim/arch_011_udd/ump_arch/ump_arch_lock.S
+++ /dev/null
@@ -1,12 +0,0 @@
-.globl ump_arch_lock
-ump_arch_lock:
-    .1c58: 	mov	r2, r1
-    .1c5c: 	mov	r1, r0
-    .1c60: 	ldr	r0, [pc, #20]	// 1c7c <ump_arch_lock+0x24>
-    .1c64: 	push	{r3, lr}
-    .1c68: 	ldr	r0, [pc, r0]
-    .1c6c: 	bl	_hwmem_uku_map
-    .1c70: 	cmn	r0, #1
-    .1c74: 	moveq	r0, #0
-    .1c78: 	pop	{r3, pc}
-    .1c7c: 	andeq	r3, r0, r4, ror #7
diff --git a/display/libUMP-shim/arch_011_udd/ump_arch/ump_arch_release.S b/display/libUMP-shim/arch_011_udd/ump_arch/ump_arch_release.S
deleted file mode 100644
index b396b2f..0000000
--- a/display/libUMP-shim/arch_011_udd/ump_arch/ump_arch_release.S
+++ /dev/null
@@ -1,37 +0,0 @@
-.globl ump_arch_release
-ump_arch_release:
-    .1bdc:      mov     r1, r0
-    .1be0:      ldr     r0, [pc, #8]   // ; 1c40 <ump_arch_release+0x64>
-    .1be4:      push    {r3, lr}
-    .1be8:      ldr     r0, [pc, r0]
-    .1bec:      bl      _hwmem_uku_release
-/*
-    .1bf0:      cmp     r0, #0
-    .1bf4:      popeq   {r3, pc}
-    .1bf8:      ldr     lr, [pc, #68]   // ; 1c44 <ump_arch_release+0x68>
-    .1bfc:      add     r0, pc, lr
-    .1c00:      bl      puts@plt
-    .1c04:      ldr     r2, [pc, #60]   // ; 1c48 <ump_arch_release+0x6c>
-    .1c08:      add     r0, pc, r2
-    .1c0c:      bl      printf@plt
-    .1c10:      ldr     ip, [pc, #52]   // ; 1c4c <ump_arch_release+0x70>
-    .1c14:      ldr     r3, [pc, #52]   // ; 1c50 <ump_arch_release+0x74>
-    .1c18:      mov     r2, #167        // ; 0xa7
-    .1c1c:      add     r0, pc, ip
-    .1c20:      add     r1, pc, r3
-    .1c24:      bl      printf@plt
-    .1c28:      ldr     r1, [pc, #36]   // ; 1c54 <ump_arch_release+0x78>
-    .1c2c:      add     r0, pc, r1
-    .1c30:      bl      printf@plt
-    .1c34:      mov     r0, #10
-    .1c38:      bl      putchar@plt
-    .1c3c:      bl      abort@plt
-*/
-    .1bf0:      .word 0x00003464
-/*
-    .1c44:      .word 0x00001964
-    .1c48:      .word 0x000019a0
-    .1c4c:      .word 0x0000199c
-    .1c50:      .word 0x000018d4
-    .1c54:      .word 0x00001b38
-*/
diff --git a/display/libUMP-shim/arch_011_udd/ump_frontend.c b/display/libUMP-shim/arch_011_udd/ump_frontend.c
index 637648b..66b2095 100644
--- a/display/libUMP-shim/arch_011_udd/ump_frontend.c
+++ b/display/libUMP-shim/arch_011_udd/ump_frontend.c
@@ -21,17 +21,15 @@
  * It relies heavily on a arch backend to do the communication with the UMP device driver.
  */
 
-
-
 #include "ump.h"
 #include "ump_internal.h"
 #include "ump_arch.h"
 #include <ump/ump_debug.h>
 #include <ump/ump_osu.h>
 
-UMP_API_EXPORT void ump_open(void)
+UMP_API_EXPORT ump_result ump_open(void)
 {
-	ump_arch_open();
+	return ump_arch_open();
 }
 
 UMP_API_EXPORT void ump_close(void)
@@ -42,6 +40,7 @@ UMP_API_EXPORT void ump_close(void)
 UMP_API_EXPORT ump_secure_id ump_secure_id_get(ump_handle memh)
 {
 	ump_mem * mem = (ump_mem*)memh;
+
 	UMP_DEBUG_ASSERT(UMP_INVALID_MEMORY_HANDLE != memh, ("Handle is invalid"));
 	UMP_DEBUG_ASSERT(UMP_INVALID_SECURE_ID != mem->secure_id, ("Secure ID is inavlid"));
 	UMP_DEBUG_ASSERT(0 < mem->ref_count, ("Reference count too low"));
@@ -50,8 +49,6 @@ UMP_API_EXPORT ump_secure_id ump_secure_id_get(ump_handle memh)
 	return mem->secure_id;
 }
 
-#if 0
-
 UMP_API_EXPORT ump_handle ump_handle_create_from_secure_id(ump_secure_id secure_id)
 {
 	unsigned long size;
@@ -99,20 +96,17 @@ UMP_API_EXPORT ump_handle ump_handle_create_from_secure_id(ump_secure_id secure_
 
 	return UMP_INVALID_MEMORY_HANDLE;
 }
-#endif /* 0 */
-
 
-UMP_API_EXPORT void ump_size_get(ump_handle memh)
+UMP_API_EXPORT unsigned long ump_size_get(ump_handle memh)
 {
-	__asm__("cmp     r0, #0");
-	__asm__("bxeq    lr");
-	__asm__("ldr     r3, [r0]");
-	__asm__("cmn     r3, #1");
-	__asm__("ldrne   r0, [r0, #8]");
-	__asm__("moveq   r0, #0");
-
-	__asm__("bx      lr");
-	//return;
+	ump_mem * mem = (ump_mem*)memh;
+
+	UMP_DEBUG_ASSERT(UMP_INVALID_MEMORY_HANDLE != memh, ("Handle is invalid"));
+	UMP_DEBUG_ASSERT(UMP_INVALID_SECURE_ID != mem->secure_id, ("Secure ID is inavlid"));
+	UMP_DEBUG_ASSERT(0 < mem->ref_count, ("Reference count too low"));
+	UMP_DEBUG_ASSERT(0 < mem->size, ("Memory size of passed handle too low"));
+
+	return mem->size;
 }
 
 UMP_API_EXPORT void ump_read(void *dst, ump_handle srch, unsigned long offset, unsigned long length)
@@ -143,6 +137,36 @@ UMP_API_EXPORT void ump_write(ump_handle dsth, unsigned long offset, const void
 	_ump_osu_memcpy((char*)(dst->mapped_mem) + offset, src, length);
 }
 
+
+
+UMP_API_EXPORT void* ump_mapped_pointer_get(ump_handle memh)
+{
+	ump_mem * mem = (ump_mem*)memh;
+
+	UMP_DEBUG_ASSERT(UMP_INVALID_MEMORY_HANDLE != memh, ("Handle is invalid"));
+	UMP_DEBUG_ASSERT(UMP_INVALID_SECURE_ID != mem->secure_id, ("Secure ID is inavlid"));
+	UMP_DEBUG_ASSERT(0 < mem->ref_count, ("Reference count too low"));
+	UMP_DEBUG_ASSERT(0 < mem->size, ("Memory size of passed handle too low"));
+	UMP_DEBUG_ASSERT(NULL != mem->mapped_mem, ("Error in mapping pointer (not mapped)"));
+
+	return mem->mapped_mem;
+}
+
+
+
+UMP_API_EXPORT void ump_mapped_pointer_release(ump_handle memh)
+{
+	UMP_DEBUG_ASSERT(UMP_INVALID_MEMORY_HANDLE != memh, ("Handle is invalid"));
+	UMP_DEBUG_ASSERT(UMP_INVALID_SECURE_ID != ((ump_mem*)memh)->secure_id, ("Secure ID is inavlid"));
+	UMP_DEBUG_ASSERT(0 < ((ump_mem*)memh)->ref_count, ("Reference count too low"));
+	UMP_DEBUG_ASSERT(0 < ((ump_mem*)memh)->size, ("Memory size of passed handle too low"));
+	UMP_DEBUG_ASSERT(NULL != ((ump_mem*)memh)->mapped_mem, ("Error in mapping pointer (not mapped)"));
+
+	/* noop, cos we map in the pointer when handle is created, and unmap it when handle is destroyed */
+}
+
+
+
 UMP_API_EXPORT void ump_reference_add(ump_handle memh)
 {
 	ump_mem * mem = (ump_mem*)memh;
@@ -157,7 +181,7 @@ UMP_API_EXPORT void ump_reference_add(ump_handle memh)
 	_ump_osu_lock_signal(mem->ref_lock, _UMP_OSU_LOCKMODE_RW);
 }
 
-#if 0
+
 
 UMP_API_EXPORT void ump_reference_release(ump_handle memh)
 {
@@ -187,4 +211,3 @@ UMP_API_EXPORT void ump_reference_release(ump_handle memh)
 		_ump_osu_lock_signal(mem->ref_lock, _UMP_OSU_LOCKMODE_RW);
 	}
 }
-#endif
diff --git a/display/libUMP-shim/arch_011_udd/ump_frontend/hwmem_uku.S b/display/libUMP-shim/arch_011_udd/ump_frontend/hwmem_uku.S
deleted file mode 100644
index f4ae735..0000000
--- a/display/libUMP-shim/arch_011_udd/ump_frontend/hwmem_uku.S
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2010-2011, 2013 ARM Limited. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#if 0
-.globl _hwmem_uku_open
-.text
-.align 2
-_hwmem_uku_open:
- .1d20: push {r4, lr}
- .1d24: subs r4, r0, #0
- .1d28: beq .1d4c
- .1d2c: ldr r0, [pc, #32]
- .1d30: mov r1, #2
- .1d34: add r0, pc, r0
- .1d38: bl open@plt
- .1d3c: cmn r0, #1
- .1d40: strne r0, [r4]
- .1d44: movne r0, #0
- .1d48: pop {r4, pc}
- .1d4c: mvn r0, #0
- .1d50: pop {r4, pc}
- .1d54: andeq r1, r0, r0, lsl #21
-#endif
-
-.globl _hwmem_uku_close
-_hwmem_uku_close:
- .1d58: push {r4, lr}
- .1d5c: subs r4, r0, #0
- .1d60: beq .1d84
- .1d64: ldr r0, [r4]
- .1d68: cmn r0, #1
- .1d6c: popeq {r4, pc}
- .1d70: bl close@plt
- .1d74: mvn r3, #0
- .1d78: mov r0, #0
- .1d7c: str r3, [r4]
- .1d80: pop {r4, pc}
- .1d84: mvn r0, #0
- .1d88: pop {r4, pc}
-
-
-.globl _hwmem_uku_allocate
-_hwmem_uku_allocate:
- .1d8c: cmn r0, #1
- .1d90: mov r2, r1
- .1d94: bxeq lr
- .1d98: movw r1, #22273 /* ; 0x5701 */
- .1d9c: movt r1, #16400 /* ; 0x4010 */
- .1da0: b ioctl@plt
-
-.globl _hwmem_uku_release
-_hwmem_uku_release:
- .1da4: cmn r0, #1
- .1da8: mov r2, r1
- .1dac: bxeq lr
- .1db0: movw r1, #22275 /* ; 0x5703 */
- .1db4: b ioctl@plt
-
-.globl _hwmem_uku_import
-_hwmem_uku_import:
- .1db8: cmn r0, #1
- .1dbc: mov r2, r1
- .1dc0: bxeq lr
- .1dc4: movw r1, #22283 /* ; 0x570b */
- .1dc8: b ioctl@plt
-
-.globl _hwmem_uku_export
-_hwmem_uku_export:
- .1dcc: cmn r0, #1
- .1dd0: mov r2, r1
- .1dd4: bxeq lr
- .1dd8: movw r1, #22282 /*; 0x570a */
- .1ddc: b ioctl@plt
-
-.globl _hwmem_uku_map
-_hwmem_uku_map:
- .1de0: cmn r0, #1
- .1de4: mov ip, r0
- .1de8: push {r4, lr}
- .1dec: moveq r0, r0
- .1df0: sub sp, sp, #8
- .1df4: mov r4, r1
- .1df8: beq .1e18
- .1dfc: mov r1, r2
- .1e00: mov r0, #0
- .1e04: mov r2, #3
- .1e08: mov r3, #1
- .1e0c: str ip, [sp]
- .1e10: str r4, [sp, #4]
- .1e14: bl mmap@plt
- .1e18: add sp, sp, #8
- .1e1c: pop {r4, pc}
-
-.globl _hwmem_uku_unmap
-_hwmem_uku_unmap:
- .1e20: b munmap@plt
-
-.globl _hwmem_uku_set_sync_domain
-_hwmem_uku_set_sync_domain:
- .1e24: cmn r0, #1
- .1e28: mov r2, r1
- .1e2c: bxeq lr
- .1e30: movw r1, #22277 /* ; 0x5705 */
- .1e34: movt r1, #16412 /* ; 0x401c */
- .1e38: b ioctl@plt
-
-.globl _hwmem_uku_set_cpu_domain
-_hwmem_uku_set_cpu_domain:
- .1e3c: cmn r0, #1
- .1e40: mov r2, r1
- .1e44: bxeq lr
- .1e48: movw r1, #22276 /* ; 0x5704 */
- .1e4c: movt r1, #16412 /* ; 0x401c */
- .1e50: b ioctl@plt
-
-.globl _hwmem_uku_pin
-_hwmem_uku_pin:
-
- .1e54: cmn r0, #1
- .1e58: mov r2, r1
- .1e5c: bxeq lr
- .1e60: movw r1, #22278 /* ; 0x5706 */
- .1e64: movt r1, #49160 /* ; 0xc008 */
- .1e68: b ioctl@plt
-
-.globl _hwmem_uku_unpin
-_hwmem_uku_unpin:
- .1e6c: cmn r0, #1
- .1e70: mov r2, r1
- .1e74: bxeq lr
- .1e78: movw r1, #22279 /* ; 0x5707 */
- .1e7c: b ioctl@plt
-
-.globl _hwmem_uku_set_access
-_hwmem_uku_set_access:
- .1e80: cmn r0, #1
- .1e84: mov r2, r1
- .1e88: bxeq lr
- .1e8c: movw r1, #22280 /* ; 0x5708 */
- .1e90: movt r1, #16396 /* ; 0x400c */
- .1e94: b ioctl@plt
-
-.globl _hwmem_uku_get_info
-_hwmem_uku_get_info:
- .1e98: cmn r0, #1
- .1e9c: mov r2, r1
- .1ea0: bxeq lr
- .1ea4: movw r1, #22281 /* ; 0x5709 */
- .1ea8: movt r1, #49168 /* ; 0xc010 */
- .1eac: b ioctl@plt
diff --git a/display/libUMP-shim/arch_011_udd/ump_frontend/ump_arch_unlock.S b/display/libUMP-shim/arch_011_udd/ump_frontend/ump_arch_unlock.S
deleted file mode 100644
index 86aac5e..0000000
--- a/display/libUMP-shim/arch_011_udd/ump_frontend/ump_arch_unlock.S
+++ /dev/null
@@ -1,5 +0,0 @@
-.globl ump_arch_unlock
-ump_arch_unlock:
-    .1c80: 	mov	r0, r1
-    .1c84: 	mov	r1, r2
-    .1c88: 	b	_hwmem_uku_unmap
diff --git a/display/libUMP-shim/arch_011_udd/ump_frontend/ump_handle_create_from_secure_id.S b/display/libUMP-shim/arch_011_udd/ump_frontend/ump_handle_create_from_secure_id.S
deleted file mode 100644
index 07732c9..0000000
--- a/display/libUMP-shim/arch_011_udd/ump_frontend/ump_handle_create_from_secure_id.S
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2010-2011, 2013 ARM Limited. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-.globl ump_handle_create_from_secure_id
-ump_handle_create_from_secure_id:
- .1278: cmn r0, #1
- .127c: push {r4, r5, r6, r7, lr}
- .1280: mov r6, r0
- .1284: sub sp, sp, #12
- .1288: moveq r4, #0
- .128c: beq .130c
- .1290: add r1, sp, #4
- .1294: bl ump_arch_import
- .1298: ldr r1, [sp, #4]
- .129c: cmp r1, #0
- .12a0: moveq r4, r1
- .12a4: mov r5, r0
- .12a8: beq .130c
- .12ac: bl ump_arch_lock
- .12b0: subs r7, r0, #0
- .12b4: moveq r4, r7
- .12b8: beq .130c
- .12bc: mov r0, #1
- .12c0: mov r1, #28
- .12c4: bl _ump_osu_calloc
- .12c8: subs r4, r0, #0
- .12cc: beq .1318
- .12d0: ldr r3, [sp, #4]
- .12d4: mov r1, #0
- .12d8: str r6, [r4]
- .12dc: add r0, r4, #12
- .12e0: str r7, [r4, #4]
- .12e4: mov r2, r1
- .12e8: str r3, [r4, #8]
- .12ec: mov r3, r1
- .12f0: str r5, [r4, #20]
- .12f4: bl _ump_osu_lock_auto_init
- .12f8: ldr r3, [r4, #12]
- .12fc: cmp r3, #0
- .1300: movne r3, #1
- .1304: strne r3, [r4, #16]
- .1308: beq .1334
- .130c: mov r0, r4
- .1310: add sp, sp, #12
- .1314: pop {r4, r5, r6, r7, pc}
- .1318: mov r0, r5
- .131c: mov r1, r7
- .1320: ldr r2, [sp, #4]
- .1324: bl ump_arch_unlock
- .1328: mov r0, r5
- .132c: bl ump_arch_release
- .1330: b .130c
- .1334: mov r4, r3
- .1338: b .130c
diff --git a/display/libUMP-shim/arch_011_udd/ump_frontend/ump_mapped_pointer_get.S b/display/libUMP-shim/arch_011_udd/ump_frontend/ump_mapped_pointer_get.S
deleted file mode 100644
index 7f74115..0000000
--- a/display/libUMP-shim/arch_011_udd/ump_frontend/ump_mapped_pointer_get.S
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2010-2011, 2013 ARM Limited. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
-000013b4 <ump_mapped_pointer_get>:
-    13b4:	e92d4010 	push	{r4, lr}
-    13b8:	e2504000 	subs	r4, r0, #0
-    13bc:	01a00004 	moveq	r0, r4
-    13c0:	08bd8010 	popeq	{r4, pc}
-    13c4:	e5943000 	ldr	r3, [r4]
-    13c8:	e3730001 	cmn	r3, #1
-    13cc:	0a00001a 	beq	143c <ump_mapped_pointer_get+0x88>
-    13d0:	e5940004 	ldr	r0, [r4, #4]
-    13d4:	e3500000 	cmp	r0, #0
-    13d8:	18bd8010 	popne	{r4, pc}
-    13dc:	e5940014 	ldr	r0, [r4, #20]
-    13e0:	e5941008 	ldr	r1, [r4, #8]
-    13e4:	eb00021b 	bl	1c58 <ump_arch_lock>
-    13e8:	e3500000 	cmp	r0, #0
-    13ec:	e5840004 	str	r0, [r4, #4]
-    13f0:	18bd8010 	popne	{r4, pc}
-    13f4:	e59fc048 	ldr	ip, [pc, #72]	; 1444 <ump_mapped_pointer_get+0x90>
-    13f8:	e59f4048 	ldr	r4, [pc, #72]	; 1448 <ump_mapped_pointer_get+0x94>
-    13fc:	e08f000c 	add	r0, pc, ip
-    1400:	ebffff39 	bl	10ec <puts@plt>
-    1404:	e59f2040 	ldr	r2, [pc, #64]	; 144c <ump_mapped_pointer_get+0x98>
-    1408:	e08f0002 	add	r0, pc, r2
-    140c:	ebffff39 	bl	10f8 <printf@plt>
-    1410:	e59f1038 	ldr	r1, [pc, #56]	; 1450 <ump_mapped_pointer_get+0x9c>
-    1414:	e3a02092 	mov	r2, #146	; 0x92
-    1418:	e08f0004 	add	r0, pc, r4
-    141c:	e08f1001 	add	r1, pc, r1
-    1420:	ebffff34 	bl	10f8 <printf@plt>
-    1424:	e59f0028 	ldr	r0, [pc, #40]	; 1454 <ump_mapped_pointer_get+0xa0>
-    1428:	e08f0000 	add	r0, pc, r0
-    142c:	ebffff31 	bl	10f8 <printf@plt>
-    1430:	e3a0000a 	mov	r0, #10
-    1434:	ebffff32 	bl	1104 <putchar@plt>
-    1438:	ebffff34 	bl	1110 <abort@plt>
-    143c:	e3a00000 	mov	r0, #0
-    1440:	e8bd8010 	pop	{r4, pc}
-    1444:	00001e2c 	andeq	r1, r0, ip, lsr #28
-    1448:	00001e68 	andeq	r1, r0, r8, ror #28
-    144c:	00001e68 	andeq	r1, r0, r8, ror #28
-    1450:	00001f18 	andeq	r1, r0, r8, lsl pc
-    1454:	00001ee4 	andeq	r1, r0, r4, ror #29
-
-*/
-
-.globl ump_mapped_pointer_get
-.text
-.align 2
-ump_mapped_pointer_get:
-    .13b4:	push	{r4, lr}
-    .13b8:	subs	r4, r0, #0
-    .13bc:	moveq	r0, r4
-    .13c0:	popeq	{r4, pc}
-    .13c4:	ldr	r3, [r4]
-    .13c8:	cmn	r3, #1
-    .13cc:	beq	.143c
-    .13d0:	ldr	r0, [r4, #4]
-    .13d4:	cmp	r0, #0
-    .13d8:	popne	{r4, pc}
-    .13dc:	ldr	r0, [r4, #20]
-    .13e0:	ldr	r1, [r4, #8]
-    .13e4:	bl	ump_arch_lock
-    .13e8:	cmp	r0, #0
-    .13ec:	str	r0, [r4, #4]
-    .13f0:	popne	{r4, pc}
-    .13f4:	ldr	ip, [pc, #72]	/* 1444 <ump_mapped_pointer_get+0x90> */
-    .13f8:	ldr	r4, [pc, #72]	/* 1448 <ump_mapped_pointer_get+0x94> */
-    .13fc:	add	r0, pc, ip
-    .1400:	bl	puts@plt
-    .1404:	ldr	r2, [pc, #64]	/* 144c <ump_mapped_pointer_get+0x98> */
-    .1408:	add	r0, pc, r2
-    .140c:	bl	printf@plt
-    .1410:	ldr	r1, [pc, #56]	/* 1450 <ump_mapped_pointer_get+0x9c> */
-    .1414:	mov	r2, #146	/* 0x92 */
-    .1418:	add	r0, pc, r4
-    .141c:	add	r1, pc, r1
-    .1420:	bl	printf@plt
-    .1424:	ldr	r0, [pc, #40]	/* 1454 <ump_mapped_pointer_get+0xa0> */
-    .1428:	add	r0, pc, r0
-    .142c:	bl	printf@plt
-    .1430:	mov	r0, #10
-    .1434:	bl	putchar@plt
-    .1438:	bl	abort@plt
-    .143c:	mov	r0, #0
-    .1440:	pop	{r4, pc}
-    .1444:	andeq	r1, r0, ip, lsr #28
-    .1448:	andeq	r1, r0, r8, ror #28
-    .144c:	andeq	r1, r0, r8, ror #28
-    .1450:	andeq	r1, r0, r8, lsl pc
-    .1454:	andeq	r1, r0, r4, ror #29
diff --git a/display/libUMP-shim/arch_011_udd/ump_frontend/ump_mapped_pointer_release.S b/display/libUMP-shim/arch_011_udd/ump_frontend/ump_mapped_pointer_release.S
deleted file mode 100644
index f02cb3d..0000000
--- a/display/libUMP-shim/arch_011_udd/ump_frontend/ump_mapped_pointer_release.S
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2010-2011, 2013 ARM Limited. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/*
- *	00001458 <ump_mapped_pointer_release>:
- *	    1458:       e5901004        ldr     r1, [r0, #4]
- *	    145c:       e92d4010        push    {r4, lr}
- *	    1460:       e3510000        cmp     r1, #0
- *	    1464:       e1a04000        mov     r4, r0
- *	    1468:       0a000002        beq     1478 <ump_mapped_pointer_release+0x20>
- *	    146c:       e5900014        ldr     r0, [r0, #20]
- *	    1470:       e5942008        ldr     r2, [r4, #8]
- *	    1474:       eb000201        bl      1c80 <ump_arch_unlock>
- *	    1478:       e3a03000        mov     r3, #0
- *	    147c:       e5843004        str     r3, [r4, #4]
- *	    1480:       e8bd8010        pop     {r4, pc}
- */
-
-
-.globl ump_mapped_pointer_release
-.text
-.align 2
-ump_mapped_pointer_release:
-        ldr     r1, [r0, #4]
-        push    {r4, lr}
-        cmp     r1, #0
-        mov     r4, r0
-        beq	.out
-        ldr     r0, [r0, #20]
-        ldr     r2, [r4, #8]
-        bl ump_arch_unlock
-.out:
-        mov     r3, #0
-        str     r3, [r4, #4]
-        pop     {r4, pc}
diff --git a/display/libUMP-shim/arch_011_udd/ump_frontend/ump_reference_release.S b/display/libUMP-shim/arch_011_udd/ump_frontend/ump_reference_release.S
deleted file mode 100644
index 4e37f6f..0000000
--- a/display/libUMP-shim/arch_011_udd/ump_frontend/ump_reference_release.S
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2010-2011, 2013 ARM Limited. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-.globl ump_reference_release
-ump_reference_release:
-    .14c4:	 	push	{r3, r4, r5, lr}
-    .14c8:	 	subs	r4, r0, #0
-    .14cc:	 	popeq	{r3, r4, r5, pc}
-    .14d0:	 	ldr	r3, [r4]
-    .14d4:	 	cmn	r3, #1
-    .14d8:	 	popeq	{r3, r4, r5, pc}
-    .14dc:	 	ldr	r0, [r4, #12]
-    .14e0:	 	mov	r1, #0
-    .14e4:	 	bl	_ump_osu_lock_wait
-    .14e8:	 	ldr	r5, [r4, #16]
-    .14ec:		sub	r5, r5, #1
-    .14f0:	 	str	r5, [r4, #16]
-    .14f4:	 	cmp	r5, #0
-    .14f8:	 	beq	.150c
-    .14fc:	 	ldr	r0, [r4, #12]
-    .1500:	 	mov	r1, #0
-    .1504:	 	pop	{r3, r4, r5, lr}
-    .1508:	 	b	_ump_osu_lock_signal
-    .150c:	 	ldr	r0, [r4, #20]
-    .1510:	 	bl	ump_arch_release
-    .1514:	 	ldr	r0, [r4, #12]
-    .1518:	 	mov	r1, r5
-    .151c:	 	bl	_ump_osu_lock_signal
-    .1520:	 	ldr	r0, [r4, #12]
-    .1524:	 	bl	_ump_osu_lock_term
-    .1528:	 	mov	r0, r4
-    .152c:	 	pop	{r3, r4, r5, lr}
-    .1530:	 	b	_ump_osu_free
diff --git a/display/libUMP-shim/arch_011_udd/ump_ref_drv.c b/display/libUMP-shim/arch_011_udd/ump_ref_drv.c
index 328da91..7b480f3 100644
--- a/display/libUMP-shim/arch_011_udd/ump_ref_drv.c
+++ b/display/libUMP-shim/arch_011_udd/ump_ref_drv.c
@@ -29,9 +29,9 @@
 
 /* Allocate a buffer which can be used directly by hardware, 4kb aligned */
 static ump_handle ump_ref_drv_allocate_internal(unsigned long size, ump_alloc_constraints constraints, ump_cache_enabled cache);
-//static ump_handle ump_ref_drv_ion_import_internal(int ion_fd, ump_alloc_constraints constraints, ump_cache_enabled cache);
+static ump_handle ump_ref_drv_ion_import_internal(int ion_fd, ump_alloc_constraints constraints, ump_cache_enabled cache);
+
 
-#if 0
 /* Allocate a buffer which can be used directly by hardware, 4kb aligned */
 ump_handle ump_ref_drv_allocate(unsigned long size, ump_alloc_constraints constraints)
 {
@@ -42,9 +42,7 @@ ump_handle ump_ref_drv_allocate(unsigned long size, ump_alloc_constraints constr
 	}
 	return ump_ref_drv_allocate_internal(size, constraints, cache);
 }
-#endif
 
-#if 0
 ump_handle ump_ref_drv_ion_import(int ion_fd, ump_alloc_constraints constraints)
 {
     ump_cache_enabled cache= UMP_CACHE_DISABLE;
@@ -54,7 +52,6 @@ ump_handle ump_ref_drv_ion_import(int ion_fd, ump_alloc_constraints constraints)
     }
     return ump_ref_drv_ion_import_internal(ion_fd, constraints, cache);
 }
-#endif
 
 UMP_API_EXPORT int ump_cpu_msync_now(ump_handle memh, ump_cpu_msync_op op, void* address, int size)
 {
@@ -102,46 +99,37 @@ UMP_API_EXPORT int ump_switch_hw_usage( ump_handle memh, ump_hw_usage new_user )
 	return ump_arch_switch_hw_usage(mem->secure_id, new_user);
 }
 
-/*
 UMP_API_EXPORT int ump_lock( ump_handle memh, ump_lock_usage lock_usage)
 {
 	ump_mem * mem = (ump_mem*)memh;
 	UMP_DEBUG_ASSERT(UMP_INVALID_MEMORY_HANDLE != memh, ("Handle is invalid"));
 	return ump_arch_lock(mem->secure_id, lock_usage);
 }
-*/
 
-/*
 UMP_API_EXPORT int ump_unlock( ump_handle memh )
 {
 	ump_mem * mem = (ump_mem*)memh;
 	UMP_DEBUG_ASSERT(UMP_INVALID_MEMORY_HANDLE != memh, ("Handle is invalid"));
 	return ump_arch_unlock(mem->secure_id);
 }
-*/
 
 UMP_API_EXPORT int ump_switch_hw_usage_secure_id( ump_secure_id ump_id, ump_hw_usage new_user )
 {
 	return ump_arch_switch_hw_usage(ump_id, new_user);
 }
 
-#if 0
 /** Locking buffer. Blocking call if the buffer is already locked. */
 UMP_API_EXPORT int ump_lock_secure_id( ump_secure_id ump_id, ump_lock_usage lock_usage )
 {
 	return ump_arch_lock(ump_id, lock_usage);
 }
-#endif
 
 /** Unlocking buffer. Let other users lock the buffer for their usage */
-/*
 UMP_API_EXPORT int ump_unlock_secure_id( ump_secure_id ump_id )
 {
 	return ump_arch_unlock(ump_id);
 }
-*/
 
-#if 0
 /* Allocate a buffer which can be used directly by hardware, 4kb aligned */
 static ump_handle ump_ref_drv_allocate_internal(unsigned long size, ump_alloc_constraints constraints, ump_cache_enabled cache)
 {
@@ -182,7 +170,7 @@ static ump_handle ump_ref_drv_allocate_internal(unsigned long size, ump_alloc_co
 				 * We release the one from ump_arch_allocate(), and rely solely on the one from the ump_arch_map()
 				 * That is, ump_arch_unmap() should now do the final release towards the UMP kernel space driver.
 				 */
-				ump_arch_release(secure_id);
+				ump_arch_reference_release(secure_id);
 
 				/* This is called only to set the cache settings in this handle */
 				ump_cpu_msync_now((ump_handle)mem, UMP_MSYNC_READOUT_CACHE_ENABLED, NULL, 0);
@@ -193,18 +181,16 @@ static ump_handle ump_ref_drv_allocate_internal(unsigned long size, ump_alloc_co
 			}
 
 			ump_arch_unmap(mapping, allocated_size, cookie); /* Unmap the memory */
-			ump_arch_release(secure_id); /* Release reference added when we allocated the UMP memory */
+			ump_arch_reference_release(secure_id); /* Release reference added when we allocated the UMP memory */
 		}
 
-		ump_arch_release(secure_id); /* Release reference added when we allocated the UMP memory */
+		ump_arch_reference_release(secure_id); /* Release reference added when we allocated the UMP memory */
 	}
 
 	UMP_DEBUG_PRINT(4, ("Allocation of UMP memory failed"));
 	return UMP_INVALID_MEMORY_HANDLE;
 }
-#endif
 
-#if 0
 static ump_handle ump_ref_drv_ion_import_internal(int ion_fd, ump_alloc_constraints constraints, ump_cache_enabled cache)
 {
     ump_secure_id secure_id;
@@ -266,4 +252,3 @@ static ump_handle ump_ref_drv_ion_import_internal(int ion_fd, ump_alloc_constrai
     UMP_DEBUG_PRINT(4, ("Allocation of UMP memory failed"));
     return UMP_INVALID_MEMORY_HANDLE;
 }
-#endif
diff --git a/display/libUMP-shim/os/linux/ump_uku.c b/display/libUMP-shim/os/linux/ump_uku.c
index 64954dc..6bca7a4 100644
--- a/display/libUMP-shim/os/linux/ump_uku.c
+++ b/display/libUMP-shim/os/linux/ump_uku.c
@@ -41,9 +41,9 @@ static int ump_ioctl_api_version_used = UMP_IOCTL_API_VERSION;
  * This is a character special file giving access to the device driver.
  * Usually created using the mknod command line utility.
  */
-static const char ump_device_file_name[] = "/dev/hwmem";
+static const char ump_device_file_name[] = "/dev/ump";
 
-_ump_osu_errcode_t _hwmem_uku_open( void **context )
+_ump_osu_errcode_t _ump_uku_open( void **context )
 {
 	int ump_device_file;
 	if(NULL == context)
@@ -58,6 +58,28 @@ _ump_osu_errcode_t _hwmem_uku_open( void **context )
 		return _UMP_OSU_ERR_FAULT;
 	}
 
+	{
+		struct _ump_uk_api_version_s args;
+		args.ctx     = (void*)ump_device_file;
+		args.version = UMP_IOCTL_API_VERSION;
+		args.compatible = 3;
+		ump_driver_ioctl(args.ctx, UMP_IOC_QUERY_API_VERSION, &args);
+		if ( 1 != args.compatible )
+		{
+			if (IS_API_MATCH(MAKE_VERSION_ID(1), args.version))
+			{
+				ump_ioctl_api_version_used = MAKE_VERSION_ID(1);
+				UMP_PRINTF("The UMP devicedriver does not support cached UMP. Update it if this is needed.\n");
+			}
+			else
+			{
+				UMP_PRINTF("The UMP devicedriver is version: %d, UMP libraries is version: %d.\n", GET_VERSION(args.version), GET_VERSION(UMP_IOCTL_API_VERSION) );
+			   close(ump_device_file);
+			   return _UMP_OSU_ERR_FAULT;
+			}
+		}
+	}
+
 	*context = (void *) ump_device_file;
 	return _UMP_OSU_ERR_OK;
 }
diff --git a/display/libUMP-shim/os/ump_uku.h b/display/libUMP-shim/os/ump_uku.h
index 077cd9d..4940932 100644
--- a/display/libUMP-shim/os/ump_uku.h
+++ b/display/libUMP-shim/os/ump_uku.h
@@ -31,7 +31,7 @@ extern "C"
 {
 #endif
 
-_ump_osu_errcode_t _hwmem_uku_open( void **context );
+_ump_osu_errcode_t _ump_uku_open( void **context );
 
 _ump_osu_errcode_t _ump_uku_close( void **context );
 
diff --git a/display/libUMP-shim/shim.c b/display/libUMP-shim/shim.c
deleted file mode 100644
index 40c5603..0000000
--- a/display/libUMP-shim/shim.c
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "libUMP-shim"
-
-#include "ump.h"
-#include "arch_011_udd/ump_arch.h"
-#include <ump/ump_debug.h>
-
-#include <ump/ump_uk_types.h>
-#include "os/ump_uku.h"
-
-#include <cutils/log.h>
-
-#include <dlfcn.h>
-#include <errno.h>
-
-
-#include "shim.h"
-
-
-
-/* libUMP-shim constructor / destructor */
-
-void libEvtLoading(void) __attribute__((constructor));
-void libEvtUnloading(void) __attribute__((destructor));
-
-/* wrapped library handle */
-
-static void *realLibHandle;
-
-/* wrapped callbacks */
-
-/* arch */
-
-ump_result (*fReal_ump_arch_open)(void);
-void (*fReal_ump_arch_close)(void);
-//ump_secure_id (*fReal_ump_arch_allocate)(unsigned long * size, ump_alloc_constraints constraints);
-//int (*fReal_ump_arch_lock)( ump_secure_id secure_id, ump_lock_usage lock_usage );
-//int (*fReal_ump_arch_unlock)( ump_secure_id secure_id );
-
-//ump_cache_enabled (*fReal_ump_arch_msync)(ump_secure_id secure_id, void* mapping, unsigned long cookie,
-//	 void * address, unsigned long size,  ump_cpu_msync_op op);
-
-void (*fReal_ump_arch_release)(ump_secure_id secure_id);
-
-//ump_secure_id (*fReal_ump_arch_import)(void);
-//ump_secure_id (*fReal_ump_arch_export)(ump_secure_id secure_id);
-
-
-/* frontend */
-
-//UMP_API_EXPORT unsigned long (*fReal_ump_size_get)(ump_handle memh);
-//UMP_API_EXPORT ump_result  (*fReal_ump_open)(void);
-//UMP_API_EXPORT void (*fReal_ump_close)(void);
-//UMP_API_EXPORT ump_secure_id (*fReal_ump_secure_id_get)(ump_handle memh);
-UMP_API_EXPORT ump_handle (*fReal_ump_handle_create_from_secure_id)(ump_secure_id secure_id);
-//UMP_API_EXPORT void (*fReal_ump_read)(void *dst, ump_handle srch, unsigned long offset, unsigned long length);
-//UMP_API_EXPORT void (*fReal_ump_write)(ump_handle dsth, unsigned long offset, const void *src, unsigned long length);
-UMP_API_EXPORT void* (*fReal_ump_mapped_pointer_get)(ump_handle memh);
-//UMP_API_EXPORT void (*fReal_ump_mapped_pointer_release)(ump_handle memh);
-//UMP_API_EXPORT void (*fReal_ump_reference_add)(ump_handle memh);
-//UMP_API_EXPORT void (*fReal_ump_reference_release)(ump_handle memh);
-
-/******************************************************************************************************************************/
-
-
-void libEvtLoading(void)
-{
-
-        realLibHandle = dlopen(REAL_LIB_NAME, RTLD_LOCAL);
-        if (!realLibHandle) {
-                RLOGE("Failed to load the real LIB '" REAL_LIB_NAME  "': %s\n", dlerror());
-                return;
-        }
-        // load the real lib
-	LOAD_SYMBOL(fReal_ump_arch_open, "ump_arch_open");
-	LOAD_SYMBOL(fReal_ump_arch_close, "ump_arch_close");
-	//LOAD_SYMBOL(fReal_ump_arch_allocate, "ump_arch_allocate");
-	//LOAD_SYMBOL(fReal_ump_arch_lock, "ump_arch_lock");
-	//LOAD_SYMBOL(fReal_ump_arch_unlock, "ump_arch_unlock");
-	//LOAD_SYMBOL(fReal_ump_arch_msync, "ump_arch_msync");
-	LOAD_SYMBOL(fReal_ump_arch_release, "ump_arch_release");
-	//LOAD_SYMBOL(fReal_ump_arch_import, "ump_arch_import");
-	//LOAD_SYMBOL(fReal_ump_arch_export, "ump_arch_export");
-	//LOAD_SYMBOL(fReal_ump_size_get, "ump_size_get");
-        //LOAD_SYMBOL(fReal_ump_open, "ump_open");
-        //LOAD_SYMBOL(fReal_ump_close, "ump_close");
-        //LOAD_SYMBOL(fReal_ump_secure_id_get, "ump_secure_id_get");
-        LOAD_SYMBOL(fReal_ump_handle_create_from_secure_id, "ump_handle_create_from_secure_id");
-        //LOAD_SYMBOL(fReal_ump_read, "ump_read");
-        //LOAD_SYMBOL(fReal_ump_write, "ump_write");
-        LOAD_SYMBOL(fReal_ump_mapped_pointer_get, "ump_mapped_pointer_get");
-        //LOAD_SYMBOL(fReal_ump_mapped_pointer_release, "ump_mapped_pointer_release");
-	//LOAD_SYMBOL(fReal_ump_reference_add, "ump_reference_add");
-	//LOAD_SYMBOL(fReal_ump_reference_release, "ump_reference_release");
-
-	return;
-
-out_fail:
-	dlclose(realLibHandle);
-}
-
-void libEvtUnloading(void)
-{
-	if (realLibHandle)
-		 dlclose(realLibHandle);
-}
-
-/* arch */
-
-#ifndef TEST
-WRAP_FUNCTION(ump_result, ump_arch_open, (void), (), fReal_ump_arch_open)
-WRAP_VOID_FUNCTION(ump_arch_close, (void), (), fReal_ump_arch_close)
-//WRAP_FUNCTION(ump_secure_id, ump_arch_allocate, (unsigned long * size, ump_alloc_constraints constraints),
-//		(size, constraints), fReal_ump_arch_allocate)
-
-//WRAP_FUNCTION(int, ump_arch_lock, (ump_secure_id secure_id, ump_lock_usage lock_usage),
-//		(secure_id, lock_usage), fReal_ump_arch_lock)
-
-//WRAP_FUNCTION(int, ump_arch_unlock, (ump_secure_id secure_id), (secure_id), fReal_ump_arch_unlock)
-
-//WRAP_FUNCTION(ump_cache_enabled, ump_arch_msync, (ump_secure_id secure_id, void* mapping, unsigned long cookie,
-//		void * address, unsigned long size,  ump_cpu_msync_op op),
-//		(secure_id, mapping, cookie, address, size, op), fReal_ump_arch_msync)
-
-WRAP_VOID_FUNCTION(ump_arch_release, (ump_secure_id secure_id), (secure_id), fReal_ump_arch_release)
-#endif
-
-//WRAP_FUNCTION(ump_secure_id, ump_arch_import, (void), (), fReal_ump_arch_import)
-//WRAP_FUNCTION(ump_secure_id, ump_arch_export, (ump_secure_id secure_id), (secure_id), fReal_ump_arch_export)
-
-/* frontend */
-
-//WRAP_FUNCTION(unsigned long, ump_size_get, (ump_handle memh), (memh), fReal_ump_size_get)
-
-//WRAP_FUNCTION(ump_result, ump_open, (void), (), fReal_ump_open)
-//WRAP_VOID_FUNCTION(ump_close, (void), (), fReal_ump_close)
-
-//WRAP_FUNCTION(ump_secure_id, ump_secure_id_get, (ump_handle memh), (memh), fReal_ump_secure_id_get)
-WRAP_FUNCTION(ump_handle, ump_handle_create_from_secure_id, (ump_secure_id secure_id), (secure_id), fReal_ump_handle_create_from_secure_id)
-
-//WRAP_VOID_FUNCTION(ump_read, (void *dst, ump_handle srch, unsigned long offset, unsigned long length),
-//		(dst, srch, offset, length), fReal_ump_read)
-
-//WRAP_VOID_FUNCTION(ump_write, (ump_handle dsth, unsigned long offset, const void *src, unsigned long length),
-//		(dsth, offset, src, length), fReal_ump_write)
-
-WRAP_FUNCTION(void*, ump_mapped_pointer_get, (ump_handle memh), (memh), fReal_ump_mapped_pointer_get)
-//WRAP_VOID_FUNCTION(ump_mapped_pointer_release, (ump_handle memh), (memh), fReal_ump_mapped_pointer_release)
-//WRAP_VOID_FUNCTION(ump_reference_add, (ump_handle memh), (memh), fReal_ump_reference_add)
-//WRAP_VOID_FUNCTION(ump_reference_release, (ump_handle memh), (memh), fReal_ump_reference_release)
diff --git a/display/libUMP-shim/shim.h b/display/libUMP-shim/shim.h
deleted file mode 100644
index 797560c..0000000
--- a/display/libUMP-shim/shim.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef SHIM_H
-#define SHIM_H
-
-#define REAL_LIB_NAME                           "/system/lib/libUMP-old.so"
-
-#define LOAD_SYMBOL(shim_symbol, real_symbol)				 \
-	shim_symbol = dlsym(realLibHandle, real_symbol);		 \
-	if (!shim_symbol) { 						 \
-                RLOGE("Failed to find the real %s\n", real_symbol);	 \
-                goto out_fail;						 \
-        }
-
-#define  WRAP_FUNCTION(type, name, args_declare, args_return, real_function)  \
-	type name args_declare { 					      \
-		return real_function args_return;			      \
-	}
-
-#define  WRAP_VOID_FUNCTION(name, args_declare, args_return, real_function)   \
-	void name args_declare { 					      \
-		real_function args_return;				      \
-	}
-
-#endif
diff --git a/display/libgralloc/Android.mk b/display/libgralloc/Android.mk
index 0da6f3b..e835d07 100644
--- a/display/libgralloc/Android.mk
+++ b/display/libgralloc/Android.mk
@@ -20,14 +20,15 @@ LOCAL_PATH := $(call my-dir)
 # hw/<OVERLAY_HARDWARE_MODULE_ID>.<ro.product.board>.so
 include $(CLEAR_VARS)
 LOCAL_PRELINK_MODULE := false
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)
 LOCAL_SHARED_LIBRARIES := liblog libcutils libGLESv1_CM
 
 LOCAL_SRC_FILES := 	\
-	hwmem_gralloc.c hwmem_gralloc_pmem.c hwmem_gralloc_framebuffer.c
+	hwmem_gralloc.cpp hwmem_gralloc_framebuffer.cpp hwmem_gralloc_pmem.cpp
 
 LOCAL_C_INCLUDES += $(MULTIMEDIA_PATH)/linux/b2r2lib/include $(MULTIMEDIA_PATH)
-LOCAL_MODULE := gralloc.$(TARGET_BOARD_PLATFORM)
+LOCAL_MODULE := libgralloc-shim
 LOCAL_MODULE_TAGS := optional
-LOCAL_CFLAGS:= -DLOG_TAG=\"gralloc\" -std=gnu99
+LOCAL_CLANG := true
+LOCAL_CFLAGS:= -DLOG_TAG=\"gralloc\"
 include $(BUILD_SHARED_LIBRARY)
diff --git a/display/libgralloc/hwmem_gralloc.c b/display/libgralloc/hwmem_gralloc.c
deleted file mode 100644
index 5fb90e3..0000000
--- a/display/libgralloc/hwmem_gralloc.c
+++ /dev/null
@@ -1,1888 +0,0 @@
-/*
- * Copyright (C) ST-Ericsson AB 2010
- *
- * \file    hwmem_gralloc.c
- * \brief   Gralloc implementation that uses hwmem
- * \author  Johan Mossberg <johan.xx.mossberg@stericsson.com> and
- * Fredrik Allansson <fredrik.allansson@stericsson.com> for ST-Ericsson
- *
- */
-
-
-/*
- * IMPLEMENTATION SHORTCOMINGS
- * - The implementation assumes ints are 32 bit.
- */
-
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <errno.h>
-#include <limits.h>
-#include <linux/hwmem.h>
-#include <string.h>
-#include <stdarg.h>
-
-#include <cutils/native_handle.h>
-
-#include <cutils/atomic.h>
-#include <cutils/log.h>
-#include <cutils/threads.h>
-#include <cutils/hashmap.h>
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-#include <system/graphics.h>
-#include "gralloc_stericsson_ext.h"
-
-#include "hwmem_gralloc.h"
-#include "hwmem_gralloc_pmem.h"
-#include "hwmem_gralloc_framebuffer.h"
-
-
-#if defined(INT_MAX) && INT_MAX != 2147483647
-    #error "Hwmem gralloc only supports 32 bit ints"
-#endif
-
-
-/* Use these macro when it's probably a user error. */
-#define LOG_USER_ERROR_ALWAYS(...) ALOGE("[User error] " __VA_ARGS__);
-
-#ifndef LOG_USER_ERROR
-#define LOG_USER_ERROR(...) ALOGE("[User error] " __VA_ARGS__);
-#endif
-
-#ifndef LOG_ERROR
-#define LOG_ERROR(...) ALOGE(__VA_ARGS__);
-#endif
-
-#define LOG_WARNING_ALWAYS(...) ALOGW(__VA_ARGS__);
-
-#ifndef LOG_API_CALL
-/* #define LOG_API_CALL(...) ALOGI(__VA_ARGS__); */
-#define LOG_API_CALL(...)
-#endif
-
-
-enum buf_counters
-{
-    REGISTER_COUNTER,
-    LOCK_COUNTER
-};
-
-struct buf_tg_info
-{
-    void *addr;
-    int mmap_prot;
-    int reg_cnt;
-    int lock_cnt;
-};
-
-
-const int num_fds_in_hwmem_gralloc_buf_handle = 1;
-const int num_ints_in_hwmem_gralloc_buf_handle = 14;
-const int hwmem_gralloc_buf_handle_type_identifier = 0xA63B8FF0;
-
-
-static const char hwmem_files_full_name[] = "/dev/" HWMEM_DEFAULT_DEVICE_NAME;
-
-/* To ensure we don't get overflows in the width + height + format -> size calculations. Should
-be isqrt(INT_MAX / max_bpp) but isqrt does not seem to exist. The value below is the result of
-the previous calculation when INT_MAX = 2147483647 and max_bpp = 32 which is currently correct. */
-static const int max_width_height = 8191;
-
-static mutex_t buf_tg_infos_mutex = MUTEX_INITIALIZER;
-static Hashmap *buf_handl_2_tg_info_map = NULL;
-
-
-/* Gralloc module API functions */
-static int gralloc_open_device(const struct hw_module_t* module, const char* name,
-    struct hw_device_t** device);
-
-static int gralloc_register_buffer(struct gralloc_module_t const* module, buffer_handle_t handle);
-static int gralloc_unregister_buffer(struct gralloc_module_t const* module, buffer_handle_t handle);
-
-static int gralloc_lock(struct gralloc_module_t const* module, buffer_handle_t handle, int usage,
-    int left, int top, int width, int height, void** addr);
-static int gralloc_unlock(struct gralloc_module_t const* module, buffer_handle_t handle);
-
-static int gralloc_perform(struct gralloc_module_t const* module, int operation, ...);
-
-static int gralloc_create_handle_from_buffer(int fd, size_t size, size_t offset, void* base,
-    native_handle_t** handle);
-
-static int gralloc_get_buf_allocator_handle(struct gralloc_module_t const* module,
-    buffer_handle_t handle);
-
-static int gralloc_pin_buf(struct gralloc_module_t const *module,
-    buffer_handle_t handle);
-
-static int gralloc_unpin_buf(struct gralloc_module_t const *module,
-    buffer_handle_t handle);
-
-static int gralloc_get_buf_offset(struct gralloc_module_t const* module,
-    buffer_handle_t handle);
-
-static int gralloc_get_buf_type(struct gralloc_module_t const* module,
-    buffer_handle_t handle);
-
-static int gralloc_get_buf_size(struct gralloc_module_t const* module,
-    buffer_handle_t handle);
-
-static int gralloc_get_buf_width(struct gralloc_module_t const* module,
-    buffer_handle_t handle);
-
-static int gralloc_get_buf_height(struct gralloc_module_t const* module,
-    buffer_handle_t handle);
-
-static int gralloc_get_buf_format(struct gralloc_module_t const* module,
-    buffer_handle_t handle);
-
-static int gralloc_get_buf_usage(struct gralloc_module_t const* module,
-    buffer_handle_t handle);
-
-
-static struct hw_module_methods_t hwmem_gralloc_module_methods = {
-        open: gralloc_open_device
-};
-
-struct hwmem_gralloc_module_t HAL_MODULE_INFO_SYM =
-{
-    base:
-    {
-        common:
-        {
-            tag: HARDWARE_MODULE_TAG,
-            version_major: 1,
-            version_minor: 0,
-            id: GRALLOC_HARDWARE_MODULE_ID,
-            name: "Graphics Memory Allocator Module",
-            author: "ST-Ericsson",
-            methods: &hwmem_gralloc_module_methods
-        },
-        registerBuffer: gralloc_register_buffer,
-        unregisterBuffer: gralloc_unregister_buffer,
-        lock: gralloc_lock,
-        unlock: gralloc_unlock,
-        perform: gralloc_perform
-    },
-    type_identifier: (int)HWMEM_GRALLOC_MODULE_TYPE_IDENTIFIER,
-    framebuffer: 0,
-    flags: 0,
-    numBuffers: 0,
-    bufferMask: 0,
-    lock: PTHREAD_MUTEX_INITIALIZER,
-    currentBuffer: 0
-};
-
-
-/* Gralloc module alloc device API functions */
-static int gralloc_alloc(struct alloc_device_t* device, int width, int height, int format,
-    int usage, buffer_handle_t* handle, int* stride);
-static int gralloc_free(struct alloc_device_t* device, buffer_handle_t handle);
-
-static int open_alloc_device(const struct hwmem_gralloc_module_t* module,
-    struct alloc_device_t** alloc_device);
-static int gralloc_close_alloc_device(struct hw_device_t* device);
-
-/* Hwmem API wrappers */
-static int set_buffer_domain(struct hwmem_gralloc_buf_handle_t* buf, int usage, int left,
-    int top, int width, int height);
-
-/* Mmap */
-static int mmap_buf_if_necessary(struct hwmem_gralloc_buf_handle_t *buf, void **addr,
-    int *mmap_prot);
-/* buf_tg_infos_mutex must be held when calling this function */
-static void munmap_buf_if_necessary(struct hwmem_gralloc_buf_handle_t* buf);
-
-/* Helpers */
-static enum hwmem_access usage_2_hwmem_access(int usage);
-
-static int does_lock_usage_match_alloc_usage(int lock_usage, int alloc_usage);
-static int does_usage_match_mmap_prot(int usage, int mmap_prot);
-
-static int get_format_bpp(int format, int* bpp);
-static int is_non_planar_and_independent_pixel_format(int format);
-static int get_format_width_and_height_alignment(int format, int usage,
-    int* width_alignment, int* height_alignment);
-
-static int set_up_hwmem_region(int left, int top, int width, int height, int buf_width,
-    int buf_height, int buf_format, struct hwmem_region_us* hwmem_region);
-
-static int align_up(int value, int alignment, int* result);
-
-static int calc_buf_size(int width, int height, int format, int usage,
-    int *actual_width, int *actual_height);
-
-/*
- * Quicker method that just calculates the size as
- * "width * height * get_format_bpp(format) / 8" without any checks.
- */
-static int get_buf_size(int width, int height, int format);
-
-static int get_hwmem_file_info(dev_t* device, ino_t* serial_number);
-static int is_hwmem_fd(int fd, int* is_hwmem_fd_var);
-
-static enum hwmem_alloc_flags usage_2_hwmem_alloc_flags(int usage);
-static enum hwmem_mem_type usage_2_hwmem_mem_type(int usage);
-
-static int hwmem_access_2_mmap_prot(enum hwmem_access hwmem_access);
-static int limit_mmap_prot_to_usage(int mmap_prot, int usage);
-
-static int inc_buf_cnt(struct hwmem_gralloc_buf_handle_t* buf,
-    enum buf_counters buf_counter);
-static void dec_buf_cnt(struct hwmem_gralloc_buf_handle_t* buf,
-    enum buf_counters buf_counter, int lock);
-static int dec_buf_reg_cnt_if_last_usr(struct hwmem_gralloc_buf_handle_t* buf);
-
-/* buf_tg_infos_mutex muste be held when calling these functions */
-static int get_create_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf,
-    struct buf_tg_info **buf_tg_info);
-static struct buf_tg_info *get_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf);
-static void remove_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf);
-static int ensure_buf_handl_2_tg_info_map_exists(void);
-
-static int ptr_2_int(void *ptr);
-static bool are_ptrs_equal(void *ptr1, void *ptr2);
-
-
-/* Gralloc module API functions */
-
-static int gralloc_open_device(const struct hw_module_t* module, const char* name,
-    hw_device_t** device)
-{
-    const struct hwmem_gralloc_module_t* gralloc;
-
-    LOG_API_CALL("%s(%p, %s, %p)", __func__, module, name, device);
-
-    if (NULL == name || NULL == device)
-    {
-        LOG_USER_ERROR("%s: NULL == name || NULL == device", __func__);
-        return -EINVAL;
-    }
-
-    /* module_2_hwmem_gralloc_module does not write to module so the const to non
-    const cast is ok */
-    if (!module_2_hwmem_gralloc_module((struct gralloc_module_t const*)module,
-        (struct hwmem_gralloc_module_t**)&gralloc))
-        return -errno;
-
-    if (0 == strcmp(name, GRALLOC_HARDWARE_GPU0))
-    {
-        if (!open_alloc_device(gralloc, (struct alloc_device_t**)device))
-            return -errno;
-    }
-    else if (0 == strcmp(name, GRALLOC_HARDWARE_FB0))
-        return fb_device_open(module, name, device);
-    else
-    {
-        LOG_USER_ERROR("%s: Unknown device, %s", __func__, name);
-        return -EINVAL;
-    }
-
-    return 0;
-}
-
-static int gralloc_register_buffer(gralloc_module_t const* module, buffer_handle_t handle)
-{
-    struct hwmem_gralloc_module_t* gralloc;
-    struct hwmem_gralloc_buf_handle_t* buf;
-    struct buf_tg_info *buf_tg_info;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
-        !handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
-        return gralloc_register_buffer_pmem(module, buf);
-
-    if (!inc_buf_cnt(buf, REGISTER_COUNTER))
-        return -errno;
-
-    return 0;
-}
-
-static int gralloc_unregister_buffer(gralloc_module_t const* module, buffer_handle_t handle)
-{
-    struct hwmem_gralloc_module_t* gralloc;
-    struct hwmem_gralloc_buf_handle_t* buf;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
-        !handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -EINVAL;
-
-    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
-        return gralloc_unregister_buffer_pmem(module, buf);
-
-    dec_buf_cnt(buf, REGISTER_COUNTER, 1);
-
-    return 0;
-}
-
-static int gralloc_lock(gralloc_module_t const* module, buffer_handle_t handle, int usage,
-    int left, int top, int width, int height, void** addr)
-{
-    struct hwmem_gralloc_module_t* gralloc;
-    struct hwmem_gralloc_buf_handle_t* buf;
-
-    int ret = 0;
-
-    LOG_API_CALL("%s(%p, %p, %#x, %i, %i, %i, %i, %p)", __func__,
-        module, (void *)handle, (unsigned int)usage, left, top, width, height,
-        addr);
-
-    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
-        !handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
-        return gralloc_lock_pmem(module, buf, usage, left, top, width, height, addr);
-
-    /* TODO: Uncomment when applications learn to allocate buffers with correct usage */
-    /*if (!does_lock_usage_match_alloc_usage(usage, buf->usage))
-    {
-        LOG_USER_ERROR("!does_lock_usage_match_alloc_usage");
-        return -EINVAL;
-    }*/
-
-    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK))
-    {
-        int mmap_prot = 0;
-
-        if (NULL == addr)
-        {
-            LOG_USER_ERROR("%s: Software usage specified but addr == NULL", __func__);
-            return -EINVAL;
-        }
-
-        if (!mmap_buf_if_necessary(buf, addr, &mmap_prot))
-            return -errno;
-
-        if (!does_usage_match_mmap_prot(usage, mmap_prot))
-        {
-            LOG_USER_ERROR("%s: !does_usage_match_mmap_prot(usage, mmap_prot)", __func__);
-            return -EACCES;
-        }
-    }
-
-    if (!set_buffer_domain(buf, usage, left, top, width, height))
-        return -errno;
-
-    if (!inc_buf_cnt(buf, LOCK_COUNTER))
-        return -errno;
-
-    return 0;
-}
-
-static int gralloc_unlock(gralloc_module_t const* module, buffer_handle_t handle)
-{
-    struct hwmem_gralloc_module_t* gralloc;
-    struct hwmem_gralloc_buf_handle_t* buf;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
-        !handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
-        return gralloc_unlock_pmem(module, buf);
-
-    dec_buf_cnt(buf, LOCK_COUNTER, 1);
-
-    return 0;
-}
-
-static int gralloc_perform(struct gralloc_module_t const* module, int operation, ...)
-{
-    va_list args;
-    va_start(args, operation);
-
-    LOG_API_CALL("%s(%p, %i, ...)", __func__, module, operation);
-
-    switch (operation)
-    {
-        case GRALLOC_MODULE_PERFORM_GET_BUF_ALLOCATOR_HANDLE:
-        {
-            buffer_handle_t handle = va_arg(args, buffer_handle_t);
-            va_end(args);
-
-            return gralloc_get_buf_allocator_handle(module, handle);
-        }
-
-        case GRALLOC_MODULE_PERFORM_PIN_BUF:
-        {
-            buffer_handle_t handle = va_arg(args, buffer_handle_t);
-            va_end(args);
-
-            return gralloc_pin_buf(module, handle);
-        }
-
-        case GRALLOC_MODULE_PERFORM_UNPIN_BUF:
-        {
-            buffer_handle_t handle = va_arg(args, buffer_handle_t);
-            va_end(args);
-
-            return gralloc_unpin_buf(module, handle);
-        }
-
-        case GRALLOC_MODULE_PERFORM_GET_BUF_OFFSET:
-        {
-            buffer_handle_t handle = va_arg(args, buffer_handle_t);
-            va_end(args);
-
-            return gralloc_get_buf_offset(module, handle);
-        }
-
-        case GRALLOC_MODULE_PERFORM_GET_BUF_TYPE:
-        {
-            buffer_handle_t handle = va_arg(args, buffer_handle_t);
-            va_end(args);
-
-            return gralloc_get_buf_type(module, handle);
-        }
-
-        case GRALLOC_MODULE_PERFORM_GET_BUF_SIZE:
-        {
-            buffer_handle_t handle = va_arg(args, buffer_handle_t);
-            va_end(args);
-
-            return gralloc_get_buf_size(module, handle);
-        }
-
-        case GRALLOC_MODULE_PERFORM_GET_BUF_WIDTH:
-        {
-            buffer_handle_t handle = va_arg(args, buffer_handle_t);
-            va_end(args);
-
-            return gralloc_get_buf_width(module, handle);
-        }
-        case GRALLOC_MODULE_PERFORM_GET_BUF_HEIGHT:
-        {
-            buffer_handle_t handle = va_arg(args, buffer_handle_t);
-            va_end(args);
-
-            return gralloc_get_buf_height(module, handle);
-        }
-        case GRALLOC_MODULE_PERFORM_GET_BUF_FORMAT:
-        {
-            buffer_handle_t handle = va_arg(args, buffer_handle_t);
-            va_end(args);
-
-            return gralloc_get_buf_format(module, handle);
-        }
-        case GRALLOC_MODULE_PERFORM_GET_BUF_USAGE:
-        {
-            buffer_handle_t handle = va_arg(args, buffer_handle_t);
-            va_end(args);
-
-            return gralloc_get_buf_usage(module, handle);
-        }
-        case GRALLOC_MODULE_PERFORM_COMPOSITION_COMPLETE:
-        {
-            return fb_compositionComplete();
-        }
-
-
-        default:
-            va_end(args);
-
-            LOG_USER_ERROR("%s: Unknown operation, %i", __func__, operation);
-            return -EINVAL;
-    }
-}
-
-static int gralloc_create_handle_from_buffer(int fd, size_t size, size_t offset, void* base,
-    native_handle_t** handle)
-{
-    int is_hwmem_fd_var;
-    struct hwmem_get_info_request hwmem_get_info_request;
-    struct hwmem_gralloc_buf_handle_t* hwmem_gralloc_buf_handle;
-
-    LOG_API_CALL("%s(%i, %u, %u, %p, %p)", __func__, fd, size, ofset, base, handle);
-
-    if (offset > (unsigned int)INT_MAX || size > (unsigned int)INT_MAX || size == 0 || NULL == handle)
-    {
-        LOG_USER_ERROR("%s: offset > (unsigned int)INT_MAX || size > (unsigned int)INT_MAX || size == 0 || NULL == handle", __func__);
-        return -EINVAL;
-    }
-
-    if (!is_hwmem_fd(fd, &is_hwmem_fd_var))
-        return -errno;
-    if (!is_hwmem_fd_var)
-    {
-        LOG_USER_ERROR("%s: !is_hwmem_fd_var", __func__);
-        return -EINVAL;
-    }
-
-    hwmem_get_info_request.id = 0;
-    if (ioctl(fd, HWMEM_GET_INFO_IOC, &hwmem_get_info_request) < 0)
-    {
-        LOG_USER_ERROR("%s: HWMEM_GET_INFO_IOC failed, %s", __func__, strerror(errno));
-        return -errno;
-    }
-
-    if (offset + size > hwmem_get_info_request.size)
-    {
-        LOG_USER_ERROR("%s: offset + buf_size > hwmem_get_info_request.size", __func__);
-        return -EINVAL;
-    }
-
-    hwmem_gralloc_buf_handle =
-        (struct hwmem_gralloc_buf_handle_t*)native_handle_create(
-        num_fds_in_hwmem_gralloc_buf_handle, num_ints_in_hwmem_gralloc_buf_handle);
-    if (NULL == hwmem_gralloc_buf_handle)
-    {
-        LOG_ERROR("%s: Out of memory!", __func__);
-        return -ENOMEM;
-    }
-
-    hwmem_gralloc_buf_handle->fd = fd;
-    hwmem_gralloc_buf_handle->type_identifier = hwmem_gralloc_buf_handle_type_identifier;
-    hwmem_gralloc_buf_handle->width = -1;
-    hwmem_gralloc_buf_handle->height = -1;
-    hwmem_gralloc_buf_handle->format = -1;
-    hwmem_gralloc_buf_handle->usage = GRALLOC_USAGE_SW_READ_MASK |
-        GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_RENDER |
-        GRALLOC_USAGE_HW_2D;
-    hwmem_gralloc_buf_handle->addr = (int)((char *)base + offset);
-    hwmem_gralloc_buf_handle->offset = (int)offset;
-    hwmem_gralloc_buf_handle->size = (int)size;
-    hwmem_gralloc_buf_handle->type = GRALLOC_BUF_TYPE_HWMEM_CONTIGUOUS;
-
-    *handle = (native_handle_t*)hwmem_gralloc_buf_handle;
-
-    return 0;
-}
-
-static int gralloc_get_buf_allocator_handle(struct gralloc_module_t const* module,
-    buffer_handle_t handle)
-{
-    struct hwmem_gralloc_module_t* gralloc;
-    struct hwmem_gralloc_buf_handle_t* buf;
-
-    int buf_hwmem_name;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
-        !handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
-        return gralloc_get_buf_allocator_handle_pmem(module, buf);
-
-    buf_hwmem_name = ioctl(buf->fd, HWMEM_EXPORT_IOC, 0);
-    if (buf_hwmem_name < 0)
-    {
-        LOG_ERROR("%s: HWMEM_EXPORT_IOC failed, %s", __func__, strerror(errno));
-    }
-
-    return buf_hwmem_name;
-}
-
-static int gralloc_pin_buf(struct gralloc_module_t const *module,
-        buffer_handle_t handle)
-{
-    struct hwmem_gralloc_module_t *gralloc;
-    struct hwmem_gralloc_buf_handle_t *buf;
-
-    struct hwmem_pin_request pin;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
-            !handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
-        return gralloc_pin_buf_pmem(module, buf);
-
-    pin.id = 0;
-    if (ioctl(buf->fd, HWMEM_PIN_IOC, &pin) < 0) {
-        ALOGE("%s: Could not pin hwmem buffer!", __func__);
-        return -errno;
-    }
-
-    return (int)pin.phys_addr + buf->offset;
-}
-
-static int gralloc_unpin_buf(struct gralloc_module_t const* module,
-        buffer_handle_t handle)
-{
-    struct hwmem_gralloc_module_t *gralloc;
-    struct hwmem_gralloc_buf_handle_t *buf;
-
-    struct hwmem_pin_request pin;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
-            !handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
-        return gralloc_unpin_buf_pmem(module, buf);
-
-    if (ioctl(buf->fd, HWMEM_UNPIN_IOC, 0) < 0) {
-        ALOGE("%s: Could not unpin hwmem buffer!", __func__);
-        return -errno;
-    }
-
-    return 0;
-}
-
-static int gralloc_get_buf_offset(struct gralloc_module_t const* module,
-    buffer_handle_t handle)
-{
-    struct hwmem_gralloc_module_t* gralloc;
-    struct hwmem_gralloc_buf_handle_t* buf;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
-        !handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -EINVAL;
-
-    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
-        return gralloc_get_buf_offset_pmem(module, buf);
-
-    return buf->offset;
-}
-
-static int gralloc_get_buf_type(struct gralloc_module_t const* module,
-    buffer_handle_t handle)
-{
-    struct hwmem_gralloc_buf_handle_t* buf;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    return buf->type;
-}
-
-static int gralloc_get_buf_size(struct gralloc_module_t const* module,
-    buffer_handle_t handle)
-{
-    struct hwmem_gralloc_buf_handle_t* buf;
-    int buf_size;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    /* If this is a wrapped handle, just return the stored size */
-    if (buf->size != -1)
-        return buf->size;
-
-    buf_size = get_buf_size(buf->width, buf->height, buf->format);
-    if (buf_size < 0)
-        return -errno;
-
-    return buf_size;
-}
-
-static int gralloc_get_buf_width(struct gralloc_module_t const* module,
-    buffer_handle_t handle)
-{
-    struct hwmem_gralloc_buf_handle_t* buf;
-    int buf_size;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    return buf->width;
-}
-
-static int gralloc_get_buf_height(struct gralloc_module_t const* module,
-    buffer_handle_t handle)
-{
-    struct hwmem_gralloc_buf_handle_t* buf;
-    int buf_size;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    return buf->height;
-}
-
-static int gralloc_get_buf_format(struct gralloc_module_t const* module,
-    buffer_handle_t handle)
-{
-    struct hwmem_gralloc_buf_handle_t* buf;
-    int buf_size;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    return buf->format;
-}
-
-static int gralloc_get_buf_usage(struct gralloc_module_t const* module,
-    buffer_handle_t handle)
-{
-    struct hwmem_gralloc_buf_handle_t* buf;
-    int buf_size;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
-
-    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    return buf->usage;
-}
-
-
-/* Gralloc module alloc device API functions */
-
-static int gralloc_alloc(struct alloc_device_t* device, int width, int height, int format,
-    int usage, buffer_handle_t* handle, int* stride)
-{
-    int ret = 0;
-    int last_result;
-    int hwmem_fd = -1;
-    int actual_width;
-    int actual_height;
-    int buf_size;
-    struct hwmem_alloc_request hwmem_alloc_request;
-    struct hwmem_gralloc_buf_handle_t* buf_handle = NULL;
-
-    LOG_API_CALL("%s(%p, %i, %i, %#x, %#x, %p, %p)", __func__, device,
-        width, height, (unsigned int)format, (unsigned int)usage,
-        handle, stride);
-
-    if (NULL == device || NULL == handle)
-    {
-        LOG_USER_ERROR("%s: NULL == device || NULL == handle", __func__);
-        return -EINVAL;
-    }
-
-    if (!(usage & GRALLOC_USAGE_HW_MASK))
-    {
-        LOG_WARNING_ALWAYS("%s: Gralloc is used to alloc software only buffers!", __func__);
-    }
-
-    buf_size = calc_buf_size(width, height, format, usage, &actual_width, &actual_height);
-    if (buf_size < 0)
-        return -errno;
-
-    if (usage & GRALLOC_USAGE_HW_FB)
-    {
-        int handled;
-
-        last_result = gralloc_alloc_framebuffer(device, buf_size, usage, handle, stride, &handled);
-        if (last_result < 0)
-        {
-            LOG_ERROR("%s: gralloc_alloc_framebuffer (google) failed, %s", __func__, strerror(-last_result));
-            return last_result;
-        }
-
-        if (handled)
-            return 0;
-        else
-            usage &= ~GRALLOC_USAGE_HW_FB;
-    }
-
-    if (!is_non_planar_and_independent_pixel_format(format))
-        usage |= GRALLOC_USAGE_HW_2D;
-
-    hwmem_fd = open(hwmem_files_full_name, O_RDWR);
-    if (hwmem_fd < 0)
-    {
-        LOG_ERROR("%s: open failed, %s", __func__, strerror(errno));
-        return -errno;
-    }
-
-    hwmem_alloc_request.size = (unsigned int)buf_size;
-    hwmem_alloc_request.flags = usage_2_hwmem_alloc_flags(usage);
-    hwmem_alloc_request.default_access =
-        /* TODO: Uncomment when applications learn to allocate buffers with correct usage */
-        /* usage_2_hwmem_access(usage); */
-        HWMEM_ACCESS_READ | HWMEM_ACCESS_WRITE;
-    hwmem_alloc_request.mem_type = usage_2_hwmem_mem_type(usage);
-    if (ioctl(hwmem_fd, HWMEM_ALLOC_FD_IOC, &hwmem_alloc_request) < 0)
-    {
-        LOG_ERROR("%s: HWMEM_ALLOC_IOC failed, %s", __func__, strerror(errno));
-        ret = -errno;
-        goto alloc_failed;
-    }
-
-    buf_handle =
-        (struct hwmem_gralloc_buf_handle_t*)native_handle_create(
-        num_fds_in_hwmem_gralloc_buf_handle, num_ints_in_hwmem_gralloc_buf_handle);
-    if (NULL == buf_handle)
-    {
-        LOG_ERROR("%s: Out of memory!", __func__);
-        ret = -ENOMEM;
-        goto native_handle_create_failed;
-    }
-
-    buf_handle->fd = hwmem_fd;
-    buf_handle->type_identifier = hwmem_gralloc_buf_handle_type_identifier;
-    buf_handle->width = actual_width;
-    buf_handle->height = actual_height;
-    buf_handle->format = format;
-    buf_handle->usage = usage;
-    buf_handle->offset = 0;
-    buf_handle->size = -1;
-    if (hwmem_alloc_request.mem_type == HWMEM_MEM_SCATTERED_SYS)
-    {
-        buf_handle->type = GRALLOC_BUF_TYPE_HWMEM_SCATTERED;
-    }
-    else
-    {
-        buf_handle->type = GRALLOC_BUF_TYPE_HWMEM_CONTIGUOUS;
-    }
-
-    if (!inc_buf_cnt(buf_handle, REGISTER_COUNTER))
-    {
-        ret = -errno;
-        goto inc_buf_cnt_failed;
-    }
-
-    *handle = (buffer_handle_t)buf_handle;
-
-    if (stride != NULL)
-    {
-        *stride = actual_width;
-    }
-
-    goto out;
-
-inc_buf_cnt_failed:
-    last_result = native_handle_delete((native_handle_t *)buf_handle);
-    if (last_result < 0)
-    {
-        LOG_ERROR("%s: native_handle_delete, %s. Resource leak!", __func__, strerror(-last_result));
-    }
-native_handle_create_failed:
-alloc_failed:
-    if (close(hwmem_fd) < 0)
-    {
-        LOG_ERROR("%s: close failed, %s. Resource leak!", __func__, strerror(errno));
-    }
-
-out:
-    return ret;
-}
-
-static int gralloc_free(struct alloc_device_t* device, buffer_handle_t handle)
-{
-    int last_ret;
-    struct hwmem_gralloc_buf_handle_t* buf;
-    struct buf_tg_info *buf_tg_info;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, device, (void *)handle);
-
-    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
-        return -errno;
-
-    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
-        return gralloc_free_pmem(device, buf);
-
-    if (!dec_buf_reg_cnt_if_last_usr(buf))
-        return -errno;
-
-    last_ret = native_handle_close((const native_handle_t*)buf);
-    if (last_ret < 0)
-    {
-        LOG_ERROR("%s: native_handle_close failed, %s. Resource leak!", __func__, strerror(-last_ret));
-    }
-
-    last_ret = native_handle_delete((native_handle_t*)buf);
-    if (last_ret < 0)
-    {
-        LOG_ERROR("%s: native_handle_delete failed, %s. Resource leak!", __func__, strerror(-last_ret));
-    }
-
-    return 0;
-}
-
-static int open_alloc_device(const struct hwmem_gralloc_module_t* module,
-    struct alloc_device_t** alloc_device)
-{
-    const struct hwmem_gralloc_module_t* gralloc;
-
-    LOG_API_CALL("%s(%p, %p)", __func__, module, alloc_device);
-
-    /* module_2_hwmem_gralloc_module does not write to module so the const to non
-    const cast is ok */
-    if (!module_2_hwmem_gralloc_module((struct gralloc_module_t const*)module,
-        (struct hwmem_gralloc_module_t**)&gralloc))
-        return 0;
-
-    if (NULL == alloc_device)
-    {
-        LOG_USER_ERROR("%s: NULL == alloc_device", __func__);
-        errno = EINVAL;
-        return 0;
-    }
-
-    *alloc_device = (alloc_device_t*)malloc(sizeof(alloc_device_t));
-    if (NULL == *alloc_device)
-    {
-        LOG_ERROR("%s: Out of memory!", __func__);
-        errno = ENOMEM;
-        return 0;
-    }
-
-    memset(*alloc_device, 0, sizeof(**alloc_device));
-
-    (*alloc_device)->common.tag = HARDWARE_DEVICE_TAG;
-    (*alloc_device)->common.version = 1;
-    /* Dangerous cast but it can't be avoided given the current gralloc API. */
-    (*alloc_device)->common.module = (hw_module_t*)gralloc;
-    (*alloc_device)->common.close = gralloc_close_alloc_device;
-
-    (*alloc_device)->alloc = gralloc_alloc;
-    (*alloc_device)->free = gralloc_free;
-
-    return 1;
-}
-
-static int gralloc_close_alloc_device(struct hw_device_t* device)
-{
-    LOG_API_CALL("%s(%p)", __func__, device);
-
-    if (NULL == device)
-    {
-        LOG_USER_ERROR("%s: NULL == device", __func__);
-        return -EINVAL;
-    }
-
-    /* It would be nice to free all the device's buffers here in case the application
-    forgot. The problem with that approach is the native_handle_close/delete functions.
-    It's not unlikely that an application erronously closes a handle with
-    native_handle_close/delete instead of free and in that case the cleanup code here
-    will try to free an invalid handle which will probably crash the application. Not
-    cleaning up here on the other hand might lead to temporary resource leaks (till the
-    application dies) so the choice is between possibly crashing a faulty application or
-    letting it temporarily leak some resources, I choose the second alternative. If
-    problems arise we'll have to re-evaluate this choice. */
-
-    free(device);
-
-    return 0;
-}
-
-
-/* Hwmem API wrappers */
-
-static int set_buffer_domain(struct hwmem_gralloc_buf_handle_t* buf,
-    int usage, int left, int top, int width, int height)
-{
-    struct hwmem_set_domain_request request;
-
-    request.id = 0;
-    request.access = usage_2_hwmem_access(usage);
-
-    if (buf->size != -1)
-    {
-        /* We don't have enough information for a partial domain switch in the wrapping
-        handle case so we switch domain for the entire buffer. */
-
-        request.region.offset = buf->offset;
-        request.region.count = 1;
-        request.region.start = 0;
-        request.region.end = buf->size;
-        request.region.size = buf->size;
-    }
-    else
-    {
-        if (!set_up_hwmem_region(left, top, width, height, buf->width, buf->height,
-            buf->format, &request.region))
-            return 0;
-    }
-
-    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
-        if (ioctl(buf->fd, HWMEM_SET_CPU_DOMAIN_IOC, &request) < 0)
-        {
-            LOG_ERROR("%s: HWMEM_SET_DOMAIN_IOC failed, %s", __func__, strerror(errno));
-            return 0;
-        }
-    } else {
-        if (ioctl(buf->fd, HWMEM_SET_SYNC_DOMAIN_IOC, &request) < 0)
-        {
-            LOG_ERROR("%s: HWMEM_SET_DOMAIN_IOC failed, %s", __func__, strerror(errno));
-            return 0;
-        }
-    }
-
-    return 1;
-}
-
-
-/* Mmap */
-
-static int mmap_buf_if_necessary(struct hwmem_gralloc_buf_handle_t *buf, void **addr,
-    int *mmap_prot)
-{
-    int ret = 1;
-    struct buf_tg_info *buf_tg_info;
-    struct hwmem_get_info_request buf_info;
-
-    /* Wrapper handles are not memory mapped by gralloc */
-    if (buf->size != -1)
-    {
-        if ((int)NULL == buf->addr)
-        {
-            LOG_USER_ERROR("%s, Wrapper handle is not memory mapped", __func__);
-            errno = -ENOMSG;
-            return 0;
-        }
-
-        *addr = (void *)buf->addr;
-        *mmap_prot = PROT_READ | PROT_WRITE;
-
-        return 1;
-    }
-
-    mutex_lock(&buf_tg_infos_mutex);
-
-    buf_tg_info = get_buf_tg_info(buf);
-    if (NULL == buf_tg_info)
-    {
-        LOG_USER_ERROR("%s: Memory mapping unregistered buffer", __func__);
-        errno = ENOMSG;
-        goto no_buf_tg_info;
-    }
-
-    /* Check if we are already mapped */
-    if (buf_tg_info->addr != NULL)
-    {
-        *addr = buf_tg_info->addr;
-        *mmap_prot = buf_tg_info->mmap_prot;
-
-        goto out;
-    }
-
-    buf_info.id = 0;
-    if (ioctl(buf->fd, HWMEM_GET_INFO_IOC, &buf_info) < 0)
-    {
-        LOG_ERROR("%s: HWMEM_GET_INFO_IOC failed, %s", __func__, strerror(errno));
-        goto hwmem_get_info_failed;
-    }
-
-    buf_tg_info->mmap_prot = hwmem_access_2_mmap_prot(buf_info.access);
-    /* TODO: Uncomment when applications learns to allocate buffers with correct usage */
-    /*buf_tg_info->mmap_prot = limit_mmap_prot_to_usage(buf_tg_info->mmap_prot,
-        buf->usage);*/
-
-    buf_tg_info->addr = mmap(NULL, buf_info.size, buf_tg_info->mmap_prot, MAP_SHARED,
-        buf->fd, 0);
-    if (MAP_FAILED == buf_tg_info->addr)
-    {
-        LOG_ERROR("%s: mmap failed, %s", __func__, strerror(errno));
-        goto mmap_failed;
-    }
-
-    *addr = buf_tg_info->addr;
-    *mmap_prot = buf_tg_info->mmap_prot;
-
-    goto out;
-
-mmap_failed:
-    buf_tg_info->addr = NULL;
-hwmem_get_info_failed:
-no_buf_tg_info:
-    ret = 0;
-
-out:
-    mutex_unlock(&buf_tg_infos_mutex);
-
-    return ret;
-}
-
-/* buf_tg_infos_mutex must be held when calling this function */
-static void munmap_buf_if_necessary(struct hwmem_gralloc_buf_handle_t* buf)
-{
-    struct buf_tg_info *buf_tg_info;
-    struct hwmem_get_info_request buf_info;
-
-    buf_tg_info = get_buf_tg_info(buf);
-    if (NULL == buf_tg_info)
-    {
-        LOG_USER_ERROR("%s: Unmapping unregistered buffer", __func__);
-        return;
-    }
-
-    if (NULL == buf_tg_info->addr)
-        return;
-
-    buf_info.id = 0;
-    if (ioctl(buf->fd, HWMEM_GET_INFO_IOC, &buf_info) < 0)
-    {
-        LOG_ERROR("%s: HWMEM_GET_INFO_IOC failed, %s. Resource leak!", __func__, strerror(errno));
-        return;
-    }
-
-    if (munmap(buf_tg_info->addr, buf_info.size) < 0)
-    {
-        LOG_ERROR("%s: munmap failed, %s. Resource leak!", __func__, strerror(errno));
-        return;
-    }
-
-    buf_tg_info->addr = NULL;
-}
-
-
-/* Helpers */
-
-int module_2_hwmem_gralloc_module(struct gralloc_module_t const* module,
-    struct hwmem_gralloc_module_t** gralloc_out)
-{
-    struct hwmem_gralloc_module_t* gralloc =
-            (struct hwmem_gralloc_module_t *)module;
-
-    if (NULL == gralloc || gralloc->base.common.tag != HARDWARE_MODULE_TAG ||
-        gralloc->type_identifier != (int)HWMEM_GRALLOC_MODULE_TYPE_IDENTIFIER)
-    {
-        LOG_USER_ERROR("%s, Invalid module", __func__);
-        errno = EINVAL;
-        return 0;
-    }
-
-    *gralloc_out = gralloc;
-
-    return 1;
-
-}
-
-int handle_2_hwmem_gralloc_handle(buffer_handle_t handle,
-        struct hwmem_gralloc_buf_handle_t **buf_out)
-{
-    struct hwmem_gralloc_buf_handle_t *buf =
-            (struct hwmem_gralloc_buf_handle_t*)handle;
-
-    if (NULL == buf || buf->base.version != sizeof(native_handle_t) ||
-        buf->base.numFds != num_fds_in_hwmem_gralloc_buf_handle ||
-        buf->base.numInts != num_ints_in_hwmem_gralloc_buf_handle ||
-        buf->type_identifier != hwmem_gralloc_buf_handle_type_identifier)
-    {
-        LOG_USER_ERROR("%s: Invalid handle", __func__);
-        errno = EINVAL;
-        return 0;
-    }
-
-    *buf_out = buf;
-
-    return 1;
-}
-
-static enum hwmem_access usage_2_hwmem_access(int usage)
-{
-    enum hwmem_access hwmem_access = (enum hwmem_access)0;
-
-    if (usage & GRALLOC_USAGE_SW_READ_MASK)
-        hwmem_access |= HWMEM_ACCESS_READ;
-    if (usage & GRALLOC_USAGE_SW_WRITE_MASK || usage & GRALLOC_USAGE_HW_RENDER)
-        hwmem_access |= HWMEM_ACCESS_WRITE;
-    if (usage & (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_2D | GRALLOC_USAGE_HW_FB))
-        hwmem_access |= HWMEM_ACCESS_READ | HWMEM_ACCESS_WRITE;
-
-    return hwmem_access;
-}
-
-static int does_lock_usage_match_alloc_usage(int lock_usage, int alloc_usage)
-{
-    int lock_sw_read = lock_usage & GRALLOC_USAGE_SW_READ_MASK;
-    int lock_sw_write = lock_usage & GRALLOC_USAGE_SW_WRITE_MASK;
-    int alloc_sw_read = alloc_usage & GRALLOC_USAGE_SW_READ_MASK;
-    int alloc_sw_write = alloc_usage & GRALLOC_USAGE_SW_WRITE_MASK;
-
-    if ((lock_sw_read && !alloc_sw_read) ||
-        (lock_sw_write && !alloc_sw_write) ||
-        ((lock_usage & GRALLOC_USAGE_HW_MASK) & (alloc_usage & GRALLOC_USAGE_HW_MASK)) != (lock_usage & GRALLOC_USAGE_HW_MASK))
-        return 0;
-    else
-        return 1;
-}
-
-static int does_usage_match_mmap_prot(int usage, int mmap_prot)
-{
-    int usage_sw_read = usage & GRALLOC_USAGE_SW_READ_MASK;
-    int usage_sw_write = usage & GRALLOC_USAGE_SW_WRITE_MASK;
-    int mmap_prot_read = mmap_prot & PROT_READ;
-    int mmap_prot_write = mmap_prot & PROT_WRITE;
-
-    if ((usage_sw_read && !mmap_prot_read) ||
-        (usage_sw_write && !mmap_prot_write))
-        return 0;
-    else
-        return 1;
-}
-
-static int get_format_bpp(int format, int* bpp)
-{
-    switch (format)
-    {
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-        case HAL_PIXEL_FORMAT_RGBX_8888:
-        case HAL_PIXEL_FORMAT_BGRA_8888:
-            *bpp = 32;
-            break;
-
-        case HAL_PIXEL_FORMAT_RGB_888:
-            *bpp = 24;
-            break;
-
-        case HAL_PIXEL_FORMAT_RGB_565:
-        case HAL_PIXEL_FORMAT_RGBA_5551:
-        case HAL_PIXEL_FORMAT_RGBA_4444:
-        case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-        case HAL_PIXEL_FORMAT_YCbCr_422_P:
-        case HAL_PIXEL_FORMAT_YCbCr_422_I:
-        case HAL_PIXEL_FORMAT_CbYCrY_422_I:
-        case HAL_PIXEL_FORMAT_YCrCb_422_SP:
-        case HAL_PIXEL_FORMAT_YCrCb_422_P:
-            *bpp = 16;
-            break;
-
-        case HAL_PIXEL_FORMAT_YCBCR42XMBN: /* Interpreted as HAL_PIXEL_FORMAT_YCBCR420MBN */
-        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
-        case HAL_PIXEL_FORMAT_YCbCr_420_P:
-        case HAL_PIXEL_FORMAT_YCbCr_420_I:
-        case HAL_PIXEL_FORMAT_CbYCrY_420_I:
-        case HAL_PIXEL_FORMAT_YCrCb_420_SP:
-        case HAL_PIXEL_FORMAT_YCrCb_420_P:
-        case HAL_PIXEL_FORMAT_YV12:
-            *bpp = 12;
-            break;
-
-        default:
-            LOG_USER_ERROR("%s: Unknown format, %i", __func__, format);
-            errno = EINVAL;
-            return 0;
-    }
-
-    return 1;
-}
-
-static int is_non_planar_and_independent_pixel_format(int format)
-{
-    switch (format)
-    {
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-        case HAL_PIXEL_FORMAT_RGBX_8888:
-        case HAL_PIXEL_FORMAT_BGRA_8888:
-        case HAL_PIXEL_FORMAT_RGB_888:
-        case HAL_PIXEL_FORMAT_RGB_565:
-        case HAL_PIXEL_FORMAT_RGBA_5551:
-        case HAL_PIXEL_FORMAT_RGBA_4444:
-            return 1;
-    }
-
-    return 0;
-}
-
-static int get_format_width_and_height_alignment(int format, int usage,
-    int* width_alignment, int* height_alignment)
-{
-    switch (format) {
-        case HAL_PIXEL_FORMAT_RGBX_8888:
-	    if (usage & (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_COMPOSER | GRALLOC_USAGE_HW_RENDER))
-	        *width_alignment = 2;
-	    else
-	        *width_alignment = 1;
-	    *height_alignment = 1;
-            break;
-
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-        case HAL_PIXEL_FORMAT_BGRA_8888:
-	    if (usage & (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_COMPOSER | GRALLOC_USAGE_HW_RENDER))
-                *width_alignment = 2;
-            else
-                *width_alignment = 1;
-            *height_alignment = 1;
-            break;
-
-        case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-        case HAL_PIXEL_FORMAT_YCbCr_422_P:
-        case HAL_PIXEL_FORMAT_YCbCr_422_I:
-        case HAL_PIXEL_FORMAT_CbYCrY_422_I:
-        case HAL_PIXEL_FORMAT_YCrCb_422_SP:
-        case HAL_PIXEL_FORMAT_YCrCb_422_P:
-            *width_alignment = 2;
-            *height_alignment = 1;
-            break;
-
-        case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:
-        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
-        case HAL_PIXEL_FORMAT_YCbCr_420_P:
-        case HAL_PIXEL_FORMAT_YCbCr_420_I:
-        case HAL_PIXEL_FORMAT_YCrCb_420_SP_TILED:
-        case HAL_PIXEL_FORMAT_YCrCb_420_SP:
-        case HAL_PIXEL_FORMAT_YCrCb_420_P:
-        case HAL_PIXEL_FORMAT_CbYCrY_420_I:
-            *width_alignment = 2;
-            *height_alignment = 2;
-            break;
-
-        case HAL_PIXEL_FORMAT_RGB_565:
-        case HAL_PIXEL_FORMAT_RGBA_5551:
-        case HAL_PIXEL_FORMAT_RGBA_4444:
-            if (usage & (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_RENDER))
-                *width_alignment = 4;
-            else
-                *width_alignment = 1;
-            *height_alignment = 1;
-            break;
-
-        case HAL_PIXEL_FORMAT_RGB_888:
-            if (usage & (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_COMPOSER | GRALLOC_USAGE_HW_RENDER))
-                *width_alignment = 8;
-            else if (usage & GRALLOC_USAGE_HW_2D)
-                *width_alignment = 4;
-            else
-                *width_alignment = 1;
-            *height_alignment = 1;
-            break;
-
-        case HAL_PIXEL_FORMAT_YCBCR42XMBN:
-            *width_alignment = 16;
-            *height_alignment = 16;
-            break;
-
-        case HAL_PIXEL_FORMAT_YV12:
-            *width_alignment = 16;
-            *height_alignment = 2;
-            break;
-
-        default:
-            LOG_USER_ERROR("%s: Unknown format, %i", __func__, format);
-            errno = EINVAL;
-            return 0;
-    }
-
-    return 1;
-}
-
-static int set_up_hwmem_region(int left, int top, int width, int height, int buf_width,
-    int buf_height, int buf_format, struct hwmem_region_us* hwmem_region)
-{
-    int buf_format_bpp;
-    int actual_left, actual_top, actual_width, actual_height;
-    int pitch;
-
-    if (left < 0 || top < 0 || width < 0 || height < 0 || left > INT_MAX - width ||
-        left + width > buf_width || top > INT_MAX - height ||
-        top + height > buf_height)
-    {
-        LOG_USER_ERROR("%s: left < 0 || top < 0 || width < 0 || height < 0 || left > INT_MAX - width || left + width > buf_width || top > INT_MAX - height || top + height > buf_height", __func__);
-        errno = EINVAL;
-        return 0;
-    }
-
-    if (!get_format_bpp(buf_format, &buf_format_bpp))
-        return 0;
-
-    if (is_non_planar_and_independent_pixel_format(buf_format))
-    {
-        actual_left = left;
-        actual_top = top;
-        actual_width = width;
-        actual_height = height;
-    }
-    else
-    {
-        /* TODO: Locking entire buffer as a quick safe solution. In the future
-        we should lock less to avoid unecessary cache syncing. Pixel interleaved
-        YCbCr formats should be quite easy, just align start and stop points on 2. */
-        actual_left = 0;
-        actual_top = 0;
-        actual_width = buf_width;
-        actual_height = buf_height;
-    }
-
-    pitch = (buf_width * buf_format_bpp) / 8;
-
-    hwmem_region->offset = (unsigned int)(actual_top * pitch);
-    hwmem_region->count = (unsigned int)actual_height;
-    hwmem_region->start = (unsigned int)((actual_left * buf_format_bpp) / 8);
-    hwmem_region->end = (unsigned int)
-        (((actual_left + actual_width) * buf_format_bpp) / 8);
-    hwmem_region->size = (unsigned int)pitch;
-
-    return 1;
-}
-
-static int align_up(int value, int alignment, int* result)
-{
-    int remainder = value % alignment;
-    int value_to_add;
-
-    /* We never align negative values so there is no point dealing with that */
-    if (value < 0 || alignment < 0)
-    {
-        LOG_ERROR("%s: value < 0 || alignment < 0", __func__);
-        errno = EINVAL;
-        return 0;
-    }
-
-    if (remainder > 0)
-        value_to_add = alignment - remainder;
-    else
-        value_to_add = 0;
-
-    if (value > INT_MAX - value_to_add)
-    {
-        /* Will result in overflow */
-        LOG_ERROR("%s: value > INT_MAX - value_to_add", __func__);
-        errno = ERANGE;
-        return 0;
-    }
-
-    *result = value + value_to_add;
-
-    return 1;
-}
-
-static int calc_buf_size(int width, int height, int format, int usage,
-    int* actual_width, int* actual_height)
-{
-    int bpp;
-    int format_width_alignment;
-    int format_height_alignment;
-
-    if (width < 0 || height < 0)
-    {
-        LOG_USER_ERROR("%s: width < 0 || height < 0", __func__);
-        errno = EINVAL;
-        return -1;
-    }
-
-    if (!get_format_bpp(format, &bpp))
-        return -1;
-
-    if (!get_format_width_and_height_alignment(format, usage,
-        &format_width_alignment, &format_height_alignment))
-        return -1;
-
-    if (!align_up(width, format_width_alignment, actual_width) ||
-        !align_up(height, format_height_alignment, actual_height))
-        return -1;
-
-    if (*actual_width > max_width_height || *actual_height > max_width_height)
-    {
-        LOG_USER_ERROR("%s: actual_width > max_width_height || actual_height > max_width_height", __func__);
-        errno = EINVAL;
-        return -1;
-    }
-
-    if (format == HAL_PIXEL_FORMAT_YV12) {
-        int uv_stride;
-        int mean_stride;
-        /*
-         * Y stride needs to be aligned to 16 pixels, and
-         * the U/V stride needs to be half of Y stride
-         * aligned to 16. In other words:
-         *   y_size = stride * height
-         *   c_size = ALIGN(stride/2, 16) * height/2
-         *   size = y_size + c_size * 2
-         * However, b2r2 does not recognize the YV12 format
-         * being any different than the YVU420P which requires
-         * the U/V stride to be half of the Y stride, and
-         * therefore we align the pitch to 32.
-         */
-        align_up(*actual_width >> 1, 16, &uv_stride);
-        mean_stride = uv_stride + (*actual_width >> 1);
-        return (mean_stride * (*actual_height) * bpp) >> 3;
-    } else {
-        return ((*actual_width) * (*actual_height) * bpp) >> 3;
-    }
-}
-
-static int get_buf_size(int width, int height, int format)
-{
-    int bpp;
-
-    if (!get_format_bpp(format, &bpp))
-        return -1;
-
-    return (width * height * bpp) / 8;
-}
-
-static int get_hwmem_file_info(dev_t* device, ino_t* serial_number)
-{
-    static int write_values_initiated = 0;
-    static int error_occured_when_retreiving_hwmem_file_info = 0;
-    static int error_code_produced_when_retreiving_hwmem_file_info;
-    static int cached_values_present = 0;
-    static dev_t hwmem_files_device;
-    static ino_t hwmem_files_serial_number;
-
-    struct stat hwmem_file_info;
-
-    if (error_occured_when_retreiving_hwmem_file_info)
-    {
-        errno = error_code_produced_when_retreiving_hwmem_file_info;
-
-        return 0;
-    }
-    else if (cached_values_present)
-    {
-        *device = hwmem_files_device;
-        *serial_number = hwmem_files_serial_number;
-
-        return 1;
-    }
-
-    if (stat(hwmem_files_full_name, &hwmem_file_info) < 0)
-    {
-        if (0 == android_atomic_cmpxchg(0, 1, &write_values_initiated))
-        {
-            error_code_produced_when_retreiving_hwmem_file_info = errno;
-            android_atomic_write(1, &error_occured_when_retreiving_hwmem_file_info);
-        }
-
-        LOG_ERROR("%s: stat failed, %s", __func__, strerror(errno));
-        return 0;
-    }
-
-    if (0 == android_atomic_cmpxchg(0, 1, &write_values_initiated))
-    {
-        hwmem_files_device = hwmem_file_info.st_dev;
-        hwmem_files_serial_number = hwmem_file_info.st_ino;
-        android_atomic_write(1, &cached_values_present);
-    }
-
-    *device = hwmem_file_info.st_dev;
-    *serial_number = hwmem_file_info.st_ino;
-
-    return 1;
-}
-
-static int is_hwmem_fd(int fd, int* is_hwmem_fd_var)
-{
-    dev_t hwmem_file_device;
-    ino_t hwmem_file_serial_number;
-
-    struct stat file_info;
-
-    if (!get_hwmem_file_info(&hwmem_file_device, &hwmem_file_serial_number))
-        return 0;
-
-    if (fstat(fd, &file_info) < 0)
-    {
-        LOG_USER_ERROR("%s: stat failed, %s", __func__, strerror(errno));
-        return 0;
-    }
-
-    if (file_info.st_dev == hwmem_file_device &&
-        file_info.st_ino == hwmem_file_serial_number)
-        *is_hwmem_fd_var = 1;
-    else
-        *is_hwmem_fd_var = 0;
-
-    return 1;
-}
-
-static enum hwmem_alloc_flags usage_2_hwmem_alloc_flags(int usage)
-{
-    int sw_usage = usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK);
-    int hw_usage = usage & GRALLOC_USAGE_HW_MASK;
-
-    if (sw_usage == 0)
-        return HWMEM_ALLOC_HINT_UNCACHED;
-    else if (sw_usage & GRALLOC_USAGE_SW_READ_OFTEN ||
-        (sw_usage & GRALLOC_USAGE_SW_READ_RARELY && !(hw_usage &
-        (GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_2D))))
-    {
-        /* Read often, or rarely with no chance of HW write -> SW read (invalidate
-        needed) */
-        if (sw_usage & GRALLOC_USAGE_SW_WRITE_OFTEN)
-            return HWMEM_ALLOC_HINT_WRITE_COMBINE | HWMEM_ALLOC_HINT_CACHED |
-                HWMEM_ALLOC_HINT_CACHE_WB;
-        else
-            return HWMEM_ALLOC_HINT_WRITE_COMBINE | HWMEM_ALLOC_HINT_CACHED |
-                HWMEM_ALLOC_HINT_CACHE_WT;
-    }
-    else
-        /* Write often/rarely, read rarely with risk of HW write -> SW read or a
-        combination of the two */
-        return HWMEM_ALLOC_HINT_UNCACHED | HWMEM_ALLOC_HINT_WRITE_COMBINE;
-}
-
-static enum hwmem_mem_type usage_2_hwmem_mem_type(int usage)
-{
-    if (usage & GRALLOC_USAGE_PROTECTED) {
-        return HWMEM_MEM_PROTECTED_SYS;
-    }
-    else if (usage & GRALLOC_USAGE_HW_2D) {
-        return HWMEM_MEM_CONTIGUOUS_SYS;
-    }
-
-    return HWMEM_MEM_SCATTERED_SYS;
-}
-
-static int hwmem_access_2_mmap_prot(enum hwmem_access hwmem_access)
-{
-    int mmap_prot = 0;
-
-    if (hwmem_access & HWMEM_ACCESS_READ)
-        mmap_prot |= PROT_READ;
-    if (hwmem_access & HWMEM_ACCESS_WRITE)
-        mmap_prot |= PROT_WRITE;
-
-    return mmap_prot;
-}
-
-static int limit_mmap_prot_to_usage(int mmap_prot, int usage)
-{
-    int new_mmap_prot = mmap_prot & ~PROT_EXEC;
-
-    if (!(usage & GRALLOC_USAGE_SW_READ_MASK))
-        new_mmap_prot &= ~PROT_READ;
-    if (!(usage & GRALLOC_USAGE_SW_WRITE_MASK))
-        new_mmap_prot &= ~PROT_WRITE;
-
-    return new_mmap_prot;
-}
-
-static int inc_buf_cnt(struct hwmem_gralloc_buf_handle_t* buf,
-    enum buf_counters buf_counter)
-{
-    int ret = 1;
-    struct buf_tg_info *buf_tg_info;
-    int *cnt;
-
-    /* Wrapper handles don't have thread group info */
-    if (buf->size != -1)
-        return 1;
-
-    mutex_lock(&buf_tg_infos_mutex);
-
-    if (!get_create_buf_tg_info(buf, &buf_tg_info))
-        goto get_create_buf_tg_info_failed;
-
-    switch (buf_counter)
-    {
-        case REGISTER_COUNTER:
-            cnt = &buf_tg_info->reg_cnt;
-            break;
-
-        case LOCK_COUNTER:
-            cnt = &buf_tg_info->lock_cnt;
-            break;
-
-        default:
-            LOG_ERROR("%s: Unknown buffer counter, %i", __func__, buf_counter);
-            goto out;
-    }
-
-    if (*cnt == INT_MAX)
-    {
-        LOG_ERROR("%s: *cnt == INT_MAX", __func__);
-        goto overflow;
-    }
-
-    (*cnt)++;
-
-    goto out;
-
-overflow:
-get_create_buf_tg_info_failed:
-    ret = 0;
-
-out:
-    mutex_unlock(&buf_tg_infos_mutex);
-
-    return ret;
-}
-
-static void dec_buf_cnt(struct hwmem_gralloc_buf_handle_t* buf,
-    enum buf_counters buf_counter, int lock)
-{
-    struct buf_tg_info *buf_tg_info;
-    int *cnt;
-
-    /* Wrapper handles don't have thread group info */
-    if (buf->size != -1)
-        return;
-
-    if (lock)
-        mutex_lock(&buf_tg_infos_mutex);
-
-    buf_tg_info = get_buf_tg_info(buf);
-    if (NULL == buf_tg_info)
-    {
-        LOG_USER_ERROR("%s: Usage count mismatch", __func__);
-        goto out;
-    }
-
-    switch (buf_counter)
-    {
-        case REGISTER_COUNTER:
-            cnt = &buf_tg_info->reg_cnt;
-            break;
-
-        case LOCK_COUNTER:
-            cnt = &buf_tg_info->lock_cnt;
-            break;
-
-        default:
-            LOG_ERROR("%s: Unknown buffer counter, %i", __func__, buf_counter);
-            goto out;
-    }
-
-    (*cnt)--;
-    if (*cnt < 0)
-    {
-        LOG_USER_ERROR("%s: Usage count mismatch", __func__);
-        *cnt = 0;
-    }
-
-    if (0 == buf_tg_info->reg_cnt && 0 == buf_tg_info->lock_cnt)
-    {
-        remove_buf_tg_info(buf);
-    }
-
-    goto out;
-
-out:
-    if (lock)
-        mutex_unlock(&buf_tg_infos_mutex);
-}
-
-static int dec_buf_reg_cnt_if_last_usr(struct hwmem_gralloc_buf_handle_t* buf)
-{
-    int ret = 1;
-    struct buf_tg_info *buf_tg_info;
-
-    /* Wrapper handles don't have thread group info */
-    if (buf->size != -1)
-        return 1;
-
-    mutex_lock(&buf_tg_infos_mutex);
-
-    buf_tg_info = get_buf_tg_info(buf);
-    if (NULL == buf_tg_info)
-    {
-        LOG_USER_ERROR("%s: Usage count mismatch", __func__);
-        goto out;
-    }
-
-    if (buf_tg_info->reg_cnt > 1 || buf_tg_info->lock_cnt != 0)
-    {
-        LOG_USER_ERROR("%s: Buffer is in use", __func__);
-        errno = ENOMSG;
-        goto buf_in_use;
-    }
-
-    dec_buf_cnt(buf, REGISTER_COUNTER, 0);
-
-    goto out;
-
-buf_in_use:
-    ret = 0;
-
-out:
-    mutex_unlock(&buf_tg_infos_mutex);
-
-    return ret;
-}
-
-/* buf_tg_infos_mutex must be held when calling this function */
-static int get_create_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf,
-    struct buf_tg_info **buf_tg_info)
-{
-    if (buf->size != -1)
-    {
-        LOG_ERROR("%s: Creating thread group info for wrapper handle", __func__);
-        return 0;
-    }
-
-    if (!ensure_buf_handl_2_tg_info_map_exists())
-        return 0;
-
-    *buf_tg_info = (struct buf_tg_info *)hashmapGet(
-        buf_handl_2_tg_info_map, buf);
-    if (*buf_tg_info != NULL)
-        return 1;
-
-    *buf_tg_info = (struct buf_tg_info *)malloc(sizeof(struct buf_tg_info));
-    memset(*buf_tg_info, 0, sizeof(**buf_tg_info));
-    (*buf_tg_info)->addr = NULL;
-
-    errno = 0;
-    if (NULL == hashmapPut(buf_handl_2_tg_info_map, buf, *buf_tg_info) && ENOMEM == errno)
-    {
-        LOG_ERROR("%s: NULL == hashmapPut(buf_handl_2_tg_info_map, buf, *buf_tg_info) && ENOMEM == errno", __func__);
-        goto hashmap_put_failed;
-    }
-
-    return 1;
-
-hashmap_put_failed:
-    free(*buf_tg_info);
-
-    return 0;
-}
-
-/* buf_tg_infos_mutex must be held when calling this function */
-static struct buf_tg_info *get_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf)
-{
-    if (!ensure_buf_handl_2_tg_info_map_exists())
-        return NULL;
-
-    return (struct buf_tg_info *)hashmapGet(buf_handl_2_tg_info_map, buf);
-}
-
-/* buf_tg_infos_mutex must be held when calling this function */
-static void remove_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf)
-{
-    struct buf_tg_info *buf_tg_info;
-
-    if (!ensure_buf_handl_2_tg_info_map_exists())
-        return;
-
-    munmap_buf_if_necessary(buf);
-    buf_tg_info = (struct buf_tg_info *)hashmapRemove(buf_handl_2_tg_info_map,
-        buf);
-    if (NULL == buf_tg_info)
-    {
-        LOG_ERROR("%s: Removing non existing thread group info", __func__);
-    }
-    free(buf_tg_info);
-}
-
-/* buf_tg_infos_mutex must be held when calling this function */
-static int ensure_buf_handl_2_tg_info_map_exists(void)
-{
-    if (buf_handl_2_tg_info_map != NULL)
-        return 1;
-
-    buf_handl_2_tg_info_map = hashmapCreate(10, ptr_2_int, are_ptrs_equal);
-    if (NULL == buf_handl_2_tg_info_map)
-    {
-        LOG_ERROR("%s: Failed to create hashmap, %s", __func__, strerror(errno));
-        return 0;
-    }
-
-    return 1;
-}
-
-static int ptr_2_int(void *ptr)
-{
-    return (int)ptr;
-}
-
-static bool are_ptrs_equal(void *ptr1, void *ptr2)
-{
-    return ptr1 == ptr2;
-}
diff --git a/display/libgralloc/hwmem_gralloc.cpp b/display/libgralloc/hwmem_gralloc.cpp
new file mode 100644
index 0000000..6f6b0a9
--- /dev/null
+++ b/display/libgralloc/hwmem_gralloc.cpp
@@ -0,0 +1,1887 @@
+/*
+ * Copyright (C) ST-Ericsson AB 2010
+ *
+ * \file    hwmem_gralloc.c
+ * \brief   Gralloc implementation that uses hwmem
+ * \author  Johan Mossberg <johan.xx.mossberg@stericsson.com> and
+ * Fredrik Allansson <fredrik.allansson@stericsson.com> for ST-Ericsson
+ *
+ */
+
+
+/*
+ * IMPLEMENTATION SHORTCOMINGS
+ * - The implementation assumes ints are 32 bit.
+ */
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <limits.h>
+#include <linux/hwmem.h>
+#include <string.h>
+#include <stdarg.h>
+
+#include <cutils/native_handle.h>
+
+#include <cutils/atomic.h>
+#include <cutils/log.h>
+#include <cutils/threads.h>
+#include <cutils/hashmap.h>
+#include <hardware/hardware.h>
+#include <hardware/gralloc.h>
+#include <system/graphics.h>
+#include "gralloc_stericsson_ext.h"
+
+#include "hwmem_gralloc.h"
+#include "hwmem_gralloc_pmem.h"
+#include "hwmem_gralloc_framebuffer.h"
+
+
+#if defined(INT_MAX) && INT_MAX != 2147483647
+    #error "Hwmem gralloc only supports 32 bit ints"
+#endif
+
+
+/* Use these macro when it's probably a user error. */
+#define LOG_USER_ERROR_ALWAYS(...) ALOGE("[User error] " __VA_ARGS__);
+
+#ifndef LOG_USER_ERROR
+#define LOG_USER_ERROR(...) ALOGE("[User error] " __VA_ARGS__);
+#endif
+
+#ifndef LOG_ERROR
+#define LOG_ERROR(...) ALOGE(__VA_ARGS__);
+#endif
+
+#define LOG_WARNING_ALWAYS(...) ALOGW(__VA_ARGS__);
+
+#ifndef LOG_API_CALL
+/* #define LOG_API_CALL(...) ALOGI(__VA_ARGS__); */
+#define LOG_API_CALL(...)
+#endif
+
+
+enum buf_counters
+{
+    REGISTER_COUNTER,
+    LOCK_COUNTER
+};
+
+struct buf_tg_info
+{
+    void *addr;
+    int mmap_prot;
+    int reg_cnt;
+    int lock_cnt;
+};
+
+
+const int num_fds_in_hwmem_gralloc_buf_handle = 1;
+const int num_ints_in_hwmem_gralloc_buf_handle = 14;
+const int hwmem_gralloc_buf_handle_type_identifier = 0xA63B8FF0;
+
+
+static const char hwmem_files_full_name[] = "/dev/" HWMEM_DEFAULT_DEVICE_NAME;
+
+/* To ensure we don't get overflows in the width + height + format -> size calculations. Should
+be isqrt(INT_MAX / max_bpp) but isqrt does not seem to exist. The value below is the result of
+the previous calculation when INT_MAX = 2147483647 and max_bpp = 32 which is currently correct. */
+static const int max_width_height = 8191;
+
+static mutex_t buf_tg_infos_mutex = MUTEX_INITIALIZER;
+static Hashmap *buf_handl_2_tg_info_map = NULL;
+
+
+/* Gralloc module API functions */
+static int gralloc_open_device(const struct hw_module_t* module, const char* name,
+    struct hw_device_t** device);
+
+static int gralloc_register_buffer(struct gralloc_module_t const* module, buffer_handle_t handle);
+static int gralloc_unregister_buffer(struct gralloc_module_t const* module, buffer_handle_t handle);
+
+static int gralloc_lock(struct gralloc_module_t const* module, buffer_handle_t handle, int usage,
+    int left, int top, int width, int height, void** addr);
+static int gralloc_unlock(struct gralloc_module_t const* module, buffer_handle_t handle);
+
+static int gralloc_perform(struct gralloc_module_t const* module, int operation, ...);
+
+static int gralloc_create_handle_from_buffer(int fd, size_t size, size_t offset, void* base,
+    native_handle_t** handle);
+
+static int gralloc_get_buf_allocator_handle(struct gralloc_module_t const* module,
+    buffer_handle_t handle);
+
+static int gralloc_pin_buf(struct gralloc_module_t const *module,
+    buffer_handle_t handle);
+
+static int gralloc_unpin_buf(struct gralloc_module_t const *module,
+    buffer_handle_t handle);
+
+static int gralloc_get_buf_offset(struct gralloc_module_t const* module,
+    buffer_handle_t handle);
+
+static int gralloc_get_buf_type(struct gralloc_module_t const* module,
+    buffer_handle_t handle);
+
+static int gralloc_get_buf_size(struct gralloc_module_t const* module,
+    buffer_handle_t handle);
+
+static int gralloc_get_buf_width(struct gralloc_module_t const* module,
+    buffer_handle_t handle);
+
+static int gralloc_get_buf_height(struct gralloc_module_t const* module,
+    buffer_handle_t handle);
+
+static int gralloc_get_buf_format(struct gralloc_module_t const* module,
+    buffer_handle_t handle);
+
+static int gralloc_get_buf_usage(struct gralloc_module_t const* module,
+    buffer_handle_t handle);
+
+
+static struct hw_module_methods_t hwmem_gralloc_module_methods = {
+        open: gralloc_open_device
+};
+
+struct hwmem_gralloc_module_t HAL_MODULE_INFO_SYM =
+{
+    base:
+    {
+        common:
+        {
+            tag: HARDWARE_MODULE_TAG,
+            version_major: 1,
+            version_minor: 0,
+            id: GRALLOC_HARDWARE_MODULE_ID,
+            name: "Graphics Memory Allocator Module",
+            author: "ST-Ericsson",
+            methods: &hwmem_gralloc_module_methods
+        },
+        registerBuffer: gralloc_register_buffer,
+        unregisterBuffer: gralloc_unregister_buffer,
+        lock: gralloc_lock,
+        unlock: gralloc_unlock,
+        perform: gralloc_perform
+    },
+    type_identifier: (int)HWMEM_GRALLOC_MODULE_TYPE_IDENTIFIER,
+    framebuffer: 0,
+    flags: 0,
+    numBuffers: 0,
+    bufferMask: 0,
+    lock: PTHREAD_MUTEX_INITIALIZER,
+    currentBuffer: 0
+};
+
+
+/* Gralloc module alloc device API functions */
+static int gralloc_alloc(struct alloc_device_t* device, int width, int height, int format,
+    int usage, buffer_handle_t* handle, int* stride);
+static int gralloc_free(struct alloc_device_t* device, buffer_handle_t handle);
+
+static int open_alloc_device(const struct hwmem_gralloc_module_t* module,
+    struct alloc_device_t** alloc_device);
+static int gralloc_close_alloc_device(struct hw_device_t* device);
+
+/* Hwmem API wrappers */
+static int set_buffer_domain(struct hwmem_gralloc_buf_handle_t* buf, int usage, int left,
+    int top, int width, int height);
+
+/* Mmap */
+static int mmap_buf_if_necessary(struct hwmem_gralloc_buf_handle_t *buf, void **addr,
+    int *mmap_prot);
+/* buf_tg_infos_mutex must be held when calling this function */
+static void munmap_buf_if_necessary(struct hwmem_gralloc_buf_handle_t* buf);
+
+/* Helpers */
+static __u32 usage_2_hwmem_access(int usage);
+
+static int does_lock_usage_match_alloc_usage(int lock_usage, int alloc_usage);
+static int does_usage_match_mmap_prot(int usage, int mmap_prot);
+
+static int get_format_bpp(int format, int* bpp);
+static int is_non_planar_and_independent_pixel_format(int format);
+static int get_format_width_and_height_alignment(int format, int usage,
+    int* width_alignment, int* height_alignment);
+
+static int set_up_hwmem_region(int left, int top, int width, int height, int buf_width,
+    int buf_height, int buf_format, struct hwmem_region_us* hwmem_region);
+
+static int align_up(int value, int alignment, int* result);
+
+static int calc_buf_size(int width, int height, int format, int usage,
+    int *actual_width, int *actual_height);
+
+/*
+ * Quicker method that just calculates the size as
+ * "width * height * get_format_bpp(format) / 8" without any checks.
+ */
+static int get_buf_size(int width, int height, int format);
+
+static int get_hwmem_file_info(dev_t* device, ino_t* serial_number);
+static int is_hwmem_fd(int fd, int* is_hwmem_fd_var);
+
+static __u32 usage_2_hwmem_alloc_flags(int usage);
+static enum hwmem_mem_type usage_2_hwmem_mem_type(int usage);
+
+static int hwmem_access_2_mmap_prot(__u32 hwmem_access);
+static int limit_mmap_prot_to_usage(int mmap_prot, int usage);
+
+static int inc_buf_cnt(struct hwmem_gralloc_buf_handle_t* buf,
+    enum buf_counters buf_counter);
+static void dec_buf_cnt(struct hwmem_gralloc_buf_handle_t* buf,
+    enum buf_counters buf_counter, int lock);
+static int dec_buf_reg_cnt_if_last_usr(struct hwmem_gralloc_buf_handle_t* buf);
+
+/* buf_tg_infos_mutex muste be held when calling these functions */
+static int get_create_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf,
+    struct buf_tg_info **buf_tg_info);
+static struct buf_tg_info *get_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf);
+static void remove_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf);
+static int ensure_buf_handl_2_tg_info_map_exists(void);
+
+static int ptr_2_int(void *ptr);
+static bool are_ptrs_equal(void *ptr1, void *ptr2);
+
+
+/* Gralloc module API functions */
+
+static int gralloc_open_device(const struct hw_module_t* module, const char* name,
+    hw_device_t** device)
+{
+    const struct hwmem_gralloc_module_t* gralloc;
+
+    LOG_API_CALL("%s(%p, %s, %p)", __func__, module, name, device);
+
+    if (NULL == name || NULL == device)
+    {
+        LOG_USER_ERROR("%s: NULL == name || NULL == device", __func__);
+        return -EINVAL;
+    }
+
+    /* module_2_hwmem_gralloc_module does not write to module so the const to non
+    const cast is ok */
+    if (!module_2_hwmem_gralloc_module((struct gralloc_module_t const*)module,
+        (struct hwmem_gralloc_module_t**)&gralloc))
+        return -errno;
+
+    if (0 == strcmp(name, GRALLOC_HARDWARE_GPU0))
+    {
+        if (!open_alloc_device(gralloc, (struct alloc_device_t**)device))
+            return -errno;
+    }
+    else if (0 == strcmp(name, GRALLOC_HARDWARE_FB0))
+        return fb_device_open(module, name, device);
+    else
+    {
+        LOG_USER_ERROR("%s: Unknown device, %s", __func__, name);
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int gralloc_register_buffer(gralloc_module_t const* module, buffer_handle_t handle)
+{
+    struct hwmem_gralloc_module_t* gralloc;
+    struct hwmem_gralloc_buf_handle_t* buf;
+    struct buf_tg_info *buf_tg_info;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
+        !handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
+        return gralloc_register_buffer_pmem(module, buf);
+    if (!inc_buf_cnt(buf, REGISTER_COUNTER))
+        return -errno;
+
+    return 0;
+}
+
+static int gralloc_unregister_buffer(gralloc_module_t const* module, buffer_handle_t handle)
+{
+    struct hwmem_gralloc_module_t* gralloc;
+    struct hwmem_gralloc_buf_handle_t* buf;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
+        !handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -EINVAL;
+
+    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
+        return gralloc_unregister_buffer_pmem(module, buf);
+
+    dec_buf_cnt(buf, REGISTER_COUNTER, 1);
+
+    return 0;
+}
+
+static int gralloc_lock(gralloc_module_t const* module, buffer_handle_t handle, int usage,
+    int left, int top, int width, int height, void** addr)
+{
+    struct hwmem_gralloc_module_t* gralloc;
+    struct hwmem_gralloc_buf_handle_t* buf;
+
+    int ret = 0;
+
+    LOG_API_CALL("%s(%p, %p, %#x, %i, %i, %i, %i, %p)", __func__,
+        module, (void *)handle, (unsigned int)usage, left, top, width, height,
+        addr);
+
+    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
+        !handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
+        return gralloc_lock_pmem(module, buf, usage, left, top, width, height, addr);
+
+    /* TODO: Uncomment when applications learn to allocate buffers with correct usage */
+    /*if (!does_lock_usage_match_alloc_usage(usage, buf->usage))
+    {
+        LOG_USER_ERROR("!does_lock_usage_match_alloc_usage");
+        return -EINVAL;
+    }*/
+
+    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK))
+    {
+        int mmap_prot = 0;
+
+        if (NULL == addr)
+        {
+            LOG_USER_ERROR("%s: Software usage specified but addr == NULL", __func__);
+            return -EINVAL;
+        }
+
+        if (!mmap_buf_if_necessary(buf, addr, &mmap_prot))
+            return -errno;
+
+        if (!does_usage_match_mmap_prot(usage, mmap_prot))
+        {
+            LOG_USER_ERROR("%s: !does_usage_match_mmap_prot(usage, mmap_prot)", __func__);
+            return -EACCES;
+        }
+    }
+
+    if (!set_buffer_domain(buf, usage, left, top, width, height))
+        return -errno;
+
+    if (!inc_buf_cnt(buf, LOCK_COUNTER))
+        return -errno;
+
+    return 0;
+}
+
+static int gralloc_unlock(gralloc_module_t const* module, buffer_handle_t handle)
+{
+    struct hwmem_gralloc_module_t* gralloc;
+    struct hwmem_gralloc_buf_handle_t* buf;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
+        !handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
+        return gralloc_unlock_pmem(module, buf);
+
+    dec_buf_cnt(buf, LOCK_COUNTER, 1);
+
+    return 0;
+}
+
+static int gralloc_perform(struct gralloc_module_t const* module, int operation, ...)
+{
+    va_list args;
+    va_start(args, operation);
+
+    LOG_API_CALL("%s(%p, %i, ...)", __func__, module, operation);
+
+    switch (operation)
+    {
+        case GRALLOC_MODULE_PERFORM_GET_BUF_ALLOCATOR_HANDLE:
+        {
+            buffer_handle_t handle = va_arg(args, buffer_handle_t);
+            va_end(args);
+
+            return gralloc_get_buf_allocator_handle(module, handle);
+        }
+
+        case GRALLOC_MODULE_PERFORM_PIN_BUF:
+        {
+            buffer_handle_t handle = va_arg(args, buffer_handle_t);
+            va_end(args);
+
+            return gralloc_pin_buf(module, handle);
+        }
+
+        case GRALLOC_MODULE_PERFORM_UNPIN_BUF:
+        {
+            buffer_handle_t handle = va_arg(args, buffer_handle_t);
+            va_end(args);
+
+            return gralloc_unpin_buf(module, handle);
+        }
+
+        case GRALLOC_MODULE_PERFORM_GET_BUF_OFFSET:
+        {
+            buffer_handle_t handle = va_arg(args, buffer_handle_t);
+            va_end(args);
+
+            return gralloc_get_buf_offset(module, handle);
+        }
+
+        case GRALLOC_MODULE_PERFORM_GET_BUF_TYPE:
+        {
+            buffer_handle_t handle = va_arg(args, buffer_handle_t);
+            va_end(args);
+
+            return gralloc_get_buf_type(module, handle);
+        }
+
+        case GRALLOC_MODULE_PERFORM_GET_BUF_SIZE:
+        {
+            buffer_handle_t handle = va_arg(args, buffer_handle_t);
+            va_end(args);
+
+            return gralloc_get_buf_size(module, handle);
+        }
+
+        case GRALLOC_MODULE_PERFORM_GET_BUF_WIDTH:
+        {
+            buffer_handle_t handle = va_arg(args, buffer_handle_t);
+            va_end(args);
+
+            return gralloc_get_buf_width(module, handle);
+        }
+        case GRALLOC_MODULE_PERFORM_GET_BUF_HEIGHT:
+        {
+            buffer_handle_t handle = va_arg(args, buffer_handle_t);
+            va_end(args);
+
+            return gralloc_get_buf_height(module, handle);
+        }
+        case GRALLOC_MODULE_PERFORM_GET_BUF_FORMAT:
+        {
+            buffer_handle_t handle = va_arg(args, buffer_handle_t);
+            va_end(args);
+
+            return gralloc_get_buf_format(module, handle);
+        }
+        case GRALLOC_MODULE_PERFORM_GET_BUF_USAGE:
+        {
+            buffer_handle_t handle = va_arg(args, buffer_handle_t);
+            va_end(args);
+
+            return gralloc_get_buf_usage(module, handle);
+        }
+        case GRALLOC_MODULE_PERFORM_COMPOSITION_COMPLETE:
+        {
+            return fb_compositionComplete();
+        }
+
+
+        default:
+            va_end(args);
+
+            LOG_USER_ERROR("%s: Unknown operation, %i", __func__, operation);
+            return -EINVAL;
+    }
+}
+
+static int gralloc_create_handle_from_buffer(int fd, size_t size, size_t offset, void* base,
+    native_handle_t** handle)
+{
+    int is_hwmem_fd_var;
+    struct hwmem_get_info_request hwmem_get_info_request;
+    struct hwmem_gralloc_buf_handle_t* hwmem_gralloc_buf_handle;
+
+    LOG_API_CALL("%s(%i, %u, %u, %p, %p)", __func__, fd, size, ofset, base, handle);
+
+    if (offset > (unsigned int)INT_MAX || size > (unsigned int)INT_MAX || size == 0 || NULL == handle)
+    {
+        LOG_USER_ERROR("%s: offset > (unsigned int)INT_MAX || size > (unsigned int)INT_MAX || size == 0 || NULL == handle", __func__);
+        return -EINVAL;
+    }
+
+    if (!is_hwmem_fd(fd, &is_hwmem_fd_var))
+        return -errno;
+    if (!is_hwmem_fd_var)
+    {
+        LOG_USER_ERROR("%s: !is_hwmem_fd_var", __func__);
+        return -EINVAL;
+    }
+
+    hwmem_get_info_request.id = 0;
+    if (ioctl(fd, HWMEM_GET_INFO_IOC, &hwmem_get_info_request) < 0)
+    {
+        LOG_USER_ERROR("%s: HWMEM_GET_INFO_IOC failed, %s", __func__, strerror(errno));
+        return -errno;
+    }
+
+    if (offset + size > hwmem_get_info_request.size)
+    {
+        LOG_USER_ERROR("%s: offset + buf_size > hwmem_get_info_request.size", __func__);
+        return -EINVAL;
+    }
+
+    hwmem_gralloc_buf_handle =
+        (struct hwmem_gralloc_buf_handle_t*)native_handle_create(
+        num_fds_in_hwmem_gralloc_buf_handle, num_ints_in_hwmem_gralloc_buf_handle);
+    if (NULL == hwmem_gralloc_buf_handle)
+    {
+        LOG_ERROR("%s: Out of memory!", __func__);
+        return -ENOMEM;
+    }
+
+    hwmem_gralloc_buf_handle->fd = fd;
+    hwmem_gralloc_buf_handle->type_identifier = hwmem_gralloc_buf_handle_type_identifier;
+    hwmem_gralloc_buf_handle->width = -1;
+    hwmem_gralloc_buf_handle->height = -1;
+    hwmem_gralloc_buf_handle->format = -1;
+    hwmem_gralloc_buf_handle->usage = GRALLOC_USAGE_SW_READ_MASK |
+        GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_RENDER |
+        GRALLOC_USAGE_HW_2D;
+    hwmem_gralloc_buf_handle->addr = (int)((char *)base + offset);
+    hwmem_gralloc_buf_handle->offset = (int)offset;
+    hwmem_gralloc_buf_handle->size = (int)size;
+    hwmem_gralloc_buf_handle->type = GRALLOC_BUF_TYPE_HWMEM_CONTIGUOUS;
+
+    *handle = (native_handle_t*)hwmem_gralloc_buf_handle;
+
+    return 0;
+}
+
+static int gralloc_get_buf_allocator_handle(struct gralloc_module_t const* module,
+    buffer_handle_t handle)
+{
+    struct hwmem_gralloc_module_t* gralloc;
+    struct hwmem_gralloc_buf_handle_t* buf;
+
+    int buf_hwmem_name;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
+        !handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
+        return gralloc_get_buf_allocator_handle_pmem(module, buf);
+
+    buf_hwmem_name = ioctl(buf->fd, HWMEM_EXPORT_IOC, 0);
+    if (buf_hwmem_name < 0)
+    {
+        LOG_ERROR("%s: HWMEM_EXPORT_IOC failed, %s", __func__, strerror(errno));
+    }
+
+    return buf_hwmem_name;
+}
+
+static int gralloc_pin_buf(struct gralloc_module_t const *module,
+        buffer_handle_t handle)
+{
+    struct hwmem_gralloc_module_t *gralloc;
+    struct hwmem_gralloc_buf_handle_t *buf;
+
+    struct hwmem_pin_request pin;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
+            !handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
+        return gralloc_pin_buf_pmem(module, buf);
+
+    pin.id = 0;
+    if (ioctl(buf->fd, HWMEM_PIN_IOC, &pin) < 0) {
+        ALOGE("%s: Could not pin hwmem buffer!", __func__);
+        return -errno;
+    }
+
+    return (int)pin.phys_addr + buf->offset;
+}
+
+static int gralloc_unpin_buf(struct gralloc_module_t const* module,
+        buffer_handle_t handle)
+{
+    struct hwmem_gralloc_module_t *gralloc;
+    struct hwmem_gralloc_buf_handle_t *buf;
+
+    struct hwmem_pin_request pin;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
+            !handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
+        return gralloc_unpin_buf_pmem(module, buf);
+
+    if (ioctl(buf->fd, HWMEM_UNPIN_IOC, 0) < 0) {
+        ALOGE("%s: Could not unpin hwmem buffer!", __func__);
+        return -errno;
+    }
+
+    return 0;
+}
+
+static int gralloc_get_buf_offset(struct gralloc_module_t const* module,
+    buffer_handle_t handle)
+{
+    struct hwmem_gralloc_module_t* gralloc;
+    struct hwmem_gralloc_buf_handle_t* buf;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!module_2_hwmem_gralloc_module(module, &gralloc) ||
+        !handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -EINVAL;
+
+    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
+        return gralloc_get_buf_offset_pmem(module, buf);
+
+    return buf->offset;
+}
+
+static int gralloc_get_buf_type(struct gralloc_module_t const* module,
+    buffer_handle_t handle)
+{
+    struct hwmem_gralloc_buf_handle_t* buf;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    return buf->type;
+}
+
+static int gralloc_get_buf_size(struct gralloc_module_t const* module,
+    buffer_handle_t handle)
+{
+    struct hwmem_gralloc_buf_handle_t* buf;
+    int buf_size;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    /* If this is a wrapped handle, just return the stored size */
+    if (buf->size != -1)
+        return buf->size;
+
+    buf_size = get_buf_size(buf->width, buf->height, buf->format);
+    if (buf_size < 0)
+        return -errno;
+
+    return buf_size;
+}
+
+static int gralloc_get_buf_width(struct gralloc_module_t const* module,
+    buffer_handle_t handle)
+{
+    struct hwmem_gralloc_buf_handle_t* buf;
+    int buf_size;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    return buf->width;
+}
+
+static int gralloc_get_buf_height(struct gralloc_module_t const* module,
+    buffer_handle_t handle)
+{
+    struct hwmem_gralloc_buf_handle_t* buf;
+    int buf_size;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    return buf->height;
+}
+
+static int gralloc_get_buf_format(struct gralloc_module_t const* module,
+    buffer_handle_t handle)
+{
+    struct hwmem_gralloc_buf_handle_t* buf;
+    int buf_size;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    return buf->format;
+}
+
+static int gralloc_get_buf_usage(struct gralloc_module_t const* module,
+    buffer_handle_t handle)
+{
+    struct hwmem_gralloc_buf_handle_t* buf;
+    int buf_size;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, (void *)handle);
+
+    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    return buf->usage;
+}
+
+
+/* Gralloc module alloc device API functions */
+
+static int gralloc_alloc(struct alloc_device_t* device, int width, int height, int format,
+    int usage, buffer_handle_t* handle, int* stride)
+{
+    int ret = 0;
+    int last_result;
+    int hwmem_fd = -1;
+    int actual_width;
+    int actual_height;
+    int buf_size;
+    struct hwmem_alloc_request hwmem_alloc_request;
+    struct hwmem_gralloc_buf_handle_t* buf_handle = NULL;
+
+    LOG_API_CALL("%s(%p, %i, %i, %#x, %#x, %p, %p)", __func__, device,
+        width, height, (unsigned int)format, (unsigned int)usage,
+        handle, stride);
+
+    if (NULL == device || NULL == handle)
+    {
+        LOG_USER_ERROR("%s: NULL == device || NULL == handle", __func__);
+        return -EINVAL;
+    }
+
+    if (!(usage & GRALLOC_USAGE_HW_MASK))
+    {
+        LOG_WARNING_ALWAYS("%s: Gralloc is used to alloc software only buffers!", __func__);
+    }
+
+    buf_size = calc_buf_size(width, height, format, usage, &actual_width, &actual_height);
+    if (buf_size < 0)
+        return -errno;
+
+    if (usage & GRALLOC_USAGE_HW_FB)
+    {
+        int handled;
+
+        last_result = gralloc_alloc_framebuffer(device, buf_size, usage, handle, stride, &handled);
+        if (last_result < 0)
+        {
+            LOG_ERROR("%s: gralloc_alloc_framebuffer (google) failed, %s", __func__, strerror(-last_result));
+            return last_result;
+        }
+
+        if (handled)
+            return 0;
+        else
+            usage &= ~GRALLOC_USAGE_HW_FB;
+    }
+
+    if (!is_non_planar_and_independent_pixel_format(format))
+        usage |= GRALLOC_USAGE_HW_2D;
+
+    hwmem_fd = open(hwmem_files_full_name, O_RDWR);
+    if (hwmem_fd < 0)
+    {
+        LOG_ERROR("%s: open failed, %s", __func__, strerror(errno));
+        return -errno;
+    }
+
+    hwmem_alloc_request.size = (unsigned int)buf_size;
+    hwmem_alloc_request.flags = usage_2_hwmem_alloc_flags(usage);
+    hwmem_alloc_request.default_access =
+        /* TODO: Uncomment when applications learn to allocate buffers with correct usage */
+        /* usage_2_hwmem_access(usage); */
+        HWMEM_ACCESS_READ | HWMEM_ACCESS_WRITE;
+    hwmem_alloc_request.mem_type = usage_2_hwmem_mem_type(usage);
+    if (ioctl(hwmem_fd, HWMEM_ALLOC_FD_IOC, &hwmem_alloc_request) < 0)
+    {
+        LOG_ERROR("%s: HWMEM_ALLOC_IOC failed, %s", __func__, strerror(errno));
+        ret = -errno;
+        goto alloc_failed;
+    }
+
+    buf_handle =
+        (struct hwmem_gralloc_buf_handle_t*)native_handle_create(
+        num_fds_in_hwmem_gralloc_buf_handle, num_ints_in_hwmem_gralloc_buf_handle);
+    if (NULL == buf_handle)
+    {
+        LOG_ERROR("%s: Out of memory!", __func__);
+        ret = -ENOMEM;
+        goto native_handle_create_failed;
+    }
+
+    buf_handle->fd = hwmem_fd;
+    buf_handle->type_identifier = hwmem_gralloc_buf_handle_type_identifier;
+    buf_handle->width = actual_width;
+    buf_handle->height = actual_height;
+    buf_handle->format = format;
+    buf_handle->usage = usage;
+    buf_handle->offset = 0;
+    buf_handle->size = -1;
+    if (hwmem_alloc_request.mem_type == HWMEM_MEM_SCATTERED_SYS)
+    {
+        buf_handle->type = GRALLOC_BUF_TYPE_HWMEM_SCATTERED;
+    }
+    else
+    {
+        buf_handle->type = GRALLOC_BUF_TYPE_HWMEM_CONTIGUOUS;
+    }
+
+    if (!inc_buf_cnt(buf_handle, REGISTER_COUNTER))
+    {
+        ret = -errno;
+        goto inc_buf_cnt_failed;
+    }
+
+    *handle = (buffer_handle_t)buf_handle;
+
+    if (stride != NULL)
+    {
+        *stride = actual_width;
+    }
+
+    goto out;
+
+inc_buf_cnt_failed:
+    last_result = native_handle_delete((native_handle_t *)buf_handle);
+    if (last_result < 0)
+    {
+        LOG_ERROR("%s: native_handle_delete, %s. Resource leak!", __func__, strerror(-last_result));
+    }
+native_handle_create_failed:
+alloc_failed:
+    if (close(hwmem_fd) < 0)
+    {
+        LOG_ERROR("%s: close failed, %s. Resource leak!", __func__, strerror(errno));
+    }
+
+out:
+    return ret;
+}
+
+static int gralloc_free(struct alloc_device_t* device, buffer_handle_t handle)
+{
+    int last_ret;
+    struct hwmem_gralloc_buf_handle_t* buf;
+    struct buf_tg_info *buf_tg_info;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, device, (void *)handle);
+
+    if (!handle_2_hwmem_gralloc_handle(handle, &buf))
+        return -errno;
+
+    if ((buf->type == GRALLOC_BUF_TYPE_PMEM) || (buf->type == GRALLOC_BUF_TYPE_FB))
+        return gralloc_free_pmem(device, buf);
+
+    if (!dec_buf_reg_cnt_if_last_usr(buf))
+        return -errno;
+
+    last_ret = native_handle_close((const native_handle_t*)buf);
+    if (last_ret < 0)
+    {
+        LOG_ERROR("%s: native_handle_close failed, %s. Resource leak!", __func__, strerror(-last_ret));
+    }
+
+    last_ret = native_handle_delete((native_handle_t*)buf);
+    if (last_ret < 0)
+    {
+        LOG_ERROR("%s: native_handle_delete failed, %s. Resource leak!", __func__, strerror(-last_ret));
+    }
+
+    return 0;
+}
+
+static int open_alloc_device(const struct hwmem_gralloc_module_t* module,
+    struct alloc_device_t** alloc_device)
+{
+    const struct hwmem_gralloc_module_t* gralloc;
+
+    LOG_API_CALL("%s(%p, %p)", __func__, module, alloc_device);
+
+    /* module_2_hwmem_gralloc_module does not write to module so the const to non
+    const cast is ok */
+    if (!module_2_hwmem_gralloc_module((struct gralloc_module_t const*)module,
+        (struct hwmem_gralloc_module_t**)&gralloc))
+        return 0;
+
+    if (NULL == alloc_device)
+    {
+        LOG_USER_ERROR("%s: NULL == alloc_device", __func__);
+        errno = EINVAL;
+        return 0;
+    }
+
+    *alloc_device = (alloc_device_t*)malloc(sizeof(alloc_device_t));
+    if (NULL == *alloc_device)
+    {
+        LOG_ERROR("%s: Out of memory!", __func__);
+        errno = ENOMEM;
+        return 0;
+    }
+
+    memset(*alloc_device, 0, sizeof(**alloc_device));
+
+    (*alloc_device)->common.tag = HARDWARE_DEVICE_TAG;
+    (*alloc_device)->common.version = 1;
+    /* Dangerous cast but it can't be avoided given the current gralloc API. */
+    (*alloc_device)->common.module = (hw_module_t*)gralloc;
+    (*alloc_device)->common.close = gralloc_close_alloc_device;
+
+    (*alloc_device)->alloc = gralloc_alloc;
+    (*alloc_device)->free = gralloc_free;
+
+    return 1;
+}
+
+static int gralloc_close_alloc_device(struct hw_device_t* device)
+{
+    LOG_API_CALL("%s(%p)", __func__, device);
+
+    if (NULL == device)
+    {
+        LOG_USER_ERROR("%s: NULL == device", __func__);
+        return -EINVAL;
+    }
+
+    /* It would be nice to free all the device's buffers here in case the application
+    forgot. The problem with that approach is the native_handle_close/delete functions.
+    It's not unlikely that an application erronously closes a handle with
+    native_handle_close/delete instead of free and in that case the cleanup code here
+    will try to free an invalid handle which will probably crash the application. Not
+    cleaning up here on the other hand might lead to temporary resource leaks (till the
+    application dies) so the choice is between possibly crashing a faulty application or
+    letting it temporarily leak some resources, I choose the second alternative. If
+    problems arise we'll have to re-evaluate this choice. */
+
+    free(device);
+
+    return 0;
+}
+
+
+/* Hwmem API wrappers */
+
+static int set_buffer_domain(struct hwmem_gralloc_buf_handle_t* buf,
+    int usage, int left, int top, int width, int height)
+{
+    struct hwmem_set_domain_request request;
+
+    request.id = 0;
+    request.access = usage_2_hwmem_access(usage);
+
+    if (buf->size != -1)
+    {
+        /* We don't have enough information for a partial domain switch in the wrapping
+        handle case so we switch domain for the entire buffer. */
+
+        request.region.offset = buf->offset;
+        request.region.count = 1;
+        request.region.start = 0;
+        request.region.end = buf->size;
+        request.region.size = buf->size;
+    }
+    else
+    {
+        if (!set_up_hwmem_region(left, top, width, height, buf->width, buf->height,
+            buf->format, &request.region))
+            return 0;
+    }
+
+    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
+        if (ioctl(buf->fd, HWMEM_SET_CPU_DOMAIN_IOC, &request) < 0)
+        {
+            LOG_ERROR("%s: HWMEM_SET_DOMAIN_IOC failed, %s", __func__, strerror(errno));
+            return 0;
+        }
+    } else {
+        if (ioctl(buf->fd, HWMEM_SET_SYNC_DOMAIN_IOC, &request) < 0)
+        {
+            LOG_ERROR("%s: HWMEM_SET_DOMAIN_IOC failed, %s", __func__, strerror(errno));
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+
+/* Mmap */
+
+static int mmap_buf_if_necessary(struct hwmem_gralloc_buf_handle_t *buf, void **addr,
+    int *mmap_prot)
+{
+    int ret = 1;
+    struct buf_tg_info *buf_tg_info;
+    struct hwmem_get_info_request buf_info;
+
+    /* Wrapper handles are not memory mapped by gralloc */
+    if (buf->size != -1)
+    {
+        if ((int)NULL == buf->addr)
+        {
+            LOG_USER_ERROR("%s, Wrapper handle is not memory mapped", __func__);
+            errno = -ENOMSG;
+            return 0;
+        }
+
+        *addr = (void *)buf->addr;
+        *mmap_prot = PROT_READ | PROT_WRITE;
+
+        return 1;
+    }
+
+    mutex_lock(&buf_tg_infos_mutex);
+
+    buf_tg_info = get_buf_tg_info(buf);
+    if (NULL == buf_tg_info)
+    {
+        LOG_USER_ERROR("%s: Memory mapping unregistered buffer", __func__);
+        errno = ENOMSG;
+        goto no_buf_tg_info;
+    }
+
+    /* Check if we are already mapped */
+    if (buf_tg_info->addr != NULL)
+    {
+        *addr = buf_tg_info->addr;
+        *mmap_prot = buf_tg_info->mmap_prot;
+
+        goto out;
+    }
+
+    buf_info.id = 0;
+    if (ioctl(buf->fd, HWMEM_GET_INFO_IOC, &buf_info) < 0)
+    {
+        LOG_ERROR("%s: HWMEM_GET_INFO_IOC failed, %s", __func__, strerror(errno));
+        goto hwmem_get_info_failed;
+    }
+
+    buf_tg_info->mmap_prot = hwmem_access_2_mmap_prot(buf_info.access);
+    /* TODO: Uncomment when applications learns to allocate buffers with correct usage */
+    /*buf_tg_info->mmap_prot = limit_mmap_prot_to_usage(buf_tg_info->mmap_prot,
+        buf->usage);*/
+
+    buf_tg_info->addr = mmap(NULL, buf_info.size, buf_tg_info->mmap_prot, MAP_SHARED,
+        buf->fd, 0);
+    if (MAP_FAILED == buf_tg_info->addr)
+    {
+        LOG_ERROR("%s: mmap failed, %s", __func__, strerror(errno));
+        goto mmap_failed;
+    }
+
+    *addr = buf_tg_info->addr;
+    *mmap_prot = buf_tg_info->mmap_prot;
+
+    goto out;
+
+mmap_failed:
+    buf_tg_info->addr = NULL;
+hwmem_get_info_failed:
+no_buf_tg_info:
+    ret = 0;
+
+out:
+    mutex_unlock(&buf_tg_infos_mutex);
+
+    return ret;
+}
+
+/* buf_tg_infos_mutex must be held when calling this function */
+static void munmap_buf_if_necessary(struct hwmem_gralloc_buf_handle_t* buf)
+{
+    struct buf_tg_info *buf_tg_info;
+    struct hwmem_get_info_request buf_info;
+
+    buf_tg_info = get_buf_tg_info(buf);
+    if (NULL == buf_tg_info)
+    {
+        LOG_USER_ERROR("%s: Unmapping unregistered buffer", __func__);
+        return;
+    }
+
+    if (NULL == buf_tg_info->addr)
+        return;
+
+    buf_info.id = 0;
+    if (ioctl(buf->fd, HWMEM_GET_INFO_IOC, &buf_info) < 0)
+    {
+        LOG_ERROR("%s: HWMEM_GET_INFO_IOC failed, %s. Resource leak!", __func__, strerror(errno));
+        return;
+    }
+
+    if (munmap(buf_tg_info->addr, buf_info.size) < 0)
+    {
+        LOG_ERROR("%s: munmap failed, %s. Resource leak!", __func__, strerror(errno));
+        return;
+    }
+
+    buf_tg_info->addr = NULL;
+}
+
+
+/* Helpers */
+
+int module_2_hwmem_gralloc_module(struct gralloc_module_t const* module,
+    struct hwmem_gralloc_module_t** gralloc_out)
+{
+    struct hwmem_gralloc_module_t* gralloc =
+            (struct hwmem_gralloc_module_t *)module;
+
+    if (NULL == gralloc || gralloc->base.common.tag != HARDWARE_MODULE_TAG ||
+        gralloc->type_identifier != (int)HWMEM_GRALLOC_MODULE_TYPE_IDENTIFIER)
+    {
+        LOG_USER_ERROR("%s, Invalid module", __func__);
+        errno = EINVAL;
+        return 0;
+    }
+
+    *gralloc_out = gralloc;
+
+    return 1;
+
+}
+
+int handle_2_hwmem_gralloc_handle(buffer_handle_t handle,
+        struct hwmem_gralloc_buf_handle_t **buf_out)
+{
+    struct hwmem_gralloc_buf_handle_t *buf =
+            (struct hwmem_gralloc_buf_handle_t*)handle;
+
+    if (NULL == buf || buf->base.version != sizeof(native_handle_t) ||
+        buf->base.numFds != num_fds_in_hwmem_gralloc_buf_handle ||
+        buf->base.numInts != num_ints_in_hwmem_gralloc_buf_handle ||
+        buf->type_identifier != hwmem_gralloc_buf_handle_type_identifier)
+    {
+        LOG_USER_ERROR("%s: Invalid handle", __func__);
+        errno = EINVAL;
+        return 0;
+    }
+
+    *buf_out = buf;
+
+    return 1;
+}
+
+static __u32 usage_2_hwmem_access(int usage)
+{
+    __u32 hwmem_access = 0;
+
+    if (usage & GRALLOC_USAGE_SW_READ_MASK)
+        hwmem_access |= HWMEM_ACCESS_READ;
+    if (usage & GRALLOC_USAGE_SW_WRITE_MASK || usage & GRALLOC_USAGE_HW_RENDER)
+        hwmem_access |= HWMEM_ACCESS_WRITE;
+    if (usage & (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_2D | GRALLOC_USAGE_HW_FB))
+        hwmem_access |= HWMEM_ACCESS_READ | HWMEM_ACCESS_WRITE;
+
+    return hwmem_access;
+}
+
+static int does_lock_usage_match_alloc_usage(int lock_usage, int alloc_usage)
+{
+    int lock_sw_read = lock_usage & GRALLOC_USAGE_SW_READ_MASK;
+    int lock_sw_write = lock_usage & GRALLOC_USAGE_SW_WRITE_MASK;
+    int alloc_sw_read = alloc_usage & GRALLOC_USAGE_SW_READ_MASK;
+    int alloc_sw_write = alloc_usage & GRALLOC_USAGE_SW_WRITE_MASK;
+
+    if ((lock_sw_read && !alloc_sw_read) ||
+        (lock_sw_write && !alloc_sw_write) ||
+        ((lock_usage & GRALLOC_USAGE_HW_MASK) & (alloc_usage & GRALLOC_USAGE_HW_MASK)) != (lock_usage & GRALLOC_USAGE_HW_MASK))
+        return 0;
+    else
+        return 1;
+}
+
+static int does_usage_match_mmap_prot(int usage, int mmap_prot)
+{
+    int usage_sw_read = usage & GRALLOC_USAGE_SW_READ_MASK;
+    int usage_sw_write = usage & GRALLOC_USAGE_SW_WRITE_MASK;
+    int mmap_prot_read = mmap_prot & PROT_READ;
+    int mmap_prot_write = mmap_prot & PROT_WRITE;
+
+    if ((usage_sw_read && !mmap_prot_read) ||
+        (usage_sw_write && !mmap_prot_write))
+        return 0;
+    else
+        return 1;
+}
+
+static int get_format_bpp(int format, int* bpp)
+{
+    switch (format)
+    {
+        case HAL_PIXEL_FORMAT_RGBA_8888:
+        case HAL_PIXEL_FORMAT_RGBX_8888:
+        case HAL_PIXEL_FORMAT_BGRA_8888:
+            *bpp = 32;
+            break;
+
+        case HAL_PIXEL_FORMAT_RGB_888:
+            *bpp = 24;
+            break;
+
+        case HAL_PIXEL_FORMAT_RGB_565:
+        case HAL_PIXEL_FORMAT_RGBA_5551:
+        case HAL_PIXEL_FORMAT_RGBA_4444:
+        case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+        case HAL_PIXEL_FORMAT_YCbCr_422_P:
+        case HAL_PIXEL_FORMAT_YCbCr_422_I:
+        case HAL_PIXEL_FORMAT_CbYCrY_422_I:
+        case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_422_P:
+            *bpp = 16;
+            break;
+
+        case HAL_PIXEL_FORMAT_YCBCR42XMBN: /* Interpreted as HAL_PIXEL_FORMAT_YCBCR420MBN */
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+        case HAL_PIXEL_FORMAT_YCbCr_420_P:
+        case HAL_PIXEL_FORMAT_YCbCr_420_I:
+        case HAL_PIXEL_FORMAT_CbYCrY_420_I:
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_420_P:
+        case HAL_PIXEL_FORMAT_YV12:
+            *bpp = 12;
+            break;
+
+        default:
+            LOG_USER_ERROR("%s: Unknown format, %i", __func__, format);
+            errno = EINVAL;
+            return 0;
+    }
+
+    return 1;
+}
+
+static int is_non_planar_and_independent_pixel_format(int format)
+{
+    switch (format)
+    {
+        case HAL_PIXEL_FORMAT_RGBA_8888:
+        case HAL_PIXEL_FORMAT_RGBX_8888:
+        case HAL_PIXEL_FORMAT_BGRA_8888:
+        case HAL_PIXEL_FORMAT_RGB_888:
+        case HAL_PIXEL_FORMAT_RGB_565:
+        case HAL_PIXEL_FORMAT_RGBA_5551:
+        case HAL_PIXEL_FORMAT_RGBA_4444:
+            return 1;
+    }
+
+    return 0;
+}
+
+static int get_format_width_and_height_alignment(int format, int usage,
+    int* width_alignment, int* height_alignment)
+{
+    switch (format) {
+        case HAL_PIXEL_FORMAT_RGBX_8888:
+	    if (usage & (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_COMPOSER | GRALLOC_USAGE_HW_RENDER))
+	        *width_alignment = 2;
+	    else
+	        *width_alignment = 1;
+	    *height_alignment = 1;
+            break;
+
+        case HAL_PIXEL_FORMAT_RGBA_8888:
+        case HAL_PIXEL_FORMAT_BGRA_8888:
+	    if (usage & (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_COMPOSER | GRALLOC_USAGE_HW_RENDER))
+                *width_alignment = 2;
+            else
+                *width_alignment = 1;
+            *height_alignment = 1;
+            break;
+
+        case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+        case HAL_PIXEL_FORMAT_YCbCr_422_P:
+        case HAL_PIXEL_FORMAT_YCbCr_422_I:
+        case HAL_PIXEL_FORMAT_CbYCrY_422_I:
+        case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_422_P:
+            *width_alignment = 2;
+            *height_alignment = 1;
+            break;
+
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+        case HAL_PIXEL_FORMAT_YCbCr_420_P:
+        case HAL_PIXEL_FORMAT_YCbCr_420_I:
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP_TILED:
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_420_P:
+        case HAL_PIXEL_FORMAT_CbYCrY_420_I:
+            *width_alignment = 2;
+            *height_alignment = 2;
+            break;
+
+        case HAL_PIXEL_FORMAT_RGB_565:
+        case HAL_PIXEL_FORMAT_RGBA_5551:
+        case HAL_PIXEL_FORMAT_RGBA_4444:
+            if (usage & (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_RENDER))
+                *width_alignment = 4;
+            else
+                *width_alignment = 1;
+            *height_alignment = 1;
+            break;
+
+        case HAL_PIXEL_FORMAT_RGB_888:
+            if (usage & (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_COMPOSER | GRALLOC_USAGE_HW_RENDER))
+                *width_alignment = 8;
+            else if (usage & GRALLOC_USAGE_HW_2D)
+                *width_alignment = 4;
+            else
+                *width_alignment = 1;
+            *height_alignment = 1;
+            break;
+
+        case HAL_PIXEL_FORMAT_YCBCR42XMBN:
+            *width_alignment = 16;
+            *height_alignment = 16;
+            break;
+
+        case HAL_PIXEL_FORMAT_YV12:
+            *width_alignment = 16;
+            *height_alignment = 2;
+            break;
+
+        default:
+            LOG_USER_ERROR("%s: Unknown format, %i", __func__, format);
+            errno = EINVAL;
+            return 0;
+    }
+
+    return 1;
+}
+
+static int set_up_hwmem_region(int left, int top, int width, int height, int buf_width,
+    int buf_height, int buf_format, struct hwmem_region_us* hwmem_region)
+{
+    int buf_format_bpp;
+    int actual_left, actual_top, actual_width, actual_height;
+    int pitch;
+
+    if (left < 0 || top < 0 || width < 0 || height < 0 || left > INT_MAX - width ||
+        left + width > buf_width || top > INT_MAX - height ||
+        top + height > buf_height)
+    {
+        LOG_USER_ERROR("%s: left < 0 || top < 0 || width < 0 || height < 0 || left > INT_MAX - width || left + width > buf_width || top > INT_MAX - height || top + height > buf_height", __func__);
+        errno = EINVAL;
+        return 0;
+    }
+
+    if (!get_format_bpp(buf_format, &buf_format_bpp))
+        return 0;
+
+    if (is_non_planar_and_independent_pixel_format(buf_format))
+    {
+        actual_left = left;
+        actual_top = top;
+        actual_width = width;
+        actual_height = height;
+    }
+    else
+    {
+        /* TODO: Locking entire buffer as a quick safe solution. In the future
+        we should lock less to avoid unecessary cache syncing. Pixel interleaved
+        YCbCr formats should be quite easy, just align start and stop points on 2. */
+        actual_left = 0;
+        actual_top = 0;
+        actual_width = buf_width;
+        actual_height = buf_height;
+    }
+
+    pitch = (buf_width * buf_format_bpp) / 8;
+
+    hwmem_region->offset = (unsigned int)(actual_top * pitch);
+    hwmem_region->count = (unsigned int)actual_height;
+    hwmem_region->start = (unsigned int)((actual_left * buf_format_bpp) / 8);
+    hwmem_region->end = (unsigned int)
+        (((actual_left + actual_width) * buf_format_bpp) / 8);
+    hwmem_region->size = (unsigned int)pitch;
+
+    return 1;
+}
+
+static int align_up(int value, int alignment, int* result)
+{
+    int remainder = value % alignment;
+    int value_to_add;
+
+    /* We never align negative values so there is no point dealing with that */
+    if (value < 0 || alignment < 0)
+    {
+        LOG_ERROR("%s: value < 0 || alignment < 0", __func__);
+        errno = EINVAL;
+        return 0;
+    }
+
+    if (remainder > 0)
+        value_to_add = alignment - remainder;
+    else
+        value_to_add = 0;
+
+    if (value > INT_MAX - value_to_add)
+    {
+        /* Will result in overflow */
+        LOG_ERROR("%s: value > INT_MAX - value_to_add", __func__);
+        errno = ERANGE;
+        return 0;
+    }
+
+    *result = value + value_to_add;
+
+    return 1;
+}
+
+static int calc_buf_size(int width, int height, int format, int usage,
+    int* actual_width, int* actual_height)
+{
+    int bpp;
+    int format_width_alignment;
+    int format_height_alignment;
+
+    if (width < 0 || height < 0)
+    {
+        LOG_USER_ERROR("%s: width < 0 || height < 0", __func__);
+        errno = EINVAL;
+        return -1;
+    }
+
+    if (!get_format_bpp(format, &bpp))
+        return -1;
+
+    if (!get_format_width_and_height_alignment(format, usage,
+        &format_width_alignment, &format_height_alignment))
+        return -1;
+
+    if (!align_up(width, format_width_alignment, actual_width) ||
+        !align_up(height, format_height_alignment, actual_height))
+        return -1;
+
+    if (*actual_width > max_width_height || *actual_height > max_width_height)
+    {
+        LOG_USER_ERROR("%s: actual_width > max_width_height || actual_height > max_width_height", __func__);
+        errno = EINVAL;
+        return -1;
+    }
+
+    if (format == HAL_PIXEL_FORMAT_YV12) {
+        int uv_stride;
+        int mean_stride;
+        /*
+         * Y stride needs to be aligned to 16 pixels, and
+         * the U/V stride needs to be half of Y stride
+         * aligned to 16. In other words:
+         *   y_size = stride * height
+         *   c_size = ALIGN(stride/2, 16) * height/2
+         *   size = y_size + c_size * 2
+         * However, b2r2 does not recognize the YV12 format
+         * being any different than the YVU420P which requires
+         * the U/V stride to be half of the Y stride, and
+         * therefore we align the pitch to 32.
+         */
+        align_up(*actual_width >> 1, 16, &uv_stride);
+        mean_stride = uv_stride + (*actual_width >> 1);
+        return (mean_stride * (*actual_height) * bpp) >> 3;
+    } else {
+        return ((*actual_width) * (*actual_height) * bpp) >> 3;
+    }
+}
+
+static int get_buf_size(int width, int height, int format)
+{
+    int bpp;
+
+    if (!get_format_bpp(format, &bpp))
+        return -1;
+
+    return (width * height * bpp) / 8;
+}
+
+static int get_hwmem_file_info(dev_t* device, ino_t* serial_number)
+{
+    static int write_values_initiated = 0;
+    static int error_occured_when_retreiving_hwmem_file_info = 0;
+    static int error_code_produced_when_retreiving_hwmem_file_info;
+    static int cached_values_present = 0;
+    static dev_t hwmem_files_device;
+    static ino_t hwmem_files_serial_number;
+
+    struct stat hwmem_file_info;
+
+    if (error_occured_when_retreiving_hwmem_file_info)
+    {
+        errno = error_code_produced_when_retreiving_hwmem_file_info;
+
+        return 0;
+    }
+    else if (cached_values_present)
+    {
+        *device = hwmem_files_device;
+        *serial_number = hwmem_files_serial_number;
+
+        return 1;
+    }
+
+    if (stat(hwmem_files_full_name, &hwmem_file_info) < 0)
+    {
+        if (0 == android_atomic_cmpxchg(0, 1, &write_values_initiated))
+        {
+            error_code_produced_when_retreiving_hwmem_file_info = errno;
+            android_atomic_write(1, &error_occured_when_retreiving_hwmem_file_info);
+        }
+
+        LOG_ERROR("%s: stat failed, %s", __func__, strerror(errno));
+        return 0;
+    }
+
+    if (0 == android_atomic_cmpxchg(0, 1, &write_values_initiated))
+    {
+        hwmem_files_device = hwmem_file_info.st_dev;
+        hwmem_files_serial_number = hwmem_file_info.st_ino;
+        android_atomic_write(1, &cached_values_present);
+    }
+
+    *device = hwmem_file_info.st_dev;
+    *serial_number = hwmem_file_info.st_ino;
+
+    return 1;
+}
+
+static int is_hwmem_fd(int fd, int* is_hwmem_fd_var)
+{
+    dev_t hwmem_file_device;
+    ino_t hwmem_file_serial_number;
+
+    struct stat file_info;
+
+    if (!get_hwmem_file_info(&hwmem_file_device, &hwmem_file_serial_number))
+        return 0;
+
+    if (fstat(fd, &file_info) < 0)
+    {
+        LOG_USER_ERROR("%s: stat failed, %s", __func__, strerror(errno));
+        return 0;
+    }
+
+    if (file_info.st_dev == hwmem_file_device &&
+        file_info.st_ino == hwmem_file_serial_number)
+        *is_hwmem_fd_var = 1;
+    else
+        *is_hwmem_fd_var = 0;
+
+    return 1;
+}
+
+static __u32 usage_2_hwmem_alloc_flags(int usage)
+{
+    int sw_usage = usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK);
+    int hw_usage = usage & GRALLOC_USAGE_HW_MASK;
+
+    if (sw_usage == 0)
+        return HWMEM_ALLOC_HINT_UNCACHED;
+    else if (sw_usage & GRALLOC_USAGE_SW_READ_OFTEN ||
+        (sw_usage & GRALLOC_USAGE_SW_READ_RARELY && !(hw_usage &
+        (GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_2D))))
+    {
+        /* Read often, or rarely with no chance of HW write -> SW read (invalidate
+        needed) */
+        if (sw_usage & GRALLOC_USAGE_SW_WRITE_OFTEN)
+            return HWMEM_ALLOC_HINT_WRITE_COMBINE | HWMEM_ALLOC_HINT_CACHED |
+                HWMEM_ALLOC_HINT_CACHE_WB;
+        else
+            return HWMEM_ALLOC_HINT_WRITE_COMBINE | HWMEM_ALLOC_HINT_CACHED |
+                HWMEM_ALLOC_HINT_CACHE_WT;
+    }
+    else
+        /* Write often/rarely, read rarely with risk of HW write -> SW read or a
+        combination of the two */
+        return HWMEM_ALLOC_HINT_UNCACHED | HWMEM_ALLOC_HINT_WRITE_COMBINE;
+}
+
+static enum hwmem_mem_type usage_2_hwmem_mem_type(int usage)
+{
+    if (usage & GRALLOC_USAGE_PROTECTED) {
+        return HWMEM_MEM_PROTECTED_SYS;
+    }
+    else if (usage & GRALLOC_USAGE_HW_2D) {
+        return HWMEM_MEM_CONTIGUOUS_SYS;
+    }
+
+    return HWMEM_MEM_SCATTERED_SYS;
+}
+
+static int hwmem_access_2_mmap_prot(__u32 hwmem_access)
+{
+    int mmap_prot = 0;
+
+    if (hwmem_access & HWMEM_ACCESS_READ)
+        mmap_prot |= PROT_READ;
+    if (hwmem_access & HWMEM_ACCESS_WRITE)
+        mmap_prot |= PROT_WRITE;
+
+    return mmap_prot;
+}
+
+static int limit_mmap_prot_to_usage(int mmap_prot, int usage)
+{
+    int new_mmap_prot = mmap_prot & ~PROT_EXEC;
+
+    if (!(usage & GRALLOC_USAGE_SW_READ_MASK))
+        new_mmap_prot &= ~PROT_READ;
+    if (!(usage & GRALLOC_USAGE_SW_WRITE_MASK))
+        new_mmap_prot &= ~PROT_WRITE;
+
+    return new_mmap_prot;
+}
+
+static int inc_buf_cnt(struct hwmem_gralloc_buf_handle_t* buf,
+    enum buf_counters buf_counter)
+{
+    int ret = 1;
+    struct buf_tg_info *buf_tg_info;
+    int *cnt;
+
+    /* Wrapper handles don't have thread group info */
+    if (buf->size != -1)
+        return 1;
+
+    mutex_lock(&buf_tg_infos_mutex);
+
+    if (!get_create_buf_tg_info(buf, &buf_tg_info))
+        goto get_create_buf_tg_info_failed;
+
+    switch (buf_counter)
+    {
+        case REGISTER_COUNTER:
+            cnt = &buf_tg_info->reg_cnt;
+            break;
+
+        case LOCK_COUNTER:
+            cnt = &buf_tg_info->lock_cnt;
+            break;
+
+        default:
+            LOG_ERROR("%s: Unknown buffer counter, %i", __func__, buf_counter);
+            goto out;
+    }
+
+    if (*cnt == INT_MAX)
+    {
+        LOG_ERROR("%s: *cnt == INT_MAX", __func__);
+        goto overflow;
+    }
+
+    (*cnt)++;
+
+    goto out;
+
+overflow:
+get_create_buf_tg_info_failed:
+    ret = 0;
+
+out:
+    mutex_unlock(&buf_tg_infos_mutex);
+
+    return ret;
+}
+
+static void dec_buf_cnt(struct hwmem_gralloc_buf_handle_t* buf,
+    enum buf_counters buf_counter, int lock)
+{
+    struct buf_tg_info *buf_tg_info;
+    int *cnt;
+
+    /* Wrapper handles don't have thread group info */
+    if (buf->size != -1)
+        return;
+
+    if (lock)
+        mutex_lock(&buf_tg_infos_mutex);
+
+    buf_tg_info = get_buf_tg_info(buf);
+    if (NULL == buf_tg_info)
+    {
+        LOG_USER_ERROR("%s: Usage count mismatch", __func__);
+        goto out;
+    }
+
+    switch (buf_counter)
+    {
+        case REGISTER_COUNTER:
+            cnt = &buf_tg_info->reg_cnt;
+            break;
+
+        case LOCK_COUNTER:
+            cnt = &buf_tg_info->lock_cnt;
+            break;
+
+        default:
+            LOG_ERROR("%s: Unknown buffer counter, %i", __func__, buf_counter);
+            goto out;
+    }
+
+    (*cnt)--;
+    if (*cnt < 0)
+    {
+        LOG_USER_ERROR("%s: Usage count mismatch", __func__);
+        *cnt = 0;
+    }
+
+    if (0 == buf_tg_info->reg_cnt && 0 == buf_tg_info->lock_cnt)
+    {
+        remove_buf_tg_info(buf);
+    }
+
+    goto out;
+
+out:
+    if (lock)
+        mutex_unlock(&buf_tg_infos_mutex);
+}
+
+static int dec_buf_reg_cnt_if_last_usr(struct hwmem_gralloc_buf_handle_t* buf)
+{
+    int ret = 1;
+    struct buf_tg_info *buf_tg_info;
+
+    /* Wrapper handles don't have thread group info */
+    if (buf->size != -1)
+        return 1;
+
+    mutex_lock(&buf_tg_infos_mutex);
+
+    buf_tg_info = get_buf_tg_info(buf);
+    if (NULL == buf_tg_info)
+    {
+        LOG_USER_ERROR("%s: Usage count mismatch", __func__);
+        goto out;
+    }
+
+    if (buf_tg_info->reg_cnt > 1 || buf_tg_info->lock_cnt != 0)
+    {
+        LOG_USER_ERROR("%s: Buffer is in use", __func__);
+        errno = ENOMSG;
+        goto buf_in_use;
+    }
+
+    dec_buf_cnt(buf, REGISTER_COUNTER, 0);
+
+    goto out;
+
+buf_in_use:
+    ret = 0;
+
+out:
+    mutex_unlock(&buf_tg_infos_mutex);
+
+    return ret;
+}
+
+/* buf_tg_infos_mutex must be held when calling this function */
+static int get_create_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf,
+    struct buf_tg_info **buf_tg_info)
+{
+    if (buf->size != -1)
+    {
+        LOG_ERROR("%s: Creating thread group info for wrapper handle", __func__);
+        return 0;
+    }
+
+    if (!ensure_buf_handl_2_tg_info_map_exists())
+        return 0;
+
+    *buf_tg_info = (struct buf_tg_info *)hashmapGet(
+        buf_handl_2_tg_info_map, buf);
+    if (*buf_tg_info != NULL)
+        return 1;
+
+    *buf_tg_info = (struct buf_tg_info *)malloc(sizeof(struct buf_tg_info));
+    memset(*buf_tg_info, 0, sizeof(**buf_tg_info));
+    (*buf_tg_info)->addr = NULL;
+
+    errno = 0;
+    if (NULL == hashmapPut(buf_handl_2_tg_info_map, buf, *buf_tg_info) && ENOMEM == errno)
+    {
+        LOG_ERROR("%s: NULL == hashmapPut(buf_handl_2_tg_info_map, buf, *buf_tg_info) && ENOMEM == errno", __func__);
+        goto hashmap_put_failed;
+    }
+
+    return 1;
+
+hashmap_put_failed:
+    free(*buf_tg_info);
+
+    return 0;
+}
+
+/* buf_tg_infos_mutex must be held when calling this function */
+static struct buf_tg_info *get_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf)
+{
+    if (!ensure_buf_handl_2_tg_info_map_exists())
+        return NULL;
+
+    return (struct buf_tg_info *)hashmapGet(buf_handl_2_tg_info_map, buf);
+}
+
+/* buf_tg_infos_mutex must be held when calling this function */
+static void remove_buf_tg_info(struct hwmem_gralloc_buf_handle_t* buf)
+{
+    struct buf_tg_info *buf_tg_info;
+
+    if (!ensure_buf_handl_2_tg_info_map_exists())
+        return;
+
+    munmap_buf_if_necessary(buf);
+    buf_tg_info = (struct buf_tg_info *)hashmapRemove(buf_handl_2_tg_info_map,
+        buf);
+    if (NULL == buf_tg_info)
+    {
+        LOG_ERROR("%s: Removing non existing thread group info", __func__);
+    }
+    free(buf_tg_info);
+}
+
+/* buf_tg_infos_mutex must be held when calling this function */
+static int ensure_buf_handl_2_tg_info_map_exists(void)
+{
+    if (buf_handl_2_tg_info_map != NULL)
+        return 1;
+
+    buf_handl_2_tg_info_map = hashmapCreate(10, ptr_2_int, are_ptrs_equal);
+    if (NULL == buf_handl_2_tg_info_map)
+    {
+        LOG_ERROR("%s: Failed to create hashmap, %s", __func__, strerror(errno));
+        return 0;
+    }
+
+    return 1;
+}
+
+static int ptr_2_int(void *ptr)
+{
+    return (int)ptr;
+}
+
+static bool are_ptrs_equal(void *ptr1, void *ptr2)
+{
+    return ptr1 == ptr2;
+}
diff --git a/display/libgralloc/hwmem_gralloc_framebuffer.c b/display/libgralloc/hwmem_gralloc_framebuffer.c
deleted file mode 100644
index d5c1d32..0000000
--- a/display/libgralloc/hwmem_gralloc_framebuffer.c
+++ /dev/null
@@ -1,683 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sys/mman.h>
-
-#include <dlfcn.h>
-
-#include <cutils/ashmem.h>
-#include <cutils/log.h>
-
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-#include <hardware/fb.h>
-#include "gralloc_stericsson_ext.h"
-
-#include <fcntl.h>
-#include <errno.h>
-#include <sys/ioctl.h>
-#include <string.h>
-#include <stdlib.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <system/graphics.h>
-#include <system/window.h>
-
-#if HAVE_ANDROID_OS
-#include <linux/fb.h>
-#endif
-
-#include <GLES/gl.h>
-
-#include "hwmem_gralloc.h"
-#include <linux/compdev.h>
-#define COMPDEV_PATH "/dev/comp0"
-
-enum {
-    PAGE_FLIP = 0x00000001,
-    LOCKED = 0x00000002
-};
-
-enum {
-    // flag to indicate we'll post this buffer
-    PRIV_USAGE_LOCKED_FOR_POST = 0x80000000
-};
-
-struct fb_context_t {
-    framebuffer_device_t  device;
-    int compdev;
-};
-
-/*****************************************************************************/
-
-static inline size_t roundUpToPageSize(size_t x) {
-    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
-}
-
-static void init_hwmem_gralloc_buf_handle(struct hwmem_gralloc_buf_handle_t* handle, int fd, int size, int flags)
-{
-    memset(handle, 0, sizeof(struct hwmem_gralloc_buf_handle_t));
-    handle->fd = fd;
-    handle->size = size;
-    handle->flags = flags;
-    handle->pid = getpid();
-    handle->type_identifier = hwmem_gralloc_buf_handle_type_identifier;
-    handle->type = GRALLOC_BUF_TYPE_FB;
-    handle->base.version = sizeof(native_handle_t);
-    handle->base.numInts = num_ints_in_hwmem_gralloc_buf_handle;
-    handle->base.numFds = num_fds_in_hwmem_gralloc_buf_handle;
-}
-
-static int fb_setSwapInterval(struct framebuffer_device_t* dev,
-            int interval)
-{
-    struct fb_context_t* ctx = (struct fb_context_t*)dev;
-    if (interval < dev->minSwapInterval || interval > dev->maxSwapInterval)
-        return -EINVAL;
-    // FIXME: implement fb_setSwapInterval
-    return 0;
-}
-
-static int fb_setUpdateRect(struct framebuffer_device_t* dev,
-        int l, int t, int w, int h)
-{
-    struct fb_context_t* ctx = (struct fb_context_t*)dev;
-    struct hwmem_gralloc_module_t* m = (struct hwmem_gralloc_module_t*)
-            dev->common.module;
-
-    if (((w|h) <= 0) || ((l|t)<0))
-        return -EINVAL;
-
-    m->info.reserved[0] = 0x54445055; // "UPDT";
-    m->info.reserved[1] = (uint16_t)l | ((uint32_t)t << 16);
-    m->info.reserved[2] = (uint16_t)(l+w) | ((uint32_t)(t+h) << 16);
-    return 0;
-}
-
-static unsigned int fb_rotate_to_compdev(__u32 fb_rotate)
-{
-    switch (fb_rotate) {
-    case FB_ROTATE_UR:
-        return COMPDEV_TRANSFORM_ROT_0;
-    case FB_ROTATE_CW:
-        return COMPDEV_TRANSFORM_ROT_90_CW;
-    case FB_ROTATE_UD:
-        return COMPDEV_TRANSFORM_ROT_180;
-    case FB_ROTATE_CCW:
-        return COMPDEV_TRANSFORM_ROT_90_CCW;
-    default:
-        ALOGE("%s: Illegal fb rotation supplied", __func__);
-        return 0;
-    }
-}
-
-static void send_to_compdev(struct fb_context_t* ctx, struct hwmem_gralloc_module_t* m)
-{
-    struct fb_fix_screeninfo *lcd_finfo = &m->finfo;
-    struct fb_var_screeninfo *lcd_vinfo = &m->info;
-    int i;
-    int ret;
-    struct compdev_img img;
-
-    memset(&img, 0, sizeof(img));
-
-    /* lcd_vinfo->yoffset contains the LCD actual visible buffer */
-    img.buf.offset = lcd_finfo->smem_start +
-            lcd_finfo->line_length * lcd_vinfo->yoffset;
-
-    /* Input */
-    switch (lcd_vinfo->bits_per_pixel) {
-    case 16:
-        img.fmt = COMPDEV_FMT_RGB565;
-        break;
-    case 24:
-        img.fmt = COMPDEV_FMT_RGB888;
-        break;
-    case 32:
-    default:
-        img.fmt = COMPDEV_FMT_RGBA8888;
-        break;
-    }
-    img.width = lcd_vinfo->xres;
-    img.height = lcd_vinfo->yres;
-    img.pitch = lcd_finfo->line_length;
-    img.buf.type = COMPDEV_PTR_PHYSICAL;
-    img.buf.len = lcd_finfo->line_length * lcd_vinfo->yres;
-    img.src_rect.x = 0;
-    img.src_rect.y = 0;
-    img.src_rect.width = lcd_vinfo->xres;
-    img.src_rect.height = lcd_vinfo->yres;
-
-    img.dst_rect.x = 0;
-    img.dst_rect.y = 0;
-    if (m->info.rotate == FB_ROTATE_CW ||
-        m->info.rotate == FB_ROTATE_CCW) {
-        img.dst_rect.width = lcd_vinfo->yres;
-        img.dst_rect.height = lcd_vinfo->xres;
-    } else {
-        img.dst_rect.width = lcd_vinfo->xres;
-        img.dst_rect.height = lcd_vinfo->yres;
-    }
-
-    img.z_position = 1; // HWC can decide to put a buffer either on top(0) or below(2).
-
-    img.flags = (uint32_t)COMPDEV_FRAMEBUFFER_FLAG;
-
-    img.transform = fb_rotate_to_compdev(m->info.rotate);
-
-    ret = ioctl(ctx->compdev, COMPDEV_POST_BUFFER_IOC,
-            (struct compdev_img*)&img);
-    if (ret < 0)
-        ALOGE("%s: Failed to post buffers to compdev, %s", __func__,
-                strerror(errno));
-
-}
-
-static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
-{
-    struct fb_context_t* ctx = (struct fb_context_t*)dev;
-
-    struct hwmem_gralloc_module_t* m;
-    struct hwmem_gralloc_buf_handle_t * hnd;
-
-    if (!module_2_hwmem_gralloc_module((struct gralloc_module_t const*)dev->common.module, &m) ||
-        !handle_2_hwmem_gralloc_handle(buffer, &hnd))
-        return -errno;
-
-    if (m->currentBuffer) {
-        m->base.unlock(&m->base, m->currentBuffer);
-        m->currentBuffer = 0;
-    }
-
-    if (hnd->flags & PRIV_FLAGS_FRAMEBUFFER) {
-        size_t offset;
-
-        m->base.lock(&m->base, buffer,
-                PRIV_USAGE_LOCKED_FOR_POST,
-                0, 0, m->info.xres, m->info.yres, NULL);
-
-        offset = hnd->base_addr - m->framebuffer->base_addr;
-        m->info.activate = FB_ACTIVATE_VBL;
-        m->info.yoffset = offset / m->finfo.line_length;
-
-        // Send the frame to compdev driver
-        send_to_compdev(ctx, m);
-        m->currentBuffer = buffer;
-    } else {
-        // If we can't do the page_flip, just copy the buffer to the front
-        // FIXME: use copybit HAL instead of memcpy
-
-        void* fb_vaddr;
-        void* buffer_vaddr;
-
-        m->base.lock(&m->base, (buffer_handle_t)m->framebuffer,
-                GRALLOC_USAGE_SW_WRITE_RARELY,
-                0, 0, m->info.xres, m->info.yres,
-                &fb_vaddr);
-
-        m->base.lock(&m->base, buffer,
-                GRALLOC_USAGE_SW_READ_RARELY,
-                0, 0, m->info.xres, m->info.yres,
-                &buffer_vaddr);
-
-        memcpy(fb_vaddr, buffer_vaddr, m->finfo.line_length * m->info.yres);
-
-        m->base.unlock(&m->base, buffer);
-        m->base.unlock(&m->base, (buffer_handle_t)m->framebuffer);
-    }
-
-    return 0;
-}
-
-int fb_compositionComplete()
-{
-    //Before we start updating applications buffers again i.e. setting up the next frame we need to
-    //make sure all buffers have been used by the compositor in *this* frame. This is done by
-    //flushing all outstanding draw calls. A flush will allways be done if a call to glReadPixels()
-    //is made whereas a call to glFinish() might be "optimized" out by the driver.
-    //
-    //This forced synchonous behaviour in the compositor should not affect applications ability to
-    //do asynchonous rendering.
-    unsigned char dummy_pixel[4];
-    glReadPixels(0,0,1,1, GL_RGBA, GL_UNSIGNED_BYTE, dummy_pixel);
-    return 0;
-}
-
-static int is_pitch_mcde_aligned(__u32 pitch)
-{
-    /* TODO: We should get the alignment from the driver instead of hard coding it. */
-    static const unsigned int mcde_pitch_alignment = 8;
-
-    return (pitch & (mcde_pitch_alignment - 1)) == 0;
-}
-
-static unsigned int fb_rotate_to_degree(__u32 fb_rotate)
-{
-    switch (fb_rotate) {
-    case FB_ROTATE_UR:
-        return 0;
-    case FB_ROTATE_CW:
-        return 90;
-    case FB_ROTATE_UD:
-        return 180;
-    case FB_ROTATE_CCW:
-        return 270;
-    default:
-        ALOGE("%s: Illegal fb rotation supplied", __func__);
-        return 0;
-    }
-}
-
-static __u32 degree_to_fb_rotate(unsigned int degree)
-{
-    degree = degree % 360;
-
-    switch (degree) {
-    case 0:
-        return FB_ROTATE_UR;
-    case 270:
-        return FB_ROTATE_CCW;
-    case 180:
-        return FB_ROTATE_UD;
-    case 90:
-        return FB_ROTATE_CW;
-    default:
-        ALOGE("%s: Illegal degree supplied", __func__);
-        return FB_ROTATE_UR;
-    }
-}
-
-static void switch_uint(unsigned int* uint1, unsigned int* uint2)
-{
-    unsigned int tmp = *uint1;
-    *uint1 = *uint2;
-    *uint2 = tmp;
-}
-
-static void switch_float(float* float1, float* float2)
-{
-    float tmp = *float1;
-    *float1 = *float2;
-    *float2 = tmp;
-}
-
-static int fb_rotate(struct framebuffer_device_t* dev, unsigned int absolute_degree)
-{
-    struct hwmem_gralloc_module_t* module;
-    __u32 old_rotation_degree;
-    int switch_width_height;
-
-    if (dev == NULL || absolute_degree % 90 != 0)
-        return -EINVAL;
-
-    if (!module_2_hwmem_gralloc_module((struct gralloc_module_t const*)dev->common.module, &module))
-        return -errno;
-
-    if (!is_pitch_mcde_aligned((module->info.xres * module->info.bits_per_pixel) / 8) ||
-        !is_pitch_mcde_aligned((module->info.yres * module->info.bits_per_pixel) / 8))
-    {
-        /* Rotation might cause fb re-alloc which we can't handle. */
-        ALOGW("Unable to rotate in hardware due to unaligned framebuffer width and/or height");
-        return -ENOMSG;
-    }
-
-    old_rotation_degree = fb_rotate_to_degree(module->info.rotate);
-    module->info.rotate = degree_to_fb_rotate(absolute_degree);
-
-    switch_width_height = old_rotation_degree % 180 != absolute_degree % 180;
-    if (switch_width_height) {
-        int num_bufs = module->info.yres_virtual / module->info.yres;
-        switch_uint(&module->info.xres, &module->info.yres);
-        module->info.xres_virtual = module->info.xres;
-        module->info.yres_virtual = module->info.yres * num_bufs;
-        module->finfo.line_length = (module->info.xres * module->info.bits_per_pixel) / 8;
-
-        /*
-         * This isn't thread safe and can't be made thread safe without changing
-         * the API. As far as I can see they are currently only used by one thread
-         * at a time so not a problem right now.
-         */
-        /*
-         * TODO: Change api and make thread safe so that we don't run into nasty
-         * problems in the future.
-         */
-        switch_uint(&dev->width, &dev->height);
-        switch_float(&dev->xdpi, &dev->ydpi);
-        switch_float(&module->xdpi, &module->ydpi);
-        dev->stride = module->info.xres;
-    }
-
-    return 0;
-}
-
-/*****************************************************************************/
-
-static int mapFrameBufferLocked(struct hwmem_gralloc_module_t* module)
-{
-    char const * const device_template[] = {
-            "/dev/graphics/fb%u",
-            "/dev/fb%u",
-            0 };
-
-    int fd = -1;
-    int i=0;
-    char name[64];
-    struct fb_fix_screeninfo finfo;
-    struct fb_var_screeninfo info;
-    uint32_t flags;
-    float xdpi;
-    float ydpi;
-    float fps;
-
-    // already initialized...
-    if (module->framebuffer) {
-        return 0;
-    }
-
-    while ((fd==-1) && device_template[i]) {
-        snprintf(name, 64, device_template[i], 0);
-        fd = open(name, O_RDWR, 0);
-        i++;
-    }
-    if (fd < 0)
-        return -errno;
-
-    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
-        return -errno;
-
-    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
-        return -errno;
-
-    info.reserved[0] = 0;
-    info.reserved[1] = 0;
-    info.reserved[2] = 0;
-    info.xoffset = 0;
-    info.yoffset = 0;
-    info.activate = FB_ACTIVATE_NOW;
-
-    flags = PAGE_FLIP;
-
-    if (info.yres_virtual < info.yres * 2) {
-        // we need at least 2 for page-flipping
-        info.yres_virtual = info.yres;
-        flags &= ~PAGE_FLIP;
-        ALOGW("page flipping not supported (yres_virtual=%d, requested=%d)",
-                info.yres_virtual, info.yres*2);
-    }
-
-    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
-        return -errno;
-
-    uint64_t divisor = (info.upper_margin + info.lower_margin + info.yres)
-            * (info.left_margin  + info.right_margin + info.xres)
-            * info.pixclock;
-
-    int refreshRate = 0;
-    if (divisor)
-        refreshRate = (int)(1000000000000000LLU / divisor);
-
-    if (refreshRate == 0) {
-        // bleagh, bad info from the driver
-        refreshRate = 60*1000;  // 60 Hz
-    }
-
-    if ((int)info.width <= 0 || (int)info.height <= 0) {
-        // the driver doesn't return that information
-        // default to 160 dpi
-        info.width  = ((info.xres * 25.4f)/160.0f + 0.5f);
-        info.height = ((info.yres * 25.4f)/160.0f + 0.5f);
-    }
-
-    xdpi = (info.xres * 25.4f) / info.width;
-    ydpi = (info.yres * 25.4f) / info.height;
-    fps  = refreshRate / 1000.0f;
-
-    ALOGI(   "using (fd=%d)\n"
-            "id           = %s\n"
-            "xres         = %d px\n"
-            "yres         = %d px\n"
-            "xres_virtual = %d px\n"
-            "yres_virtual = %d px\n"
-            "bpp          = %d\n"
-            "r            = %2u:%u\n"
-            "g            = %2u:%u\n"
-            "b            = %2u:%u\n",
-            fd,
-            finfo.id,
-            info.xres,
-            info.yres,
-            info.xres_virtual,
-            info.yres_virtual,
-            info.bits_per_pixel,
-            info.red.offset, info.red.length,
-            info.green.offset, info.green.length,
-            info.blue.offset, info.blue.length
-    );
-
-    ALOGI(   "width        = %d mm (%f dpi)\n"
-            "height       = %d mm (%f dpi)\n"
-            "refresh rate = %.2f Hz\n",
-            info.width,  xdpi,
-            info.height, ydpi,
-            fps
-    );
-
-
-    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
-        return -errno;
-
-    if (finfo.smem_len <= 0)
-        return -errno;
-
-    module->flags = flags;
-    module->info = info;
-    module->finfo = finfo;
-    module->xdpi = xdpi;
-    module->ydpi = ydpi;
-    module->fps = fps;
-
-    /*
-     * map the framebuffer
-     */
-    {
-        int err;
-        void* vaddr;
-        size_t fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
-        module->framebuffer = malloc(sizeof(struct hwmem_gralloc_buf_handle_t));
-        init_hwmem_gralloc_buf_handle(module->framebuffer, dup(fd), fbSize, PRIV_FLAGS_USES_PMEM);
-
-        module->numBuffers = info.yres_virtual / info.yres;
-        module->bufferMask = 0;
-        module->currentBufferIndex = -1;
-
-        vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
-        if (vaddr == MAP_FAILED) {
-            ALOGE("Error mapping the framebuffer (%s)", strerror(errno));
-            return -errno;
-        }
-        module->framebuffer->base_addr = (int)vaddr;
-        memset(vaddr, 0, fbSize);
-    }
-    return 0;
-}
-
-static int mapFrameBuffer(struct hwmem_gralloc_module_t* module)
-{
-    int err;
-    pthread_mutex_lock(&module->lock);
-    err = mapFrameBufferLocked(module);
-    pthread_mutex_unlock(&module->lock);
-    return err;
-}
-
-/*****************************************************************************/
-
-static int fb_close(struct hw_device_t *dev)
-{
-    struct fb_context_t* ctx = (struct fb_context_t*)dev;
-    if (ctx) {
-        close(ctx->compdev);
-        free(ctx);
-    }
-    return 0;
-}
-
-int fb_device_open(hw_module_t const* module, const char* name,
-        hw_device_t** device)
-{
-    int status = -EINVAL;
-    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) {
-        alloc_device_t* gralloc_device;
-        struct fb_context_t *dev;
-        struct hwmem_gralloc_module_t* m;
-
-        status = gralloc_open(module, &gralloc_device);
-        if (status < 0)
-            return status;
-
-        /* initialize our state here */
-        dev = (struct fb_context_t*)malloc(sizeof(*dev));
-        memset(dev, 0, sizeof(*dev));
-
-        /* initialize the procs */
-        dev->device.common.tag = HARDWARE_DEVICE_TAG;
-        dev->device.common.version = 0;
-        dev->device.common.module = (hw_module_t*)module;
-        dev->device.common.close = fb_close;
-        dev->device.setSwapInterval = fb_setSwapInterval;
-        dev->device.post            = fb_post;
-        dev->device.setUpdateRect = 0;
-        dev->device.compositionComplete = fb_compositionComplete;
-        dev->device.rotate          = fb_rotate;
-
-        m = (struct hwmem_gralloc_module_t*)module;
-        status = mapFrameBuffer(m);
-        if (status >= 0) {
-            int stride = m->finfo.line_length / (m->info.bits_per_pixel >> 3);
-            *((uint32_t*)&dev->device.flags) = 0;
-            if (m->info.bits_per_pixel == 16) {
-                *((int*)&dev->device.format) = HAL_PIXEL_FORMAT_RGB_565;
-            } else if (m->info.bits_per_pixel == 32) {
-                *((int*)&dev->device.format) = HAL_PIXEL_FORMAT_BGRA_8888;
-            } else {
-                ALOGE("fb_device_open: Unsupported format");
-                *((int*)&dev->device.format) = HAL_PIXEL_FORMAT_RGB_565;
-            }
-            dev->device.width = m->info.xres;
-            dev->device.height = m->info.yres;
-            dev->device.stride = stride;
-            dev->device.xdpi = m->xdpi;
-            dev->device.ydpi = m->ydpi;
-            *((float*)&dev->device.fps) = m->fps;
-            *((int*)&dev->device.minSwapInterval) = 1;
-            *((int*)&dev->device.maxSwapInterval) = 1;
-            *device = &dev->device.common;
-
-            struct fb_context_t* ctx = (struct fb_context_t*)dev;
-            /* Open the compdev */
-            ctx->compdev = open(COMPDEV_PATH, O_RDWR, 0);
-            if (ctx->compdev < 0) {
-                ALOGE("%s: Error Opening "COMPDEV_PATH": %s\n",__func__,
-                        strerror(errno));
-            }
-
-        } else {
-            free(dev);
-        }
-    }
-
-    return status;
-}
-
-static int gralloc_alloc_framebuffer_locked(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle, int *stride,
-        int* handled)
-{
-    struct hwmem_gralloc_module_t* m = (struct hwmem_gralloc_module_t*)
-            dev->common.module;
-    uint32_t bufferMask;
-    uint32_t numBuffers;
-    size_t bufferSize;
-    int vaddr;
-    uint32_t i;
-    struct hwmem_gralloc_buf_handle_t* hnd;
-
-    *handled = 1;
-
-    // allocate the framebuffer
-    if (m->framebuffer == NULL) {
-        // initialize the framebuffer, the framebuffer is mapped once
-        // and forever.
-        int err = mapFrameBufferLocked(m);
-        if (err < 0)
-            return err;
-    }
-
-    bufferMask = m->bufferMask;
-    numBuffers = m->numBuffers;
-    bufferSize = m->finfo.line_length * m->info.yres;
-    if (numBuffers == 1) {
-        // If we have only one buffer, we never use page-flipping. Instead,
-        // we return a regular buffer which will be memcpy'ed to the main
-        // screen when post is called.
-        *handled = 0;
-        return 0;
-    }
-
-    if (bufferMask >= ((1LU<<numBuffers)-1)) {
-        // We ran out of buffers.
-        return -ENOMEM;
-    }
-
-    // create a "fake" handles for it
-    vaddr = m->framebuffer->base_addr;
-    hnd = malloc(sizeof(struct hwmem_gralloc_buf_handle_t));
-    init_hwmem_gralloc_buf_handle(hnd, dup(m->framebuffer->fd), size, PRIV_FLAGS_USES_PMEM | PRIV_FLAGS_FRAMEBUFFER);
-
-    // find a free slot
-    for (i = 0 ; i < numBuffers ; i++) {
-        m->currentBufferIndex = (m->currentBufferIndex + 1) % numBuffers;
-        if ((bufferMask & (1LU<<m->currentBufferIndex)) == 0) {
-            m->bufferMask |= (1LU<<m->currentBufferIndex);
-            break;
-        }
-    }
-    vaddr += bufferSize * m->currentBufferIndex;
-
-    hnd->base_addr = vaddr;
-    hnd->offset = vaddr - m->framebuffer->base_addr;
-    *pHandle = (buffer_handle_t)hnd;
-    *stride = (m->finfo.line_length * 8) / m->info.bits_per_pixel;
-
-    return 0;
-}
-
-int gralloc_alloc_framebuffer(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle, int *stride,
-        int* handled)
-{
-    struct hwmem_gralloc_module_t* m = (struct hwmem_gralloc_module_t*)
-            dev->common.module;
-    int err;
-    *handled = 1;
-    pthread_mutex_lock(&m->lock);
-    err = gralloc_alloc_framebuffer_locked(dev, size, usage, pHandle, stride,
-                handled);
-    pthread_mutex_unlock(&m->lock);
-    return err;
-}
diff --git a/display/libgralloc/hwmem_gralloc_framebuffer.cpp b/display/libgralloc/hwmem_gralloc_framebuffer.cpp
new file mode 100644
index 0000000..4ee364f
--- /dev/null
+++ b/display/libgralloc/hwmem_gralloc_framebuffer.cpp
@@ -0,0 +1,683 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <sys/mman.h>
+
+#include <dlfcn.h>
+
+#include <cutils/ashmem.h>
+#include <cutils/log.h>
+
+#include <hardware/hardware.h>
+#include <hardware/gralloc.h>
+#include <hardware/fb.h>
+#include "gralloc_stericsson_ext.h"
+
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <system/graphics.h>
+#include <system/window.h>
+
+#if HAVE_ANDROID_OS
+#include <linux/fb.h>
+#endif
+
+#include <GLES/gl.h>
+
+#include "hwmem_gralloc.h"
+#include <linux/compdev.h>
+#define COMPDEV_PATH "/dev/comp0"
+
+enum {
+    PAGE_FLIP = 0x00000001,
+    LOCKED = 0x00000002
+};
+
+enum {
+    // flag to indicate we'll post this buffer
+    PRIV_USAGE_LOCKED_FOR_POST = 0x80000000
+};
+
+struct fb_context_t {
+    framebuffer_device_t  device;
+    int compdev;
+};
+
+/*****************************************************************************/
+
+static inline size_t roundUpToPageSize(size_t x) {
+    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
+}
+
+static void init_hwmem_gralloc_buf_handle(struct hwmem_gralloc_buf_handle_t* handle, int fd, int size, int flags)
+{
+    memset(handle, 0, sizeof(struct hwmem_gralloc_buf_handle_t));
+    handle->fd = fd;
+    handle->size = size;
+    handle->flags = flags;
+    handle->pid = getpid();
+    handle->type_identifier = hwmem_gralloc_buf_handle_type_identifier;
+    handle->type = GRALLOC_BUF_TYPE_FB;
+    handle->base.version = sizeof(native_handle_t);
+    handle->base.numInts = num_ints_in_hwmem_gralloc_buf_handle;
+    handle->base.numFds = num_fds_in_hwmem_gralloc_buf_handle;
+}
+
+static int fb_setSwapInterval(struct framebuffer_device_t* dev,
+            int interval)
+{
+    struct fb_context_t* ctx = (struct fb_context_t*)dev;
+    if (interval < dev->minSwapInterval || interval > dev->maxSwapInterval)
+        return -EINVAL;
+    // FIXME: implement fb_setSwapInterval
+    return 0;
+}
+
+static int fb_setUpdateRect(struct framebuffer_device_t* dev,
+        int l, int t, int w, int h)
+{
+    struct fb_context_t* ctx = (struct fb_context_t*)dev;
+    struct hwmem_gralloc_module_t* m = (struct hwmem_gralloc_module_t*)
+            dev->common.module;
+
+    if (((w|h) <= 0) || ((l|t)<0))
+        return -EINVAL;
+
+    m->info.reserved[0] = 0x54445055; // "UPDT";
+    m->info.reserved[1] = (uint16_t)l | ((uint32_t)t << 16);
+    m->info.reserved[2] = (uint16_t)(l+w) | ((uint32_t)(t+h) << 16);
+    return 0;
+}
+
+static unsigned int fb_rotate_to_compdev(__u32 fb_rotate)
+{
+    switch (fb_rotate) {
+    case FB_ROTATE_UR:
+        return COMPDEV_TRANSFORM_ROT_0;
+    case FB_ROTATE_CW:
+        return COMPDEV_TRANSFORM_ROT_90_CW;
+    case FB_ROTATE_UD:
+        return COMPDEV_TRANSFORM_ROT_180;
+    case FB_ROTATE_CCW:
+        return COMPDEV_TRANSFORM_ROT_90_CCW;
+    default:
+        ALOGE("%s: Illegal fb rotation supplied", __func__);
+        return 0;
+    }
+}
+
+static void send_to_compdev(struct fb_context_t* ctx, struct hwmem_gralloc_module_t* m)
+{
+    struct fb_fix_screeninfo *lcd_finfo = &m->finfo;
+    struct fb_var_screeninfo *lcd_vinfo = &m->info;
+    int i;
+    int ret;
+    struct compdev_img img;
+
+    memset(&img, 0, sizeof(img));
+
+    /* lcd_vinfo->yoffset contains the LCD actual visible buffer */
+    img.buf.offset = lcd_finfo->smem_start +
+            lcd_finfo->line_length * lcd_vinfo->yoffset;
+
+    /* Input */
+    switch (lcd_vinfo->bits_per_pixel) {
+    case 16:
+        img.fmt = COMPDEV_FMT_RGB565;
+        break;
+    case 24:
+        img.fmt = COMPDEV_FMT_RGB888;
+        break;
+    case 32:
+    default:
+        img.fmt = COMPDEV_FMT_RGBA8888;
+        break;
+    }
+    img.width = lcd_vinfo->xres;
+    img.height = lcd_vinfo->yres;
+    img.pitch = lcd_finfo->line_length;
+    img.buf.type = COMPDEV_PTR_PHYSICAL;
+    img.buf.len = lcd_finfo->line_length * lcd_vinfo->yres;
+    img.src_rect.x = 0;
+    img.src_rect.y = 0;
+    img.src_rect.width = lcd_vinfo->xres;
+    img.src_rect.height = lcd_vinfo->yres;
+
+    img.dst_rect.x = 0;
+    img.dst_rect.y = 0;
+    if (m->info.rotate == FB_ROTATE_CW ||
+        m->info.rotate == FB_ROTATE_CCW) {
+        img.dst_rect.width = lcd_vinfo->yres;
+        img.dst_rect.height = lcd_vinfo->xres;
+    } else {
+        img.dst_rect.width = lcd_vinfo->xres;
+        img.dst_rect.height = lcd_vinfo->yres;
+    }
+
+    img.z_position = 1; // HWC can decide to put a buffer either on top(0) or below(2).
+
+    img.flags = (uint32_t)COMPDEV_FRAMEBUFFER_FLAG;
+
+    img.transform = (enum compdev_transform)fb_rotate_to_compdev(m->info.rotate);
+
+    ret = ioctl(ctx->compdev, COMPDEV_POST_BUFFER_IOC,
+            (struct compdev_img*)&img);
+    if (ret < 0)
+        ALOGE("%s: Failed to post buffers to compdev, %s", __func__,
+                strerror(errno));
+
+}
+
+static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
+{
+    struct fb_context_t* ctx = (struct fb_context_t*)dev;
+
+    struct hwmem_gralloc_module_t* m;
+    struct hwmem_gralloc_buf_handle_t * hnd;
+
+    if (!module_2_hwmem_gralloc_module((struct gralloc_module_t const*)dev->common.module, &m) ||
+        !handle_2_hwmem_gralloc_handle(buffer, &hnd))
+        return -errno;
+
+    if (m->currentBuffer) {
+        m->base.unlock(&m->base, m->currentBuffer);
+        m->currentBuffer = 0;
+    }
+
+    if (hnd->flags & PRIV_FLAGS_FRAMEBUFFER) {
+        size_t offset;
+
+        m->base.lock(&m->base, buffer,
+                PRIV_USAGE_LOCKED_FOR_POST,
+                0, 0, m->info.xres, m->info.yres, NULL);
+
+        offset = hnd->base_addr - m->framebuffer->base_addr;
+        m->info.activate = FB_ACTIVATE_VBL;
+        m->info.yoffset = offset / m->finfo.line_length;
+
+        // Send the frame to compdev driver
+        send_to_compdev(ctx, m);
+        m->currentBuffer = buffer;
+    } else {
+        // If we can't do the page_flip, just copy the buffer to the front
+        // FIXME: use copybit HAL instead of memcpy
+
+        void* fb_vaddr;
+        void* buffer_vaddr;
+
+        m->base.lock(&m->base, (buffer_handle_t)m->framebuffer,
+                GRALLOC_USAGE_SW_WRITE_RARELY,
+                0, 0, m->info.xres, m->info.yres,
+                &fb_vaddr);
+
+        m->base.lock(&m->base, buffer,
+                GRALLOC_USAGE_SW_READ_RARELY,
+                0, 0, m->info.xres, m->info.yres,
+                &buffer_vaddr);
+
+        memcpy(fb_vaddr, buffer_vaddr, m->finfo.line_length * m->info.yres);
+
+        m->base.unlock(&m->base, buffer);
+        m->base.unlock(&m->base, (buffer_handle_t)m->framebuffer);
+    }
+
+    return 0;
+}
+
+int fb_compositionComplete()
+{
+    //Before we start updating applications buffers again i.e. setting up the next frame we need to
+    //make sure all buffers have been used by the compositor in *this* frame. This is done by
+    //flushing all outstanding draw calls. A flush will allways be done if a call to glReadPixels()
+    //is made whereas a call to glFinish() might be "optimized" out by the driver.
+    //
+    //This forced synchonous behaviour in the compositor should not affect applications ability to
+    //do asynchonous rendering.
+    unsigned char dummy_pixel[4];
+    glReadPixels(0,0,1,1, GL_RGBA, GL_UNSIGNED_BYTE, dummy_pixel);
+    return 0;
+}
+
+static int is_pitch_mcde_aligned(__u32 pitch)
+{
+    /* TODO: We should get the alignment from the driver instead of hard coding it. */
+    static const unsigned int mcde_pitch_alignment = 8;
+
+    return (pitch & (mcde_pitch_alignment - 1)) == 0;
+}
+
+static unsigned int fb_rotate_to_degree(__u32 fb_rotate)
+{
+    switch (fb_rotate) {
+    case FB_ROTATE_UR:
+        return 0;
+    case FB_ROTATE_CW:
+        return 90;
+    case FB_ROTATE_UD:
+        return 180;
+    case FB_ROTATE_CCW:
+        return 270;
+    default:
+        ALOGE("%s: Illegal fb rotation supplied", __func__);
+        return 0;
+    }
+}
+
+static __u32 degree_to_fb_rotate(unsigned int degree)
+{
+    degree = degree % 360;
+
+    switch (degree) {
+    case 0:
+        return FB_ROTATE_UR;
+    case 270:
+        return FB_ROTATE_CCW;
+    case 180:
+        return FB_ROTATE_UD;
+    case 90:
+        return FB_ROTATE_CW;
+    default:
+        ALOGE("%s: Illegal degree supplied", __func__);
+        return FB_ROTATE_UR;
+    }
+}
+
+static void switch_uint(unsigned int* uint1, unsigned int* uint2)
+{
+    unsigned int tmp = *uint1;
+    *uint1 = *uint2;
+    *uint2 = tmp;
+}
+
+static void switch_float(float* float1, float* float2)
+{
+    float tmp = *float1;
+    *float1 = *float2;
+    *float2 = tmp;
+}
+
+static int fb_rotate(struct framebuffer_device_t* dev, unsigned int absolute_degree)
+{
+    struct hwmem_gralloc_module_t* module;
+    __u32 old_rotation_degree;
+    int switch_width_height;
+
+    if (dev == NULL || absolute_degree % 90 != 0)
+        return -EINVAL;
+
+    if (!module_2_hwmem_gralloc_module((struct gralloc_module_t const*)dev->common.module, &module))
+        return -errno;
+
+    if (!is_pitch_mcde_aligned((module->info.xres * module->info.bits_per_pixel) / 8) ||
+        !is_pitch_mcde_aligned((module->info.yres * module->info.bits_per_pixel) / 8))
+    {
+        /* Rotation might cause fb re-alloc which we can't handle. */
+        ALOGW("Unable to rotate in hardware due to unaligned framebuffer width and/or height");
+        return -ENOMSG;
+    }
+
+    old_rotation_degree = fb_rotate_to_degree(module->info.rotate);
+    module->info.rotate = degree_to_fb_rotate(absolute_degree);
+
+    switch_width_height = old_rotation_degree % 180 != absolute_degree % 180;
+    if (switch_width_height) {
+        int num_bufs = module->info.yres_virtual / module->info.yres;
+        switch_uint(&module->info.xres, &module->info.yres);
+        module->info.xres_virtual = module->info.xres;
+        module->info.yres_virtual = module->info.yres * num_bufs;
+        module->finfo.line_length = (module->info.xres * module->info.bits_per_pixel) / 8;
+
+        /*
+         * This isn't thread safe and can't be made thread safe without changing
+         * the API. As far as I can see they are currently only used by one thread
+         * at a time so not a problem right now.
+         */
+        /*
+         * TODO: Change api and make thread safe so that we don't run into nasty
+         * problems in the future.
+         */
+        switch_uint(&dev->width, &dev->height);
+        switch_float(&dev->xdpi, &dev->ydpi);
+        switch_float(&module->xdpi, &module->ydpi);
+        dev->stride = module->info.xres;
+    }
+
+    return 0;
+}
+
+/*****************************************************************************/
+
+static int mapFrameBufferLocked(struct hwmem_gralloc_module_t* module)
+{
+    char const * const device_template[] = {
+            "/dev/graphics/fb%u",
+            "/dev/fb%u",
+            0 };
+
+    int fd = -1;
+    int i=0;
+    char name[64];
+    struct fb_fix_screeninfo finfo;
+    struct fb_var_screeninfo info;
+    uint32_t flags;
+    float xdpi;
+    float ydpi;
+    float fps;
+
+    // already initialized...
+    if (module->framebuffer) {
+        return 0;
+    }
+
+    while ((fd==-1) && device_template[i]) {
+        snprintf(name, 64, device_template[i], 0);
+        fd = open(name, O_RDWR, 0);
+        i++;
+    }
+    if (fd < 0)
+        return -errno;
+
+    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
+        return -errno;
+
+    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
+        return -errno;
+
+    info.reserved[0] = 0;
+    info.reserved[1] = 0;
+    info.reserved[2] = 0;
+    info.xoffset = 0;
+    info.yoffset = 0;
+    info.activate = FB_ACTIVATE_NOW;
+
+    flags = PAGE_FLIP;
+
+    if (info.yres_virtual < info.yres * 2) {
+        // we need at least 2 for page-flipping
+        info.yres_virtual = info.yres;
+        flags &= ~PAGE_FLIP;
+        ALOGW("page flipping not supported (yres_virtual=%d, requested=%d)",
+                info.yres_virtual, info.yres*2);
+    }
+
+    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
+        return -errno;
+
+    uint64_t divisor = (info.upper_margin + info.lower_margin + info.yres)
+            * (info.left_margin  + info.right_margin + info.xres)
+            * info.pixclock;
+
+    int refreshRate = 0;
+    if (divisor)
+        refreshRate = (int)(1000000000000000LLU / divisor);
+
+    if (refreshRate == 0) {
+        // bleagh, bad info from the driver
+        refreshRate = 60*1000;  // 60 Hz
+    }
+
+    if ((int)info.width <= 0 || (int)info.height <= 0) {
+        // the driver doesn't return that information
+        // default to 160 dpi
+        info.width  = ((info.xres * 25.4f)/160.0f + 0.5f);
+        info.height = ((info.yres * 25.4f)/160.0f + 0.5f);
+    }
+
+    xdpi = (info.xres * 25.4f) / info.width;
+    ydpi = (info.yres * 25.4f) / info.height;
+    fps  = refreshRate / 1000.0f;
+
+    ALOGI(   "using (fd=%d)\n"
+            "id           = %s\n"
+            "xres         = %d px\n"
+            "yres         = %d px\n"
+            "xres_virtual = %d px\n"
+            "yres_virtual = %d px\n"
+            "bpp          = %d\n"
+            "r            = %2u:%u\n"
+            "g            = %2u:%u\n"
+            "b            = %2u:%u\n",
+            fd,
+            finfo.id,
+            info.xres,
+            info.yres,
+            info.xres_virtual,
+            info.yres_virtual,
+            info.bits_per_pixel,
+            info.red.offset, info.red.length,
+            info.green.offset, info.green.length,
+            info.blue.offset, info.blue.length
+    );
+
+    ALOGI(   "width        = %d mm (%f dpi)\n"
+            "height       = %d mm (%f dpi)\n"
+            "refresh rate = %.2f Hz\n",
+            info.width,  xdpi,
+            info.height, ydpi,
+            fps
+    );
+
+
+    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
+        return -errno;
+
+    if (finfo.smem_len <= 0)
+        return -errno;
+
+    module->flags = flags;
+    module->info = info;
+    module->finfo = finfo;
+    module->xdpi = xdpi;
+    module->ydpi = ydpi;
+    module->fps = fps;
+
+    /*
+     * map the framebuffer
+     */
+    {
+        int err;
+        void* vaddr;
+        size_t fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
+        module->framebuffer = (struct hwmem_gralloc_buf_handle_t *)malloc(sizeof(struct hwmem_gralloc_buf_handle_t));
+        init_hwmem_gralloc_buf_handle(module->framebuffer, dup(fd), fbSize, PRIV_FLAGS_USES_PMEM);
+
+        module->numBuffers = info.yres_virtual / info.yres;
+        module->bufferMask = 0;
+        module->currentBufferIndex = -1;
+
+        vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+        if (vaddr == MAP_FAILED) {
+            ALOGE("Error mapping the framebuffer (%s)", strerror(errno));
+            return -errno;
+        }
+        module->framebuffer->base_addr = (int)vaddr;
+        memset(vaddr, 0, fbSize);
+    }
+    return 0;
+}
+
+static int mapFrameBuffer(struct hwmem_gralloc_module_t* module)
+{
+    int err;
+    pthread_mutex_lock(&module->lock);
+    err = mapFrameBufferLocked(module);
+    pthread_mutex_unlock(&module->lock);
+    return err;
+}
+
+/*****************************************************************************/
+
+static int fb_close(struct hw_device_t *dev)
+{
+    struct fb_context_t* ctx = (struct fb_context_t*)dev;
+    if (ctx) {
+        close(ctx->compdev);
+        free(ctx);
+    }
+    return 0;
+}
+
+int fb_device_open(hw_module_t const* module, const char* name,
+        hw_device_t** device)
+{
+    int status = -EINVAL;
+    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) {
+        alloc_device_t* gralloc_device;
+        struct fb_context_t *dev;
+        struct hwmem_gralloc_module_t* m;
+
+        status = gralloc_open(module, &gralloc_device);
+        if (status < 0)
+            return status;
+
+        /* initialize our state here */
+        dev = (struct fb_context_t*)malloc(sizeof(*dev));
+        memset(dev, 0, sizeof(*dev));
+
+        /* initialize the procs */
+        dev->device.common.tag = HARDWARE_DEVICE_TAG;
+        dev->device.common.version = 0;
+        dev->device.common.module = (hw_module_t*)module;
+        dev->device.common.close = fb_close;
+        dev->device.setSwapInterval = fb_setSwapInterval;
+        dev->device.post            = fb_post;
+        dev->device.setUpdateRect = 0;
+        dev->device.compositionComplete = (int (*)(struct framebuffer_device_t *))fb_compositionComplete;
+        dev->device.rotate          = fb_rotate;
+
+        m = (struct hwmem_gralloc_module_t*)module;
+        status = mapFrameBuffer(m);
+        if (status >= 0) {
+            int stride = m->finfo.line_length / (m->info.bits_per_pixel >> 3);
+            *((uint32_t*)&dev->device.flags) = 0;
+            if (m->info.bits_per_pixel == 16) {
+                *((int*)&dev->device.format) = HAL_PIXEL_FORMAT_RGB_565;
+            } else if (m->info.bits_per_pixel == 32) {
+                *((int*)&dev->device.format) = HAL_PIXEL_FORMAT_BGRA_8888;
+            } else {
+                ALOGE("fb_device_open: Unsupported format");
+                *((int*)&dev->device.format) = HAL_PIXEL_FORMAT_RGB_565;
+            }
+            dev->device.width = m->info.xres;
+            dev->device.height = m->info.yres;
+            dev->device.stride = stride;
+            dev->device.xdpi = m->xdpi;
+            dev->device.ydpi = m->ydpi;
+            *((float*)&dev->device.fps) = m->fps;
+            *((int*)&dev->device.minSwapInterval) = 1;
+            *((int*)&dev->device.maxSwapInterval) = 1;
+            *device = &dev->device.common;
+
+            struct fb_context_t* ctx = (struct fb_context_t*)dev;
+            /* Open the compdev */
+            ctx->compdev = open(COMPDEV_PATH, O_RDWR, 0);
+            if (ctx->compdev < 0) {
+                ALOGE("%s: Error Opening %s: %s\n",__func__, COMPDEV_PATH,
+                        strerror(errno));
+            }
+
+        } else {
+            free(dev);
+        }
+    }
+
+    return status;
+}
+
+static int gralloc_alloc_framebuffer_locked(alloc_device_t* dev,
+        size_t size, int usage, buffer_handle_t* pHandle, int *stride,
+        int* handled)
+{
+    struct hwmem_gralloc_module_t* m = (struct hwmem_gralloc_module_t*)
+            dev->common.module;
+    uint32_t bufferMask;
+    uint32_t numBuffers;
+    size_t bufferSize;
+    int vaddr;
+    uint32_t i;
+    struct hwmem_gralloc_buf_handle_t* hnd;
+
+    *handled = 1;
+
+    // allocate the framebuffer
+    if (m->framebuffer == NULL) {
+        // initialize the framebuffer, the framebuffer is mapped once
+        // and forever.
+        int err = mapFrameBufferLocked(m);
+        if (err < 0)
+            return err;
+    }
+
+    bufferMask = m->bufferMask;
+    numBuffers = m->numBuffers;
+    bufferSize = m->finfo.line_length * m->info.yres;
+    if (numBuffers == 1) {
+        // If we have only one buffer, we never use page-flipping. Instead,
+        // we return a regular buffer which will be memcpy'ed to the main
+        // screen when post is called.
+        *handled = 0;
+        return 0;
+    }
+
+    if (bufferMask >= ((1LU<<numBuffers)-1)) {
+        // We ran out of buffers.
+        return -ENOMEM;
+    }
+
+    // create a "fake" handles for it
+    vaddr = m->framebuffer->base_addr;
+    hnd = (struct hwmem_gralloc_buf_handle_t *)malloc(sizeof(struct hwmem_gralloc_buf_handle_t));
+    init_hwmem_gralloc_buf_handle(hnd, dup(m->framebuffer->fd), size, PRIV_FLAGS_USES_PMEM | PRIV_FLAGS_FRAMEBUFFER);
+
+    // find a free slot
+    for (i = 0 ; i < numBuffers ; i++) {
+        m->currentBufferIndex = (m->currentBufferIndex + 1) % numBuffers;
+        if ((bufferMask & (1LU<<m->currentBufferIndex)) == 0) {
+            m->bufferMask |= (1LU<<m->currentBufferIndex);
+            break;
+        }
+    }
+    vaddr += bufferSize * m->currentBufferIndex;
+
+    hnd->base_addr = vaddr;
+    hnd->offset = vaddr - m->framebuffer->base_addr;
+    *pHandle = (buffer_handle_t)hnd;
+    *stride = (m->finfo.line_length * 8) / m->info.bits_per_pixel;
+
+    return 0;
+}
+
+int gralloc_alloc_framebuffer(alloc_device_t* dev,
+        size_t size, int usage, buffer_handle_t* pHandle, int *stride,
+        int* handled)
+{
+    struct hwmem_gralloc_module_t* m = (struct hwmem_gralloc_module_t*)
+            dev->common.module;
+    int err;
+    *handled = 1;
+    pthread_mutex_lock(&m->lock);
+    err = gralloc_alloc_framebuffer_locked(dev, size, usage, pHandle, stride,
+                handled);
+    pthread_mutex_unlock(&m->lock);
+    return err;
+}
diff --git a/display/libgralloc/hwmem_gralloc_pmem.c b/display/libgralloc/hwmem_gralloc_pmem.c
deleted file mode 100644
index d700c9c..0000000
--- a/display/libgralloc/hwmem_gralloc_pmem.c
+++ /dev/null
@@ -1,450 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#include <limits.h>
-#include <errno.h>
-#include <pthread.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <string.h>
-
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-#include "gralloc_stericsson_ext.h"
-
-#include "hwmem_gralloc.h"
-
-#if HAVE_ANDROID_OS
-#include <linux/android_pmem.h>
-#endif
-
-
-// we need this for now because pmem cannot mmap at an offset
-#define PMEM_HACK   1
-
-/* desktop Linux needs a little help with gettid() */
-#if defined(ARCH_X86) && !defined(HAVE_ANDROID_OS)
-#define __KERNEL__
-# include <linux/unistd.h>
-pid_t gettid() { return syscall(__NR_gettid);}
-#undef __KERNEL__
-#endif
-
-/*****************************************************************************/
-
-enum {
-    LOCK_STATE_WRITE     =   1<<31,
-    LOCK_STATE_MAPPED    =   1<<30,
-    LOCK_STATE_READ_MASK =   0x3FFFFFFF
-};
-
-static int gralloc_map(gralloc_module_t const* module,
-        struct hwmem_gralloc_buf_handle_t* hnd,
-        void** vaddr)
-{
-    if (!(hnd->flags & PRIV_FLAGS_FRAMEBUFFER)) {
-        size_t size = hnd->size;
-#if PMEM_HACK
-        size += hnd->offset;
-#endif
-        void* mappedAddress = mmap(0, size,
-                PROT_READ|PROT_WRITE, MAP_SHARED, hnd->fd, 0);
-        if (mappedAddress == MAP_FAILED) {
-            ALOGE("Could not mmap %s", strerror(errno));
-            return -errno;
-        }
-        hnd->base_addr = (int)mappedAddress + hnd->offset;
-        //ALOGD("gralloc_map() succeeded fd=%d, off=%d, size=%d, vaddr=%p",
-        //        hnd->fd, hnd->offset, hnd->size, mappedAddress);
-    }
-    *vaddr = (void*)hnd->base_addr;
-    return 0;
-}
-
-static int gralloc_unmap(gralloc_module_t const* module,
-        struct hwmem_gralloc_buf_handle_t* hnd)
-{
-    if (!(hnd->flags & PRIV_FLAGS_FRAMEBUFFER)) {
-        void* base = (void*)hnd->base_addr;
-        size_t size = hnd->size;
-#if PMEM_HACK
-        base = (void*)((int)base - hnd->offset);
-        size += hnd->offset;
-#endif
-        //ALOGD("unmapping from %p, size=%d", base, size);
-        if (munmap(base, size) < 0) {
-            ALOGE("Could not unmap %s", strerror(errno));
-        }
-    }
-    hnd->base_addr = 0;
-    return 0;
-}
-
-static int get_pmem_file_info(dev_t* device, ino_t* serial_number)
-{
-    static int write_values_initiated = 0;
-    static int error_occured_when_retreiving_pmem_file_info = 0;
-    static int error_code_produced_when_retreiving_pmem_file_info;
-    static int cached_values_present = 0;
-    static dev_t pmem_files_device;
-    static ino_t pmem_files_serial_number;
-
-    struct stat pmem_file_info;
-
-    if (error_occured_when_retreiving_pmem_file_info)
-    {
-        errno = error_code_produced_when_retreiving_pmem_file_info;
-
-        return 0;
-    }
-    else if (cached_values_present)
-    {
-        *device = pmem_files_device;
-        *serial_number = pmem_files_serial_number;
-
-        return 1;
-    }
-
-    if (stat("/dev/pmem_hwb", &pmem_file_info) < 0)
-    {
-        if (0 == android_atomic_cmpxchg(0, 1, &write_values_initiated))
-        {
-            error_code_produced_when_retreiving_pmem_file_info = errno;
-            android_atomic_write(1, &error_occured_when_retreiving_pmem_file_info);
-        }
-
-        return 0;
-    }
-
-    if (0 == android_atomic_cmpxchg(0, 1, &write_values_initiated))
-    {
-        pmem_files_device = pmem_file_info.st_dev;
-        pmem_files_serial_number = pmem_file_info.st_ino;
-        android_atomic_write(1, &cached_values_present);
-    }
-
-    *device = pmem_file_info.st_dev;
-    *serial_number = pmem_file_info.st_ino;
-
-    return 1;
-}
-
-static int is_pmem_fd(int fd, int* is_pmem_fd_var)
-{
-    dev_t pmem_file_device;
-    ino_t pmem_file_serial_number;
-
-    struct stat file_info;
-
-    if (!get_pmem_file_info(&pmem_file_device, &pmem_file_serial_number))
-        return 0;
-
-    if (fstat(fd, &file_info) < 0)
-        return 0;
-
-    if (file_info.st_dev == pmem_file_device &&
-        file_info.st_ino == pmem_file_serial_number)
-        *is_pmem_fd_var = 1;
-    else
-        *is_pmem_fd_var = 0;
-
-    return 1;
-}
-
-/*****************************************************************************/
-
-static pthread_mutex_t sMapLock = PTHREAD_MUTEX_INITIALIZER;
-
-/*****************************************************************************/
-
-int gralloc_create_handle_from_buffer_pmem(int fd, size_t size, size_t offset, void* base,
-    native_handle_t** handle)
-{
-    struct hwmem_gralloc_buf_handle_t* hwmem_gralloc_buf_handle;
-    int is_pmem_fd_var;
-
-    if (!is_pmem_fd(fd, &is_pmem_fd_var))
-        return -errno;
-    if (!is_pmem_fd_var)
-        return -EINVAL;
-
-    hwmem_gralloc_buf_handle =
-        (struct hwmem_gralloc_buf_handle_t*)native_handle_create(
-        num_fds_in_hwmem_gralloc_buf_handle,
-        num_ints_in_hwmem_gralloc_buf_handle);
-    if (NULL == hwmem_gralloc_buf_handle)
-    {
-        return -ENOMEM;
-    }
-
-    hwmem_gralloc_buf_handle->fd = fd;
-    hwmem_gralloc_buf_handle->flags = PRIV_FLAGS_USES_PMEM;
-    hwmem_gralloc_buf_handle->type_identifier = hwmem_gralloc_buf_handle_type_identifier;
-    hwmem_gralloc_buf_handle->type = GRALLOC_BUF_TYPE_PMEM;
-    hwmem_gralloc_buf_handle->size = size;
-    hwmem_gralloc_buf_handle->offset = offset;
-    hwmem_gralloc_buf_handle->base_addr = (int)base + offset;
-    hwmem_gralloc_buf_handle->lockState = LOCK_STATE_MAPPED;
-
-    *handle = (native_handle_t*)hwmem_gralloc_buf_handle;
-
-    return 0;
-}
-
-int gralloc_get_buf_allocator_handle_pmem(struct gralloc_module_t const* module,
-    struct hwmem_gralloc_buf_handle_t* hnd)
-{
-    return hnd->fd;
-}
-
-int gralloc_pin_buf_pmem(struct gralloc_module_t const* module,
-    struct hwmem_gralloc_buf_handle_t *hnd)
-{
-    if (hnd->type == GRALLOC_BUF_TYPE_PMEM) {
-        struct pmem_region region;
-        if (ioctl(hnd->fd, PMEM_GET_PHYS, &region) < 0)
-            return -errno;
-        return region.offset + hnd->offset;
-    } else if (hnd->type == GRALLOC_BUF_TYPE_FB) {
-        struct fb_fix_screeninfo fix_info;
-
-        if (ioctl(hnd->fd, FBIOGET_FSCREENINFO, &fix_info) < 0)
-            return -errno;
-        return (int)fix_info.smem_start + hnd->offset;
-    }
-
-    return -EINVAL;
-}
-
-int gralloc_unpin_buf_pmem(struct gralloc_module_t const* module,
-    struct hwmem_gralloc_buf_handle_t *hnd)
-{
-    /* PMEM and FD does not have support for pinning in the first place... */
-    return 0;
-}
-
-int gralloc_get_buf_offset_pmem(struct gralloc_module_t const* module,
-    struct hwmem_gralloc_buf_handle_t* hnd)
-{
-    return hnd->offset;
-}
-
-int gralloc_register_buffer_pmem(gralloc_module_t const* module,
-        struct hwmem_gralloc_buf_handle_t* hnd)
-{
-    // In this implementation, we don't need to do anything here
-
-    /* NOTE: we need to initialize the buffer as not mapped/not locked
-     * because it shouldn't when this function is called the first time
-     * in a new process. Ideally these flags shouldn't be part of the
-     * handle, but instead maintained in the kernel or at least
-     * out-of-line
-     */
-
-    // if this handle was created in this process, then we keep it as is.
-    if (hnd->pid != getpid()) {
-        hnd->base_addr = 0;
-        hnd->lockState  = 0;
-        hnd->writeOwner = 0;
-    }
-    return 0;
-}
-
-int gralloc_unregister_buffer_pmem(gralloc_module_t const* module,
-        struct hwmem_gralloc_buf_handle_t* hnd)
-{
-    /*
-     * If the buffer has been mapped during a lock operation, it's time
-     * to un-map it. It's an error to be here with a locked buffer.
-     * NOTE: the framebuffer is handled differently and is never unmapped.
-     */
-
-    ALOGE_IF(hnd->lockState & LOCK_STATE_READ_MASK,
-            "[unregister] handle %p still locked (state=%08x)",
-            hnd, hnd->lockState);
-
-    // never unmap buffers that were created in this process
-    if (hnd->pid != getpid()) {
-        if (hnd->lockState & LOCK_STATE_MAPPED) {
-            gralloc_unmap(module, hnd);
-        }
-        hnd->base_addr = 0;
-        hnd->lockState  = 0;
-        hnd->writeOwner = 0;
-    }
-    return 0;
-}
-
-static int terminateBuffer(gralloc_module_t const* module,
-        struct hwmem_gralloc_buf_handle_t* hnd)
-{
-    /*
-     * If the buffer has been mapped during a lock operation, it's time
-     * to un-map it. It's an error to be here with a locked buffer.
-     */
-
-    ALOGE_IF(hnd->lockState & LOCK_STATE_READ_MASK,
-            "[terminate] handle %p still locked (state=%08x)",
-            hnd, hnd->lockState);
-
-    if (hnd->lockState & LOCK_STATE_MAPPED) {
-        // this buffer was mapped, unmap it now
-        if ((hnd->flags & PRIV_FLAGS_USES_PMEM) &&
-            (hnd->pid == getpid())) {
-            // ... unless it's a "master" pmem buffer, that is a buffer
-            // mapped in the process it's been allocated.
-            // (see gralloc_alloc_buffer())
-        } else {
-            gralloc_unmap(module, hnd);
-        }
-    }
-
-    return 0;
-}
-
-int gralloc_lock_pmem(gralloc_module_t const* module,
-        struct hwmem_gralloc_buf_handle_t* hnd, int usage,
-        int l, int t, int w, int h,
-        void** vaddr)
-{
-    int err = 0;
-    int32_t current_value, new_value;
-    int retry;
-
-    do {
-        current_value = hnd->lockState;
-        new_value = current_value;
-
-        if (current_value & LOCK_STATE_WRITE) {
-            // already locked for write
-            ALOGE("handle %p already locked for write", hnd);
-            return -EBUSY;
-        } else if (current_value & LOCK_STATE_READ_MASK) {
-            // already locked for read
-            if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
-                ALOGE("handle %p already locked for read", hnd);
-                return -EBUSY;
-            } else {
-                // this is not an error
-                //ALOGD("%p already locked for read... count = %d",
-                //        hnd, (current_value & ~(1<<31)));
-            }
-        }
-
-        // not currently locked
-        if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
-            // locking for write
-            new_value |= LOCK_STATE_WRITE;
-        }
-        new_value++;
-
-        retry = android_atomic_cmpxchg(current_value, new_value,
-                (volatile int32_t*)&hnd->lockState);
-    } while (retry);
-
-    if (new_value & LOCK_STATE_WRITE) {
-        // locking for write, store the tid
-        hnd->writeOwner = gettid();
-    }
-
-    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
-        if (!(current_value & LOCK_STATE_MAPPED)) {
-            // we need to map for real
-            pthread_mutex_t* const lock = &sMapLock;
-            pthread_mutex_lock(lock);
-            if (!(hnd->lockState & LOCK_STATE_MAPPED)) {
-                err = gralloc_map(module, hnd, vaddr);
-                if (err == 0) {
-                    android_atomic_or(LOCK_STATE_MAPPED,
-                            (volatile int32_t*)&(hnd->lockState));
-                }
-            }
-            pthread_mutex_unlock(lock);
-        }
-        *vaddr = (void*)hnd->base_addr;
-    }
-
-    return err;
-}
-
-int gralloc_unlock_pmem(gralloc_module_t const* module,
-        struct hwmem_gralloc_buf_handle_t* hnd)
-{
-    int32_t current_value, new_value;
-
-    do {
-        current_value = hnd->lockState;
-        new_value = current_value;
-
-        if (current_value & LOCK_STATE_WRITE) {
-            // locked for write
-            if (hnd->writeOwner == gettid()) {
-                hnd->writeOwner = 0;
-                new_value &= ~LOCK_STATE_WRITE;
-            }
-        }
-
-        if ((new_value & LOCK_STATE_READ_MASK) == 0) {
-            ALOGE("handle %p not locked", hnd);
-            return -EINVAL;
-        }
-
-        new_value--;
-
-    } while (android_atomic_cmpxchg(current_value, new_value,
-            (volatile int32_t*)&hnd->lockState));
-
-    return 0;
-}
-
-int gralloc_free_pmem(alloc_device_t* dev,
-        struct hwmem_gralloc_buf_handle_t* hnd)
-{
-    if (hnd->flags & PRIV_FLAGS_FRAMEBUFFER) {
-        // free this buffer
-        struct hwmem_gralloc_module_t* m = (struct hwmem_gralloc_module_t*)
-                dev->common.module;
-        const size_t bufferSize = m->finfo.line_length * m->info.yres;
-        int index = (hnd->base_addr - m->framebuffer->base_addr) / bufferSize;
-        m->bufferMask &= ~(1<<index);
-    } else {
-#if HAVE_ANDROID_OS
-        if (hnd->flags & PRIV_FLAGS_USES_PMEM) {
-            if (hnd->fd >= 0) {
-                struct pmem_region sub = { hnd->offset, hnd->size };
-                int err = ioctl(hnd->fd, PMEM_UNMAP, &sub);
-                ALOGE_IF(err<0, "PMEM_UNMAP failed (%s), "
-                        "fd=%d, sub.offset=%i, sub.size=%i",
-                        strerror(errno), hnd->fd, hnd->offset, hnd->size);
-            }
-        }
-#endif // HAVE_ANDROID_OS
-        terminateBuffer(NULL, hnd); /* NULL is ok here as the parameter is not used by terminateBuffer */
-    }
-
-    close(hnd->fd);
-    free(hnd);
-    return 0;
-}
diff --git a/display/libgralloc/hwmem_gralloc_pmem.cpp b/display/libgralloc/hwmem_gralloc_pmem.cpp
new file mode 100644
index 0000000..2cf0e41
--- /dev/null
+++ b/display/libgralloc/hwmem_gralloc_pmem.cpp
@@ -0,0 +1,451 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#include <limits.h>
+#include <errno.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hardware.h>
+#include <hardware/gralloc.h>
+#include "gralloc_stericsson_ext.h"
+
+#include "hwmem_gralloc.h"
+
+#if HAVE_ANDROID_OS
+#include <linux/android_pmem.h>
+#endif
+
+
+// we need this for now because pmem cannot mmap at an offset
+#define PMEM_HACK   1
+
+/* desktop Linux needs a little help with gettid() */
+#if defined(ARCH_X86) && !defined(HAVE_ANDROID_OS)
+#define __KERNEL__
+# include <linux/unistd.h>
+pid_t gettid() { return syscall(__NR_gettid);}
+#undef __KERNEL__
+#endif
+
+/*****************************************************************************/
+
+enum {
+    LOCK_STATE_WRITE     =   1<<31,
+    LOCK_STATE_MAPPED    =   1<<30,
+    LOCK_STATE_READ_MASK =   0x3FFFFFFF
+};
+
+static int gralloc_map(gralloc_module_t const* module,
+        struct hwmem_gralloc_buf_handle_t* hnd,
+        void** vaddr)
+{
+    if (!(hnd->flags & PRIV_FLAGS_FRAMEBUFFER)) {
+        size_t size = hnd->size;
+#if PMEM_HACK
+        size += hnd->offset;
+#endif
+        void* mappedAddress = mmap(0, size,
+                PROT_READ|PROT_WRITE, MAP_SHARED, hnd->fd, 0);
+        if (mappedAddress == MAP_FAILED) {
+            ALOGE("Could not mmap %s", strerror(errno));
+            return -errno;
+        }
+        hnd->base_addr = (int)mappedAddress + hnd->offset;
+        //ALOGD("gralloc_map() succeeded fd=%d, off=%d, size=%d, vaddr=%p",
+        //        hnd->fd, hnd->offset, hnd->size, mappedAddress);
+    }
+    *vaddr = (void*)hnd->base_addr;
+    return 0;
+}
+
+static int gralloc_unmap(gralloc_module_t const* module,
+        struct hwmem_gralloc_buf_handle_t* hnd)
+{
+    if (!(hnd->flags & PRIV_FLAGS_FRAMEBUFFER)) {
+        void* base = (void*)hnd->base_addr;
+        size_t size = hnd->size;
+#if PMEM_HACK
+        base = (void*)((int)base - hnd->offset);
+        size += hnd->offset;
+#endif
+        //ALOGD("unmapping from %p, size=%d", base, size);
+        if (munmap(base, size) < 0) {
+            ALOGE("Could not unmap %s", strerror(errno));
+        }
+    }
+    hnd->base_addr = 0;
+    return 0;
+}
+
+static int get_pmem_file_info(dev_t* device, ino_t* serial_number)
+{
+    static int write_values_initiated = 0;
+    static int error_occured_when_retreiving_pmem_file_info = 0;
+    static int error_code_produced_when_retreiving_pmem_file_info;
+    static int cached_values_present = 0;
+    static dev_t pmem_files_device;
+    static ino_t pmem_files_serial_number;
+
+    struct stat pmem_file_info;
+
+    if (error_occured_when_retreiving_pmem_file_info)
+    {
+        errno = error_code_produced_when_retreiving_pmem_file_info;
+
+        return 0;
+    }
+    else if (cached_values_present)
+    {
+        *device = pmem_files_device;
+        *serial_number = pmem_files_serial_number;
+
+        return 1;
+    }
+
+    if (stat("/dev/pmem_hwb", &pmem_file_info) < 0)
+    {
+        if (0 == android_atomic_cmpxchg(0, 1, &write_values_initiated))
+        {
+            error_code_produced_when_retreiving_pmem_file_info = errno;
+            android_atomic_write(1, &error_occured_when_retreiving_pmem_file_info);
+        }
+
+        return 0;
+    }
+
+    if (0 == android_atomic_cmpxchg(0, 1, &write_values_initiated))
+    {
+        pmem_files_device = pmem_file_info.st_dev;
+        pmem_files_serial_number = pmem_file_info.st_ino;
+        android_atomic_write(1, &cached_values_present);
+    }
+
+    *device = pmem_file_info.st_dev;
+    *serial_number = pmem_file_info.st_ino;
+
+    return 1;
+}
+
+static int is_pmem_fd(int fd, int* is_pmem_fd_var)
+{
+    dev_t pmem_file_device;
+    ino_t pmem_file_serial_number;
+
+    struct stat file_info;
+
+    if (!get_pmem_file_info(&pmem_file_device, &pmem_file_serial_number))
+        return 0;
+
+    if (fstat(fd, &file_info) < 0)
+        return 0;
+
+    if (file_info.st_dev == pmem_file_device &&
+        file_info.st_ino == pmem_file_serial_number)
+        *is_pmem_fd_var = 1;
+    else
+        *is_pmem_fd_var = 0;
+
+    return 1;
+}
+
+/*****************************************************************************/
+
+static pthread_mutex_t sMapLock = PTHREAD_MUTEX_INITIALIZER;
+
+/*****************************************************************************/
+
+int gralloc_create_handle_from_buffer_pmem(int fd, size_t size, size_t offset, void* base,
+    native_handle_t** handle)
+{
+    struct hwmem_gralloc_buf_handle_t* hwmem_gralloc_buf_handle;
+    int is_pmem_fd_var;
+
+    if (!is_pmem_fd(fd, &is_pmem_fd_var))
+        return -errno;
+    if (!is_pmem_fd_var)
+        return -EINVAL;
+
+    hwmem_gralloc_buf_handle =
+        (struct hwmem_gralloc_buf_handle_t*)native_handle_create(
+        num_fds_in_hwmem_gralloc_buf_handle,
+        num_ints_in_hwmem_gralloc_buf_handle);
+    if (NULL == hwmem_gralloc_buf_handle)
+    {
+        return -ENOMEM;
+    }
+
+    hwmem_gralloc_buf_handle->fd = fd;
+    hwmem_gralloc_buf_handle->flags = PRIV_FLAGS_USES_PMEM;
+    hwmem_gralloc_buf_handle->type_identifier = hwmem_gralloc_buf_handle_type_identifier;
+    hwmem_gralloc_buf_handle->type = GRALLOC_BUF_TYPE_PMEM;
+    hwmem_gralloc_buf_handle->size = size;
+    hwmem_gralloc_buf_handle->offset = offset;
+    hwmem_gralloc_buf_handle->base_addr = (int)base + offset;
+    hwmem_gralloc_buf_handle->lockState = LOCK_STATE_MAPPED;
+
+    *handle = (native_handle_t*)hwmem_gralloc_buf_handle;
+
+    return 0;
+}
+
+int gralloc_get_buf_allocator_handle_pmem(struct gralloc_module_t const* module,
+    struct hwmem_gralloc_buf_handle_t* hnd)
+{
+    return hnd->fd;
+}
+
+int gralloc_pin_buf_pmem(struct gralloc_module_t const* module,
+    struct hwmem_gralloc_buf_handle_t *hnd)
+{
+    if (hnd->type == GRALLOC_BUF_TYPE_PMEM) {
+        struct pmem_region region;
+        if (ioctl(hnd->fd, PMEM_GET_PHYS, &region) < 0)
+            return -errno;
+        return region.offset + hnd->offset;
+    } else if (hnd->type == GRALLOC_BUF_TYPE_FB) {
+        struct fb_fix_screeninfo fix_info;
+
+        if (ioctl(hnd->fd, FBIOGET_FSCREENINFO, &fix_info) < 0)
+            return -errno;
+        return (int)fix_info.smem_start + hnd->offset;
+    }
+
+    return -EINVAL;
+}
+
+int gralloc_unpin_buf_pmem(struct gralloc_module_t const* module,
+    struct hwmem_gralloc_buf_handle_t *hnd)
+{
+    /* PMEM and FD does not have support for pinning in the first place... */
+    return 0;
+}
+
+int gralloc_get_buf_offset_pmem(struct gralloc_module_t const* module,
+    struct hwmem_gralloc_buf_handle_t* hnd)
+{
+    return hnd->offset;
+}
+
+int gralloc_register_buffer_pmem(gralloc_module_t const* module,
+        struct hwmem_gralloc_buf_handle_t* hnd)
+{
+    // In this implementation, we don't need to do anything here
+
+    /* NOTE: we need to initialize the buffer as not mapped/not locked
+     * because it shouldn't when this function is called the first time
+     * in a new process. Ideally these flags shouldn't be part of the
+     * handle, but instead maintained in the kernel or at least
+     * out-of-line
+     */
+
+    // if this handle was created in this process, then we keep it as is.
+    if (hnd->pid != getpid()) {
+        hnd->base_addr = 0;
+        hnd->lockState  = 0;
+        hnd->writeOwner = 0;
+    }
+    return 0;
+}
+
+int gralloc_unregister_buffer_pmem(gralloc_module_t const* module,
+        struct hwmem_gralloc_buf_handle_t* hnd)
+{
+    /*
+     * If the buffer has been mapped during a lock operation, it's time
+     * to un-map it. It's an error to be here with a locked buffer.
+     * NOTE: the framebuffer is handled differently and is never unmapped.
+     */
+
+    ALOGE_IF(hnd->lockState & LOCK_STATE_READ_MASK,
+            "[unregister] handle %p still locked (state=%08x)",
+            hnd, hnd->lockState);
+
+    // never unmap buffers that were created in this process
+    if (hnd->pid != getpid()) {
+        if (hnd->lockState & LOCK_STATE_MAPPED) {
+            gralloc_unmap(module, hnd);
+        }
+        hnd->base_addr = 0;
+        hnd->lockState  = 0;
+        hnd->writeOwner = 0;
+    }
+    return 0;
+}
+
+static int terminateBuffer(gralloc_module_t const* module,
+        struct hwmem_gralloc_buf_handle_t* hnd)
+{
+    /*
+     * If the buffer has been mapped during a lock operation, it's time
+     * to un-map it. It's an error to be here with a locked buffer.
+     */
+
+    ALOGE_IF(hnd->lockState & LOCK_STATE_READ_MASK,
+            "[terminate] handle %p still locked (state=%08x)",
+            hnd, hnd->lockState);
+
+    if (hnd->lockState & LOCK_STATE_MAPPED) {
+        // this buffer was mapped, unmap it now
+        if ((hnd->flags & PRIV_FLAGS_USES_PMEM) &&
+            (hnd->pid == getpid())) {
+            // ... unless it's a "master" pmem buffer, that is a buffer
+            // mapped in the process it's been allocated.
+            // (see gralloc_alloc_buffer())
+        } else {
+            gralloc_unmap(module, hnd);
+        }
+    }
+
+    return 0;
+}
+
+int gralloc_lock_pmem(gralloc_module_t const* module,
+        struct hwmem_gralloc_buf_handle_t* hnd, int usage,
+        int l, int t, int w, int h,
+        void** vaddr)
+{
+    int err = 0;
+    int32_t current_value, new_value;
+    int retry;
+
+    do {
+        current_value = hnd->lockState;
+        new_value = current_value;
+
+        if (current_value & LOCK_STATE_WRITE) {
+            // already locked for write
+            ALOGE("handle %p already locked for write", hnd);
+            return -EBUSY;
+        } else if (current_value & LOCK_STATE_READ_MASK) {
+            // already locked for read
+            if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
+                ALOGE("handle %p already locked for read", hnd);
+                return -EBUSY;
+            } else {
+                // this is not an error
+                //ALOGD("%p already locked for read... count = %d",
+                //        hnd, (current_value & ~(1<<31)));
+            }
+        }
+
+        // not currently locked
+        if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
+            // locking for write
+            new_value |= LOCK_STATE_WRITE;
+        }
+        new_value++;
+
+        retry = android_atomic_cmpxchg(current_value, new_value,
+                (volatile int32_t*)&hnd->lockState);
+    } while (retry);
+
+    if (new_value & LOCK_STATE_WRITE) {
+        // locking for write, store the tid
+        hnd->writeOwner = gettid();
+    }
+
+    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
+        if (!(current_value & LOCK_STATE_MAPPED)) {
+            // we need to map for real
+            pthread_mutex_t* const lock = &sMapLock;
+            pthread_mutex_lock(lock);
+            if (!(hnd->lockState & LOCK_STATE_MAPPED)) {
+                err = gralloc_map(module, hnd, vaddr);
+                if (err == 0) {
+                    android_atomic_or(LOCK_STATE_MAPPED,
+                            (volatile int32_t*)&(hnd->lockState));
+                }
+            }
+            pthread_mutex_unlock(lock);
+        }
+        *vaddr = (void*)hnd->base_addr;
+    }
+
+    return err;
+}
+
+int gralloc_unlock_pmem(gralloc_module_t const* module,
+        struct hwmem_gralloc_buf_handle_t* hnd)
+{
+    int32_t current_value, new_value;
+
+    do {
+        current_value = hnd->lockState;
+        new_value = current_value;
+
+        if (current_value & LOCK_STATE_WRITE) {
+            // locked for write
+            if (hnd->writeOwner == gettid()) {
+                hnd->writeOwner = 0;
+                new_value &= ~LOCK_STATE_WRITE;
+            }
+        }
+
+        if ((new_value & LOCK_STATE_READ_MASK) == 0) {
+            ALOGE("handle %p not locked", hnd);
+            return -EINVAL;
+        }
+
+        new_value--;
+
+    } while (android_atomic_cmpxchg(current_value, new_value,
+            (volatile int32_t*)&hnd->lockState));
+
+    return 0;
+}
+
+int gralloc_free_pmem(alloc_device_t* dev,
+        struct hwmem_gralloc_buf_handle_t* hnd)
+{
+    if (hnd->flags & PRIV_FLAGS_FRAMEBUFFER) {
+        // free this buffer
+        struct hwmem_gralloc_module_t* m = (struct hwmem_gralloc_module_t*)
+                dev->common.module;
+        const size_t bufferSize = m->finfo.line_length * m->info.yres;
+        int index = (hnd->base_addr - m->framebuffer->base_addr) / bufferSize;
+        m->bufferMask &= ~(1<<index);
+    } else {
+#if HAVE_ANDROID_OS
+        if (hnd->flags & PRIV_FLAGS_USES_PMEM) {
+            if (hnd->fd >= 0) {
+                struct pmem_region sub = { (unsigned long)hnd->offset, (unsigned long)hnd->size };
+                int err = ioctl(hnd->fd, PMEM_UNMAP, &sub);
+                ALOGE_IF(err<0, "PMEM_UNMAP failed (%s), "
+                        "fd=%d, sub.offset=%i, sub.size=%i",
+                        strerror(errno), hnd->fd, hnd->offset, hnd->size);
+            }
+        }
+#endif // HAVE_ANDROID_OS
+        terminateBuffer(NULL, hnd); /* NULL is ok here as the parameter is not used by terminateBuffer */
+    }
+
+    close(hnd->fd);
+    free(hnd);
+    return 0;
+}
diff --git a/libste_symbols/Android.mk b/libste_symbols/Android.mk
index fe95fb1..6e67da9 100755
--- a/libste_symbols/Android.mk
+++ b/libste_symbols/Android.mk
@@ -12,29 +12,30 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-LOCAL_PATH := $(call my-dir)
-
 #
-# compat symbols for gps
+# compat symbols for camera HAL
 #
 
+LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
 
-LOCAL_SRC_FILES := libshim_gps.c
-LOCAL_SHARED_LIBRARIES := liblog libcutils libgui libbinder libutils
-LOCAL_MODULE := libshim_gps
+LOCAL_SRC_FILES := ste_camera.cpp
+LOCAL_SHARED_LIBRARIES := libgui libui libutils
+LOCAL_MODULE := libcamera_symbols
 LOCAL_MODULE_TAGS := optional
 
 include $(BUILD_SHARED_LIBRARY)
 
 #
-# open function wrapper
+# compat symbols for gps
 #
 
 include $(CLEAR_VARS)
-LOCAL_SRC_FILES := open_wrapper.c
-LOCAL_SHARED_LIBRARIES := liblog
-LOCAL_MODULE := libopen
+
+LOCAL_SRC_FILES := libshim_gps.c
+LOCAL_SHARED_LIBRARIES := liblog libcutils libgui libbinder libutils
+LOCAL_MODULE := libshim_gps
 LOCAL_MODULE_TAGS := optional
 
 include $(BUILD_SHARED_LIBRARY)
+
diff --git a/libste_symbols/ste_camera.cpp b/libste_symbols/ste_camera.cpp
new file mode 100755
index 0000000..8ddf8df
--- /dev/null
+++ b/libste_symbols/ste_camera.cpp
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <system/window.h>
+#include <gui/SurfaceComposerClient.h>
+#include <ui/DisplayInfo.h>
+#include <ui/PixelFormat.h>
+#include <ui/Rect.h>
+
+namespace android {
+
+// ---------------------------------------------------------------------------
+
+extern "C" {
+
+    /* status_t GraphicBufferMapper::lock */
+    status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(
+            buffer_handle_t handle, uint32_t usage, const Rect& bounds, void** vaddr);
+
+    status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(
+            buffer_handle_t handle, int usage, const android::Rect& bounds, void** vaddr) {
+        return _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(
+                handle, (uint32_t)usage, bounds, vaddr);
+    }
+
+    /* status_t GraphicBufferAllocator::alloc */
+    status_t _ZN7android22GraphicBufferAllocator5allocEjjijPPK13native_handlePj(
+            uint32_t width, uint32_t height, PixelFormat format, uint32_t usage,
+            buffer_handle_t* handle, uint32_t* stride);
+
+    status_t _ZN7android22GraphicBufferAllocator5allocEjjiiPPK13native_handlePi(
+            uint32_t width, uint32_t height, PixelFormat format, int usage,
+            buffer_handle_t* handle, uint32_t* stride) {
+        return _ZN7android22GraphicBufferAllocator5allocEjjijPPK13native_handlePj(
+                width, height, format, (uint32_t)usage, handle, stride);
+    }
+
+    /* ssize_t SurfaceComposerClient::getDisplayWidth */
+    ssize_t _ZN7android21SurfaceComposerClient15getDisplayWidthEi(int32_t displayId) {
+        DisplayInfo info;
+        SurfaceComposerClient::getDisplayInfo(
+                SurfaceComposerClient::getBuiltInDisplay(displayId), &info);
+        return static_cast<ssize_t>(info.w);
+    }
+
+    /* ssize_t SurfaceComposerClient::getDisplayHeight */
+    ssize_t _ZN7android21SurfaceComposerClient16getDisplayHeightEi(int32_t displayId) {
+        DisplayInfo info;
+        SurfaceComposerClient::getDisplayInfo(
+                SurfaceComposerClient::getBuiltInDisplay(displayId), &info);
+        return static_cast<ssize_t>(info.h);
+    }
+
+}
+
+// ---------------------------------------------------------------------------
+
+}; // namespace android
\ No newline at end of file
diff --git a/ril/libril/ril.cpp b/ril/libril/ril.cpp
index 4b772f2..579da20 100755
--- a/ril/libril/ril.cpp
+++ b/ril/libril/ril.cpp
@@ -4487,7 +4487,7 @@ void libEvtLoading(void)
 	fRealRILonRequestComplete =
 		(void (*)(RIL_Token, RIL_Errno, void *, size_t))dlsym(realRilLibHandle, "RIL_onRequestComplete");
 
-	if (!fRealRILonRequestComplete) {
+	if (!fRealRILregister) {
 		RLOGE("Failed to find the real RIL_onRequestComplete\n");
 		goto out_fail;
 	}
@@ -4495,7 +4495,7 @@ void libEvtLoading(void)
 	fRealRILonUnsolicitedResponse =
 		(void (*)(int, const void *, size_t))dlsym(realRilLibHandle, "RIL_onUnsolicitedResponse");
 
-	if (!fRealRILonUnsolicitedResponse) {
+	if (!fRealRILregister) {
 		RLOGE("Failed to find the real RIL_onUnsolicitedResponse\n");
 		goto out_fail;
 	}
diff --git a/tests/Android.mk b/tests/Android.mk
index f77d732..2791024 100644
--- a/tests/Android.mk
+++ b/tests/Android.mk
@@ -10,7 +10,8 @@ LOCAL_CFLAGS += -fno-strict-aliasing -fno-common -Werror-implicit-function-decla
 LOCAL_SRC_FILES := whetstone.c
 LOCAL_MODULE_PATH := $(TARGET_OUT_EXECUTABLES)
 LOCAL_MODULE_TAGS := optional
-LOCAL_SYSTEM_SHARED_LIBRARIES := libc libm
+LOCAL_STATIC_LIBRARIES := libm
+LOCAL_SYSTEM_SHARED_LIBRARIES := libc
 LOCAL_MODULE := whetstone
 include $(BUILD_EXECUTABLE)
 
@@ -22,18 +23,6 @@ LOCAL_CFLAGS += -fno-strict-aliasing -fno-common -Werror-implicit-function-decla
 LOCAL_SRC_FILES := whetstone.c
 LOCAL_MODULE_PATH := $(TARGET_OUT_EXECUTABLES)
 LOCAL_MODULE_TAGS := optional
-LOCAL_SYSTEM_SHARED_LIBRARIES := libc libm
-LOCAL_MODULE := whetstone_thumb
-include $(BUILD_EXECUTABLE)
-
-include $(CLEAR_VARS)
-
-LOCAL_CFLAGS := $(COMMON_FLAGS) -O2 -Wall -Wundef
-LOCAL_CFLAGS += -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration
-#LOCAL_LDFLAGS := -Wl,--no-gc-sections
-LOCAL_SRC_FILES := whetstone.c
-LOCAL_MODULE_PATH := $(TARGET_OUT_EXECUTABLES)
-LOCAL_MODULE_TAGS := optional
 LOCAL_STATIC_LIBRARIES := libw
 LOCAL_SYSTEM_SHARED_LIBRARIES := libc
 #LOCAL_FORCE_STATIC_EXECUTABLE := true
diff --git a/tests/coremark/Android.mk b/tests/coremark/Android.mk
deleted file mode 100644
index 0cb901b..0000000
--- a/tests/coremark/Android.mk
+++ /dev/null
@@ -1,39 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_CFLAGS :=  -DITERATIONS=0 -O3 -mthumb -fstrict-aliasing -funroll-loops
-LOCAL_REPORT_FLAGS := true
-
-LOCAL_SRC_FILES := core_list_join.c core_main.c core_matrix.c core_state.c core_util.c core_portme.c 
-LOCAL_MODULE_PATH := $(TARGET_OUT_EXECUTABLES)
-LOCAL_MODULE_TAGS := optional
-LOCAL_SYSTEM_SHARED_LIBRARIES := libc libm libstdc++
-LOCAL_MODULE := coremark_thumb
-
-LOCAL_CFLAGS += -DFLAGS_STR="\"\n\TARGET_GLOBAL_CFLAGS=$(TARGET_GLOBAL_CFLAGS)\n\
-TARGET_\$\(mode\)_CFLAGS=$(TARGET_thumb_CFLAGS)\n\
-LOCAL_CFLAGS=$(LOCAL_CFLAGS)\""
-
-include $(BUILD_EXECUTABLE)
-
-
-include $(CLEAR_VARS)
-
-LOCAL_CFLAGS := -O3 -marm -fstrict-aliasing -funroll-loops
-LOCAL_REPORT_FLAGS := true
-
-LOCAL_SRC_FILES := core_list_join.c core_main.c core_matrix.c core_state.c core_util.c core_portme.c 
-LOCAL_MODULE_PATH := $(TARGET_OUT_EXECUTABLES)
-LOCAL_MODULE_TAGS := optional
-LOCAL_SYSTEM_SHARED_LIBRARIES := libc libm libstdc++
-LOCAL_MODULE := coremark_arm
-
-LOCAL_CFLAGS += -DFLAGS_STR="\"\n\TARGET_GLOBAL_CFLAGS=$(TARGET_GLOBAL_CFLAGS) \n\
-TARGET_GLOBAL_CPPFLAGS=$(TARGET_GLOBAL_CPPFLAGS) \n\
-TARGET_\$\(mode\)_CFLAGS=$(TARGET_thumb_CFLAGS) \n\
-LOCAL_CFLAGS=$(LOCAL_CFLAGS)\"" -DITERATIONS=0
-
-include $(BUILD_EXECUTABLE)
-
-
diff --git a/tests/coremark/clean.sh b/tests/coremark/clean.sh
deleted file mode 100755
index 0dcccca..0000000
--- a/tests/coremark/clean.sh
+++ /dev/null
@@ -1 +0,0 @@
-rm -fr ~/repo/out/target/product/codina/obj/EXECUTABLES/coremark_*
diff --git a/tests/coremark/core_list_join.c b/tests/coremark/core_list_join.c
deleted file mode 100644
index dd2d4d7..0000000
--- a/tests/coremark/core_list_join.c
+++ /dev/null
@@ -1,496 +0,0 @@
-/*
-Author : Shay Gal-On, EEMBC
-
-This file is part of  EEMBC(R) and CoreMark(TM), which are Copyright (C) 2009 
-All rights reserved.                            
-
-EEMBC CoreMark Software is a product of EEMBC and is provided under the terms of the
-CoreMark License that is distributed with the official EEMBC COREMARK Software release. 
-If you received this EEMBC CoreMark Software without the accompanying CoreMark License, 
-you must discontinue use and download the official release from www.coremark.org.  
-
-Also, if you are publicly displaying scores generated from the EEMBC CoreMark software, 
-make sure that you are in compliance with Run and Reporting rules specified in the accompanying readme.txt file.
-
-EEMBC 
-4354 Town Center Blvd. Suite 114-200
-El Dorado Hills, CA, 95762 
-*/ 
-
-#include "coremark.h"
-/*
-Topic: Description
-	Benchmark using a linked list.
-
-	Linked list is a common data structure used in many applications.
-	
-	For our purposes, this will excercise the memory units of the processor.
-	In particular, usage of the list pointers to find and alter data.
-	
-	We are not using Malloc since some platforms do not support this library.
-	
-	Instead, the memory block being passed in is used to create a list,
-	and the benchmark takes care not to add more items then can be
-	accomodated by the memory block. The porting layer will make sure
-	that we have a valid memory block.
-	
-	All operations are done in place, without using any extra memory.
-	
-	The list itself contains list pointers and pointers to data items.
-	Data items contain the following:
-	
-	idx - An index that captures the initial order of the list.
-	data - Variable data initialized based on the input parameters. The 16b are divided as follows:
-	o Upper 8b are backup of original data.
-	o Bit 7 indicates if the lower 7 bits are to be used as is or calculated.
-	o Bits 0-2 indicate type of operation to perform to get a 7b value.
-	o Bits 3-6 provide input for the operation.
-	
-*/
-
-/* local functions */
-
-list_head *core_list_find(list_head *list,list_data *info);
-list_head *core_list_reverse(list_head *list);
-list_head *core_list_remove(list_head *item);
-list_head *core_list_undo_remove(list_head *item_removed, list_head *item_modified);
-list_head *core_list_insert_new(list_head *insert_point
-	, list_data *info, list_head **memblock, list_data **datablock
-	, list_head *memblock_end, list_data *datablock_end);
-typedef ee_s32(*list_cmp)(list_data *a, list_data *b, core_results *res);
-list_head *core_list_mergesort(list_head *list, list_cmp cmp, core_results *res);
-
-ee_s16 calc_func(ee_s16 *pdata, core_results *res) {
-	ee_s16 data=*pdata;
-	ee_s16 retval;
-	ee_u8 optype=(data>>7) & 1; /* bit 7 indicates if the function result has been cached */
-	if (optype) /* if cached, use cache */
-		return (data & 0x007f);
-	else { /* otherwise calculate and cache the result */
-		ee_s16 flag=data & 0x7; /* bits 0-2 is type of function to perform */
-		ee_s16 dtype=((data>>3) & 0xf); /* bits 3-6 is specific data for the operation */
-		dtype |= dtype << 4; /* replicate the lower 4 bits to get an 8b value */
-		switch (flag) {
-			case 0:
-				if (dtype<0x22) /* set min period for bit corruption */
-					dtype=0x22;
-				retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
-				if (res->crcstate==0)
-					res->crcstate=retval;
-				break;
-			case 1:
-				retval=core_bench_matrix(&(res->mat),dtype,res->crc);
-				if (res->crcmatrix==0)
-					res->crcmatrix=retval;
-				break;
-			default:
-				retval=data;
-				break;
-		}
-		res->crc=crcu16(retval,res->crc);
-		retval &= 0x007f; 
-		*pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
-		return retval;
-	}
-}
-/* Function: cmp_complex
-	Compare the data item in a list cell.
-
-	Can be used by mergesort.
-*/
-ee_s32 cmp_complex(list_data *a, list_data *b, core_results *res) {
-	ee_s16 val1=calc_func(&(a->data16),res);
-	ee_s16 val2=calc_func(&(b->data16),res);
-	return val1 - val2;
-}
-
-/* Function: cmp_idx
-	Compare the idx item in a list cell, and regen the data.
-
-	Can be used by mergesort.
-*/
-ee_s32 cmp_idx(list_data *a, list_data *b, core_results *res) {
-	if (res==NULL) {
-		a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16>>8));
-		b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
-	}
-	return a->idx - b->idx;
-}
-
-void copy_info(list_data *to,list_data *from) {
-	to->data16=from->data16;
-	to->idx=from->idx;
-}
-
-/* Benchmark for linked list:
-	- Try to find multiple data items.
-	- List sort
-	- Operate on data from list (crc)
-	- Single remove/reinsert
-	* At the end of this function, the list is back to original state
-*/
-ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
-	ee_u16 retval=0;
-	ee_u16 found=0,missed=0;
-	list_head *list=res->list;
-	ee_s16 find_num=res->seed3;
-	list_head *this_find;
-	list_head *finder, *remover;
-	list_data info;
-	ee_s16 i;
-
-	info.idx=finder_idx;
-	/* find <find_num> values in the list, and change the list each time (reverse and cache if value found) */
-	for (i=0; i<find_num; i++) {
-		info.data16= (i & 0xff) ;
-		this_find=core_list_find(list,&info);
-		list=core_list_reverse(list);
-		if (this_find==NULL) {
-			missed++;
-			retval+=(list->next->info->data16 >> 8) & 1;
-		}
-		else {
-			found++;
-			if (this_find->info->data16 & 0x1) /* use found value */
-				retval+=(this_find->info->data16 >> 9) & 1;
-			/* and cache next item at the head of the list (if any) */
-			if (this_find->next != NULL) {
-				finder = this_find->next;
-				this_find->next = finder->next;
-				finder->next=list->next;
-				list->next=finder;
-			}
-		}
-		if (info.idx>=0)
-			info.idx++;
-#if CORE_DEBUG
-	ee_printf("List find %d: [%d,%d,%d]\n",i,retval,missed,found);
-#endif
-	}
-	retval+=found*4-missed;
-	/* sort the list by data content and remove one item*/
-	if (finder_idx>0)
-		list=core_list_mergesort(list,cmp_complex,res);
-	remover=core_list_remove(list->next);
-	/* CRC data content of list from location of index N forward, and then undo remove */
-	finder=core_list_find(list,&info);
-	if (!finder)
-		finder=list->next;
-	while (finder) {
-		retval=crc16(list->info->data16,retval);
-		finder=finder->next;
-	}
-#if CORE_DEBUG
-	ee_printf("List sort 1: %04x\n",retval);
-#endif
-	remover=core_list_undo_remove(remover,list->next);
-	/* sort the list by index, in effect returning the list to original state */
-	list=core_list_mergesort(list,cmp_idx,NULL);
-	/* CRC data content of list */
-	finder=list->next;
-	while (finder) {
-		retval=crc16(list->info->data16,retval);
-		finder=finder->next;
-	}
-#if CORE_DEBUG
-	ee_printf("List sort 2: %04x\n",retval);
-#endif
-	return retval;
-}
-/* Function: core_list_init
-	Initialize list with data.
-
-	Parameters:
-	blksize - Size of memory to be initialized.
-	memblock - Pointer to memory block.
-	seed - 	Actual values chosen depend on the seed parameter.
-		The seed parameter MUST be supplied from a source that cannot be determined at compile time
-
-	Returns:
-	Pointer to the head of the list.
-
-*/
-list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed) {
-	/* calculated pointers for the list */
-	ee_u32 per_item=16+sizeof(struct list_data_s);
-	ee_u32 size=(blksize/per_item)-2; /* to accomodate systems with 64b pointers, and make sure same code is executed, set max list elements */
-	list_head *memblock_end=memblock+size;
-	list_data *datablock=(list_data *)(memblock_end);
-	list_data *datablock_end=datablock+size;
-	/* some useful variables */
-	ee_u32 i;
-	list_head *finder,*list=memblock;
-	list_data info;
-
-	/* create a fake items for the list head and tail */
-	list->next=NULL;
-	list->info=datablock;
-	list->info->idx=0x0000;
-	list->info->data16=(ee_s16)0x8080;
-	memblock++;
-	datablock++;
-	info.idx=0x7fff;
-	info.data16=(ee_s16)0xffff;
-	core_list_insert_new(list,&info,&memblock,&datablock,memblock_end,datablock_end);
-	
-	/* then insert size items */
-	for (i=0; i<size; i++) {
-		ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
-		ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
-		info.data16=(dat<<8) | dat;		/* fill the data with actual data and upper bits with rebuild value */
-		core_list_insert_new(list,&info,&memblock,&datablock,memblock_end,datablock_end);
-	}
-	/* and now index the list so we know initial seed order of the list */
-	finder=list->next;
-	i=1;
-	while (finder->next!=NULL) {
-		if (i<size/5) /* first 20% of the list in order */
-			finder->info->idx=i++;
-		else { 
-			ee_u16 pat=(ee_u16)(i++ ^ seed); /* get a pseudo random number */
-			finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
-		}
-		finder=finder->next;
-	}
-	list = core_list_mergesort(list,cmp_idx,NULL);
-#if CORE_DEBUG
-	ee_printf("Initialized list:\n");
-	finder=list;
-	while (finder) {
-		ee_printf("[%04x,%04x]",finder->info->idx,(ee_u16)finder->info->data16);
-		finder=finder->next;
-	}
-	ee_printf("\n");
-#endif
-	return list;
-}
-
-/* Function: core_list_insert
-	Insert an item to the list
-
-	Parameters:
-	insert_point - where to insert the item.
-	info - data for the cell.
-	memblock - pointer for the list header
-	datablock - pointer for the list data
-	memblock_end - end of region for list headers
-	datablock_end - end of region for list data
-
-	Returns:
-	Pointer to new item.
-*/
-list_head *core_list_insert_new(list_head *insert_point, list_data *info, list_head **memblock, list_data **datablock
-	, list_head *memblock_end, list_data *datablock_end) {
-	list_head *newitem;
-	
-	if ((*memblock+1) >= memblock_end)
-		return NULL;
-	if ((*datablock+1) >= datablock_end)
-		return NULL;
-		
-	newitem=*memblock;
-	(*memblock)++;
-	newitem->next=insert_point->next;
-	insert_point->next=newitem;
-	
-	newitem->info=*datablock;
-	(*datablock)++;
-	copy_info(newitem->info,info);
-	
-	return newitem;
-}
-
-/* Function: core_list_remove
-	Remove an item from the list.
-
-	Operation:
-	For a singly linked list, remove by copying the data from the next item 
-	over to the current cell, and unlinking the next item.
-
-	Note: 
-	since there is always a fake item at the end of the list, no need to check for NULL.
-
-	Returns:
-	Removed item.
-*/
-list_head *core_list_remove(list_head *item) {
-	list_data *tmp;
-	list_head *ret=item->next;
-	/* swap data pointers */
-	tmp=item->info;
-	item->info=ret->info;
-	ret->info=tmp;
-	/* and eliminate item */
-	item->next=item->next->next;
-	ret->next=NULL;
-	return ret;
-}
-
-/* Function: core_list_undo_remove
-	Undo a remove operation.
-
-	Operation:
-	Since we want each iteration of the benchmark to be exactly the same,
-	we need to be able to undo a remove. 
-	Link the removed item back into the list, and switch the info items.
-
-	Parameters:
-	item_removed - Return value from the <core_list_remove>
-	item_modified - List item that was modified during <core_list_remove>
-
-	Returns:
-	The item that was linked back to the list.
-	
-*/
-list_head *core_list_undo_remove(list_head *item_removed, list_head *item_modified) {
-	list_data *tmp;
-	/* swap data pointers */
-	tmp=item_removed->info;
-	item_removed->info=item_modified->info;
-	item_modified->info=tmp;
-	/* and insert item */
-	item_removed->next=item_modified->next;
-	item_modified->next=item_removed;
-	return item_removed;
-}
-
-/* Function: core_list_find
-	Find an item in the list
-
-	Operation:
-	Find an item by idx (if not 0) or specific data value
-
-	Parameters:
-	list - list head
-	info - idx or data to find
-
-	Returns:
-	Found item, or NULL if not found.
-*/
-list_head *core_list_find(list_head *list,list_data *info) {
-	if (info->idx>=0) {
-		while (list && (list->info->idx != info->idx))
-			list=list->next;
-		return list;
-	} else {
-		while (list && ((list->info->data16 & 0xff) != info->data16))
-			list=list->next;
-		return list;
-	}
-}
-/* Function: core_list_reverse
-	Reverse a list
-
-	Operation:
-	Rearrange the pointers so the list is reversed.
-
-	Parameters:
-	list - list head
-	info - idx or data to find
-
-	Returns:
-	Found item, or NULL if not found.
-*/
-
-list_head *core_list_reverse(list_head *list) {
-	list_head *next=NULL, *tmp;
-	while (list) {
-		tmp=list->next;
-		list->next=next;
-		next=list;
-		list=tmp;
-	}
-	return next;
-}
-/* Function: core_list_mergesort
-	Sort the list in place without recursion.
-
-	Description:
-	Use mergesort, as for linked list this is a realistic solution. 
-	Also, since this is aimed at embedded, care was taken to use iterative rather then recursive algorithm.
-	The sort can either return the list to original order (by idx) ,
-	or use the data item to invoke other other algorithms and change the order of the list.
-
-	Parameters:
-	list - list to be sorted.
-	cmp - cmp function to use
-
-	Returns:
-	New head of the list.
-
-	Note: 
-	We have a special header for the list that will always be first,
-	but the algorithm could theoretically modify where the list starts.
-
- */
-list_head *core_list_mergesort(list_head *list, list_cmp cmp, core_results *res) {
-    list_head *p, *q, *e, *tail;
-    ee_s32 insize, nmerges, psize, qsize, i;
-
-    insize = 1;
-
-    while (1) {
-        p = list;
-        list = NULL;
-        tail = NULL;
-
-        nmerges = 0;  /* count number of merges we do in this pass */
-
-        while (p) {
-            nmerges++;  /* there exists a merge to be done */
-            /* step `insize' places along from p */
-            q = p;
-            psize = 0;
-            for (i = 0; i < insize; i++) {
-                psize++;
-			    q = q->next;
-                if (!q) break;
-            }
-
-            /* if q hasn't fallen off end, we have two lists to merge */
-            qsize = insize;
-
-            /* now we have two lists; merge them */
-            while (psize > 0 || (qsize > 0 && q)) {
-
-				/* decide whether next element of merge comes from p or q */
-				if (psize == 0) {
-				    /* p is empty; e must come from q. */
-				    e = q; q = q->next; qsize--;
-				} else if (qsize == 0 || !q) {
-				    /* q is empty; e must come from p. */
-				    e = p; p = p->next; psize--;
-				} else if (cmp(p->info,q->info,res) <= 0) {
-				    /* First element of p is lower (or same); e must come from p. */
-				    e = p; p = p->next; psize--;
-				} else {
-				    /* First element of q is lower; e must come from q. */
-				    e = q; q = q->next; qsize--;
-				}
-
-		        /* add the next element to the merged list */
-				if (tail) {
-				    tail->next = e;
-				} else {
-				    list = e;
-				}
-				tail = e;
-	        }
-
-			/* now p has stepped `insize' places along, and q has too */
-			p = q;
-        }
-		
-	    tail->next = NULL;
-
-        /* If we have done only one merge, we're finished. */
-        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
-            return list;
-
-        /* Otherwise repeat, merging lists twice the size */
-        insize *= 2;
-    }
-#if COMPILER_REQUIRES_SORT_RETURN
-	return list;
-#endif
-}
diff --git a/tests/coremark/core_main.c b/tests/coremark/core_main.c
deleted file mode 100644
index c4145ec..0000000
--- a/tests/coremark/core_main.c
+++ /dev/null
@@ -1,356 +0,0 @@
-/*
-Author : Shay Gal-On, EEMBC
-
-This file is part of  EEMBC(R) and CoreMark(TM), which are Copyright (C) 2009 
-All rights reserved.                            
-
-EEMBC CoreMark Software is a product of EEMBC and is provided under the terms of the
-CoreMark License that is distributed with the official EEMBC COREMARK Software release. 
-If you received this EEMBC CoreMark Software without the accompanying CoreMark License, 
-you must discontinue use and download the official release from www.coremark.org.  
-
-Also, if you are publicly displaying scores generated from the EEMBC CoreMark software, 
-make sure that you are in compliance with Run and Reporting rules specified in the accompanying readme.txt file.
-
-EEMBC 
-4354 Town Center Blvd. Suite 114-200
-El Dorado Hills, CA, 95762 
-*/ 
-/* File: core_main.c
-	This file contains the framework to acquire a block of memory, seed initial parameters, tun t he benchmark and report the results.
-*/
-#include "coremark.h"
-
-/* Function: iterate
-	Run the benchmark for a specified number of iterations.
-
-	Operation:
-	For each type of benchmarked algorithm:
-		a - Initialize the data block for the algorithm.
-		b - Execute the algorithm N times.
-
-	Returns:
-	NULL.
-*/
-static ee_u16 list_known_crc[]   =      {(ee_u16)0xd4b0,(ee_u16)0x3340,(ee_u16)0x6a79,(ee_u16)0xe714,(ee_u16)0xe3c1};
-static ee_u16 matrix_known_crc[] =      {(ee_u16)0xbe52,(ee_u16)0x1199,(ee_u16)0x5608,(ee_u16)0x1fd7,(ee_u16)0x0747};
-static ee_u16 state_known_crc[]  =      {(ee_u16)0x5e47,(ee_u16)0x39bf,(ee_u16)0xe5a4,(ee_u16)0x8e3a,(ee_u16)0x8d84};
-void *iterate(void *pres) {
-	ee_u32 i;
-	ee_u16 crc;
-	core_results *res=(core_results *)pres;
-	ee_u32 iterations=res->iterations;
-	res->crc=0;
-	res->crclist=0;
-	res->crcmatrix=0;
-	res->crcstate=0;
-
-	for (i=0; i<iterations; i++) {
-		crc=core_bench_list(res,1);
-		res->crc=crcu16(crc,res->crc);
-		crc=core_bench_list(res,-1);
-		res->crc=crcu16(crc,res->crc);
-		if (i==0) res->crclist=res->crc;
-	}
-	return NULL;
-}
-
-#if (SEED_METHOD==SEED_ARG)
-ee_s32 get_seed_args(int i, int argc, char *argv[]);
-#define get_seed(x) (ee_s16)get_seed_args(x,argc,argv)
-#define get_seed_32(x) get_seed_args(x,argc,argv)
-#else /* via function or volatile */
-ee_s32 get_seed_32(int i);
-#define get_seed(x) (ee_s16)get_seed_32(x)
-#endif
-
-#if (MEM_METHOD==MEM_STATIC)
-ee_u8 static_memblk[TOTAL_DATA_SIZE];
-#endif
-char *mem_name[3] = {"Static","Heap","Stack"};
-/* Function: main
-	Main entry routine for the benchmark.
-	This function is responsible for the following steps:
-
-	1 - Initialize input seeds from a source that cannot be determined at compile time.
-	2 - Initialize memory block for use.
-	3 - Run and time the benchmark.
-	4 - Report results, testing the validity of the output if the seeds are known.
-
-	Arguments:
-	1 - first seed  : Any value
-	2 - second seed : Must be identical to first for iterations to be identical
-	3 - third seed  : Any value, should be at least an order of magnitude less then the input size, but bigger then 32.
-	4 - Iterations  : Special, if set to 0, iterations will be automatically determined such that the benchmark will run between 10 to 100 secs
-
-*/
-
-#if MAIN_HAS_NOARGC
-MAIN_RETURN_TYPE main(void) {
-	int argc=0;
-	char *argv[1];
-#else
-MAIN_RETURN_TYPE main(int argc, char *argv[]) {
-#endif
-	ee_u16 i,j=0,num_algorithms=0;
-	ee_s16 known_id=-1,total_errors=0;
-	ee_u16 seedcrc=0;
-	CORE_TICKS total_time;
-	core_results results[MULTITHREAD];
-#if (MEM_METHOD==MEM_STACK)
-	ee_u8 stack_memblock[TOTAL_DATA_SIZE*MULTITHREAD];
-#endif
-	/* first call any initializations needed */
-	portable_init(&(results[0].port), &argc, argv);
-	/* First some checks to make sure benchmark will run ok */
-	if (sizeof(struct list_head_s)>128) {
-		ee_printf("list_head structure too big for comparable data!\n");
-		return MAIN_RETURN_VAL;
-	}
-	results[0].seed1=get_seed(1);
-	results[0].seed2=get_seed(2);
-	results[0].seed3=get_seed(3);
-	results[0].iterations=get_seed_32(4);
-#if CORE_DEBUG
-	results[0].iterations=1;
-#endif
-	results[0].execs=get_seed_32(5);
-	if (results[0].execs==0) { /* if not supplied, execute all algorithms */
-		results[0].execs=ALL_ALGORITHMS_MASK;
-	}
-		/* put in some default values based on one seed only for easy testing */
-	if ((results[0].seed1==0) && (results[0].seed2==0) && (results[0].seed3==0)) { /* validation run */
-		results[0].seed1=0;
-		results[0].seed2=0;
-		results[0].seed3=0x66;
-	}
-	if ((results[0].seed1==1) && (results[0].seed2==0) && (results[0].seed3==0)) { /* perfromance run */
-		results[0].seed1=0x3415;
-		results[0].seed2=0x3415;
-		results[0].seed3=0x66;
-	}
-#if (MEM_METHOD==MEM_STATIC)
-	results[0].memblock[0]=(void *)static_memblk;
-	results[0].size=TOTAL_DATA_SIZE;
-	results[0].err=0;
-	#if (MULTITHREAD>1)
-	#error "Cannot use a static data area with multiple contexts!"
-	#endif
-#elif (MEM_METHOD==MEM_MALLOC)
-	for (i=0 ; i<MULTITHREAD; i++) {
-		ee_s32 malloc_override=get_seed(7);
-		if (malloc_override != 0) 
-			results[i].size=malloc_override;
-		else
-			results[i].size=TOTAL_DATA_SIZE;
-		results[i].memblock[0]=portable_malloc(results[i].size);
-		results[i].seed1=results[0].seed1;
-		results[i].seed2=results[0].seed2;
-		results[i].seed3=results[0].seed3;
-		results[i].err=0;
-		results[i].execs=results[0].execs;
-	}
-#elif (MEM_METHOD==MEM_STACK)
-	for (i=0 ; i<MULTITHREAD; i++) {
-		results[i].memblock[0]=stack_memblock+i*TOTAL_DATA_SIZE;
-		results[i].size=TOTAL_DATA_SIZE;
-		results[i].seed1=results[0].seed1;
-		results[i].seed2=results[0].seed2;
-		results[i].seed3=results[0].seed3;
-		results[i].err=0;
-		results[i].execs=results[0].execs;
-	}
-#else
-#error "Please define a way to initialize a memory block."
-#endif
-	/* Data init */ 
-	/* Find out how space much we have based on number of algorithms */
-	for (i=0; i<NUM_ALGORITHMS; i++) {
-		if ((1<<(ee_u32)i) & results[0].execs)
-			num_algorithms++;
-	}
-	for (i=0 ; i<MULTITHREAD; i++) 
-		results[i].size=results[i].size/num_algorithms;
-	/* Assign pointers */
-	for (i=0; i<NUM_ALGORITHMS; i++) {
-		ee_u32 ctx;
-		if ((1<<(ee_u32)i) & results[0].execs) {
-			for (ctx=0 ; ctx<MULTITHREAD; ctx++)
-				results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
-			j++;
-		}
-	}
-	/* call inits */
-	for (i=0 ; i<MULTITHREAD; i++) {
-		if (results[i].execs & ID_LIST) {
-			results[i].list=core_list_init(results[0].size,results[i].memblock[1],results[i].seed1);
-		}
-		if (results[i].execs & ID_MATRIX) {
-			core_init_matrix(results[0].size, results[i].memblock[2], (ee_s32)results[i].seed1 | (((ee_s32)results[i].seed2) << 16), &(results[i].mat) );
-		}
-		if (results[i].execs & ID_STATE) {
-			core_init_state(results[0].size,results[i].seed1,results[i].memblock[3]);
-		}
-	}
-	
-	/* automatically determine number of iterations if not set */
-	if (results[0].iterations==0) { 
-		secs_ret secs_passed=0;
-		ee_u32 divisor;
-		results[0].iterations=1;
-		while (secs_passed < (secs_ret)1) {
-			results[0].iterations*=10;
-			start_time();
-			iterate(&results[0]);
-			stop_time();
-			secs_passed=time_in_secs(get_time());
-		}
-		/* now we know it executes for at least 1 sec, set actual run time at about 10 secs */
-		divisor=(ee_u32)secs_passed;
-		if (divisor==0) /* some machines cast float to int as 0 since this conversion is not defined by ANSI, but we know at least one second passed */
-			divisor=1;
-		results[0].iterations*=1+10/divisor;
-	}
-	/* perform actual benchmark */
-	start_time();
-#if (MULTITHREAD>1)
-	if (default_num_contexts>MULTITHREAD) {
-		default_num_contexts=MULTITHREAD;
-	}
-	for (i=0 ; i<default_num_contexts; i++) {
-		results[i].iterations=results[0].iterations;
-		results[i].execs=results[0].execs;
-		core_start_parallel(&results[i]);
-	}
-	for (i=0 ; i<default_num_contexts; i++) {
-		core_stop_parallel(&results[i]);
-	}
-#else
-	iterate(&results[0]);
-#endif
-	stop_time();
-	total_time=get_time();
-	/* get a function of the input to report */
-	seedcrc=crc16(results[0].seed1,seedcrc);
-	seedcrc=crc16(results[0].seed2,seedcrc);
-	seedcrc=crc16(results[0].seed3,seedcrc);
-	seedcrc=crc16(results[0].size,seedcrc);
-	
-	switch (seedcrc) { /* test known output for common seeds */
-		case 0x8a02: /* seed1=0, seed2=0, seed3=0x66, size 2000 per algorithm */
-			known_id=0;
-			ee_printf("6k performance run parameters for coremark.\n");
-			break;
-		case 0x7b05: /*  seed1=0x3415, seed2=0x3415, seed3=0x66, size 2000 per algorithm */
-			known_id=1;
-			ee_printf("6k validation run parameters for coremark.\n");
-			break;
-		case 0x4eaf: /* seed1=0x8, seed2=0x8, seed3=0x8, size 400 per algorithm */
-			known_id=2;
-			ee_printf("Profile generation run parameters for coremark.\n");
-			break;
-		case 0xe9f5: /* seed1=0, seed2=0, seed3=0x66, size 666 per algorithm */
-			known_id=3;
-			ee_printf("2K performance run parameters for coremark.\n");
-			break;
-		case 0x18f2: /*  seed1=0x3415, seed2=0x3415, seed3=0x66, size 666 per algorithm */
-			known_id=4;
-			ee_printf("2K validation run parameters for coremark.\n");
-			break;
-		default:
-			total_errors=-1;
-			break;
-	}
-	if (known_id>=0) {
-		for (i=0 ; i<default_num_contexts; i++) {
-			results[i].err=0;
-			if ((results[i].execs & ID_LIST) && 
-				(results[i].crclist!=list_known_crc[known_id])) {
-				ee_printf("[%u]ERROR! list crc 0x%04x - should be 0x%04x\n",i,results[i].crclist,list_known_crc[known_id]);
-				results[i].err++;
-			}
-			if ((results[i].execs & ID_MATRIX) &&
-				(results[i].crcmatrix!=matrix_known_crc[known_id])) {
-				ee_printf("[%u]ERROR! matrix crc 0x%04x - should be 0x%04x\n",i,results[i].crcmatrix,matrix_known_crc[known_id]);
-				results[i].err++;
-			}
-			if ((results[i].execs & ID_STATE) &&
-				(results[i].crcstate!=state_known_crc[known_id])) {
-				ee_printf("[%u]ERROR! state crc 0x%04x - should be 0x%04x\n",i,results[i].crcstate,state_known_crc[known_id]);
-				results[i].err++;
-			}
-			total_errors+=results[i].err;
-		}
-	}
-	total_errors+=check_data_types();
-	/* and report results */
-	ee_printf("CoreMark Size    : %lu\n",(ee_u32)results[0].size);
-	ee_printf("Total ticks      : %lu\n",(ee_u32)total_time);
-#if HAS_FLOAT
-	ee_printf("Total time (secs): %f\n",time_in_secs(total_time));
-	if (time_in_secs(total_time) > 0)
-		ee_printf("Iterations/Sec   : %f\n",default_num_contexts*results[0].iterations/time_in_secs(total_time));
-#else 
-	ee_printf("Total time (secs): %d\n",time_in_secs(total_time));
-	if (time_in_secs(total_time) > 0)
-		ee_printf("Iterations/Sec   : %d\n",default_num_contexts*results[0].iterations/time_in_secs(total_time));
-#endif
-	if (time_in_secs(total_time) < 10) {
-		ee_printf("ERROR! Must execute for at least 10 secs for a valid result!\n");
-		total_errors++;
-	}
-
-	ee_printf("Iterations       : %lu\n",(ee_u32)default_num_contexts*results[0].iterations);
-	ee_printf("Compiler version : %s\n",COMPILER_VERSION);
-	ee_printf("Compiler flags   : %s\n",COMPILER_FLAGS);
-#if (MULTITHREAD>1)
-	ee_printf("Parallel %s : %d\n",PARALLEL_METHOD,default_num_contexts);
-#endif
-	ee_printf("Memory location  : %s\n",MEM_LOCATION);
-	/* output for verification */
-	ee_printf("seedcrc          : 0x%04x\n",seedcrc);
-	if (results[0].execs & ID_LIST)
-		for (i=0 ; i<default_num_contexts; i++) 
-			ee_printf("[%d]crclist       : 0x%04x\n",i,results[i].crclist);
-	if (results[0].execs & ID_MATRIX) 
-		for (i=0 ; i<default_num_contexts; i++) 
-			ee_printf("[%d]crcmatrix     : 0x%04x\n",i,results[i].crcmatrix);
-	if (results[0].execs & ID_STATE)
-		for (i=0 ; i<default_num_contexts; i++) 
-			ee_printf("[%d]crcstate      : 0x%04x\n",i,results[i].crcstate);
-	for (i=0 ; i<default_num_contexts; i++) 
-		ee_printf("[%d]crcfinal      : 0x%04x\n",i,results[i].crc);
-	if (total_errors==0) {
-		ee_printf("Correct operation validated. See readme.txt for run and reporting rules.\n");
-#if HAS_FLOAT
-		if (known_id==3) {
-			ee_printf("CoreMark 1.0 : %f / %s %s",default_num_contexts*results[0].iterations/time_in_secs(total_time),COMPILER_VERSION,COMPILER_FLAGS);
-#if defined(MEM_LOCATION) && !defined(MEM_LOCATION_UNSPEC)
-			ee_printf(" / %s",MEM_LOCATION);
-#else
-			ee_printf(" / %s",mem_name[MEM_METHOD]);
-#endif
-
-#if (MULTITHREAD>1)
-			ee_printf(" / %d:%s",default_num_contexts,PARALLEL_METHOD);
-#endif
-			ee_printf("\n");
-		}
-#endif
-	}
-	if (total_errors>0)
-		ee_printf("Errors detected\n");
-	if (total_errors<0)
-		ee_printf("Cannot validate operation for these seed values, please compare with results on a known platform.\n");
-
-#if (MEM_METHOD==MEM_MALLOC)
-	for (i=0 ; i<MULTITHREAD; i++) 
-		portable_free(results[i].memblock[0]);
-#endif
-	/* And last call any target specific code for finalizing */
-	portable_fini(&(results[0].port));
-
-	return MAIN_RETURN_VAL;	
-}
-
-
diff --git a/tests/coremark/core_matrix.c b/tests/coremark/core_matrix.c
deleted file mode 100644
index ab20e02..0000000
--- a/tests/coremark/core_matrix.c
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
-Author : Shay Gal-On, EEMBC
-
-This file is part of  EEMBC(R) and CoreMark(TM), which are Copyright (C) 2009 
-All rights reserved.                            
-
-EEMBC CoreMark Software is a product of EEMBC and is provided under the terms of the
-CoreMark License that is distributed with the official EEMBC COREMARK Software release. 
-If you received this EEMBC CoreMark Software without the accompanying CoreMark License, 
-you must discontinue use and download the official release from www.coremark.org.  
-
-Also, if you are publicly displaying scores generated from the EEMBC CoreMark software, 
-make sure that you are in compliance with Run and Reporting rules specified in the accompanying readme.txt file.
-
-EEMBC 
-4354 Town Center Blvd. Suite 114-200
-El Dorado Hills, CA, 95762 
-*/ 
-#include "coremark.h"
-/*
-Topic: Description
-	Matrix manipulation benchmark
-	
-	This very simple algorithm forms the basis of many more complex algorithms. 
-	
-	The tight inner loop is the focus of many optimizations (compiler as well as hardware based) 
-	and is thus relevant for embedded processing. 
-	
-	The total available data space will be divided to 3 parts:
-	NxN Matrix A - initialized with small values (upper 3/4 of the bits all zero).
-	NxN Matrix B - initialized with medium values (upper half of the bits all zero).
-	NxN Matrix C - used for the result.
-
-	The actual values for A and B must be derived based on input that is not available at compile time.
-*/
-ee_s16 matrix_test(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val);
-ee_s16 matrix_sum(ee_u32 N, MATRES *C, MATDAT clipval);
-void matrix_mul_const(ee_u32 N, MATRES *C, MATDAT *A, MATDAT val);
-void matrix_mul_vect(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B);
-void matrix_mul_matrix(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B);
-void matrix_mul_matrix_bitextract(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B);
-void matrix_add_const(ee_u32 N, MATDAT *A, MATDAT val);
-
-#define matrix_test_next(x) (x+1)
-#define matrix_clip(x,y) ((y) ? (x) & 0x0ff : (x) & 0x0ffff)
-#define matrix_big(x) (0xf000 | (x))
-#define bit_extract(x,from,to) (((x)>>(from)) & (~(0xffffffff << (to))))
-
-#if CORE_DEBUG
-void printmat(MATDAT *A, ee_u32 N, char *name) {
-	ee_u32 i,j;
-	ee_printf("Matrix %s [%dx%d]:\n",name,N,N);
-	for (i=0; i<N; i++) {
-		for (j=0; j<N; j++) {
-			if (j!=0)
-				ee_printf(",");
-			ee_printf("%d",A[i*N+j]);
-		}
-		ee_printf("\n");
-	}
-}
-void printmatC(MATRES *C, ee_u32 N, char *name) {
-	ee_u32 i,j;
-	ee_printf("Matrix %s [%dx%d]:\n",name,N,N);
-	for (i=0; i<N; i++) {
-		for (j=0; j<N; j++) {
-			if (j!=0)
-				ee_printf(",");
-			ee_printf("%d",C[i*N+j]);
-		}
-		ee_printf("\n");
-	}
-}
-#endif
-/* Function: core_bench_matrix
-	Benchmark function
-
-	Iterate <matrix_test> N times, 
-	changing the matrix values slightly by a constant amount each time.
-*/
-ee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc) {
-	ee_u32 N=p->N;
-	MATRES *C=p->C;
-	MATDAT *A=p->A;
-	MATDAT *B=p->B;
-	MATDAT val=(MATDAT)seed;
-
-	crc=crc16(matrix_test(N,C,A,B,val),crc);
-
-	return crc;
-}
-
-/* Function: matrix_test
-	Perform matrix manipulation.
-
-	Parameters:
-	N - Dimensions of the matrix.
-	C - memory for result matrix.
-	A - input matrix
-	B - operator matrix (not changed during operations)
-
-	Returns:
-	A CRC value that captures all results calculated in the function.
-	In particular, crc of the value calculated on the result matrix 
-	after each step by <matrix_sum>.
-
-	Operation:
-	
-	1 - Add a constant value to all elements of a matrix.
-	2 - Multiply a matrix by a constant.
-	3 - Multiply a matrix by a vector.
-	4 - Multiply a matrix by a matrix.
-	5 - Add a constant value to all elements of a matrix.
-
-	After the last step, matrix A is back to original contents.
-*/
-ee_s16 matrix_test(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val) {
-	ee_u16 crc=0;
-	MATDAT clipval=matrix_big(val);
-
-	matrix_add_const(N,A,val); /* make sure data changes  */
-#if CORE_DEBUG
-	printmat(A,N,"matrix_add_const");
-#endif
-	matrix_mul_const(N,C,A,val);
-	crc=crc16(matrix_sum(N,C,clipval),crc);
-#if CORE_DEBUG
-	printmatC(C,N,"matrix_mul_const");
-#endif
-	matrix_mul_vect(N,C,A,B);
-	crc=crc16(matrix_sum(N,C,clipval),crc);
-#if CORE_DEBUG
-	printmatC(C,N,"matrix_mul_vect");
-#endif
-	matrix_mul_matrix(N,C,A,B);
-	crc=crc16(matrix_sum(N,C,clipval),crc);
-#if CORE_DEBUG
-	printmatC(C,N,"matrix_mul_matrix");
-#endif
-	matrix_mul_matrix_bitextract(N,C,A,B);
-	crc=crc16(matrix_sum(N,C,clipval),crc);
-#if CORE_DEBUG
-	printmatC(C,N,"matrix_mul_matrix_bitextract");
-#endif
-	
-	matrix_add_const(N,A,-val); /* return matrix to initial value */
-	return crc;
-}
-
-/* Function : matrix_init
-	Initialize the memory block for matrix benchmarking.
-
-	Parameters:
-	blksize - Size of memory to be initialized.
-	memblk - Pointer to memory block.
-	seed - Actual values chosen depend on the seed parameter.
-	p - pointers to <mat_params> containing initialized matrixes.
-
-	Returns:
-	Matrix dimensions.
-	
-	Note:
-	The seed parameter MUST be supplied from a source that cannot be determined at compile time
-*/
-ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p) {
-	ee_u32 N=0;
-	MATDAT *A;
-	MATDAT *B;
-	ee_s32 order=1;
-	MATDAT val;
-	ee_u32 i=0,j=0;
-	if (seed==0)
-		seed=1;
-	while (j<blksize) {
-		i++;
-		j=i*i*2*4;		
-	}
-	N=i-1;
-	A=(MATDAT *)align_mem(memblk);
-	B=A+N*N;
-
-	for (i=0; i<N; i++) {
-		for (j=0; j<N; j++) {
-			seed = ( ( order * seed ) % 65536 );
-			val = (seed + order);
-			val=matrix_clip(val,0);
-			B[i*N+j] = val;
-			val =  (val + order);
-			val=matrix_clip(val,1);
-			A[i*N+j] = val;
-			order++;
-		}
-	}
-
-	p->A=A;
-	p->B=B;
-	p->C=(MATRES *)align_mem(B+N*N);
-	p->N=N;
-#if CORE_DEBUG
-	printmat(A,N,"A");
-	printmat(B,N,"B");
-#endif
-	return N;
-}
-
-/* Function: matrix_sum
-	Calculate a function that depends on the values of elements in the matrix.
-
-	For each element, accumulate into a temporary variable.
-	
-	As long as this value is under the parameter clipval, 
-	add 1 to the result if the element is bigger then the previous.
-	
-	Otherwise, reset the accumulator and add 10 to the result.
-*/
-ee_s16 matrix_sum(ee_u32 N, MATRES *C, MATDAT clipval) {
-	MATRES tmp=0,prev=0,cur=0;
-	ee_s16 ret=0;
-	ee_u32 i,j;
-	for (i=0; i<N; i++) {
-		for (j=0; j<N; j++) {
-			cur=C[i*N+j];
-			tmp+=cur;
-			if (tmp>clipval) {
-				ret+=10;
-				tmp=0;
-			} else {
-				ret += (cur>prev) ? 1 : 0;
-			}
-			prev=cur;
-		}
-	}
-	return ret;
-}
-
-/* Function: matrix_mul_const
-	Multiply a matrix by a constant.
-	This could be used as a scaler for instance.
-*/
-void matrix_mul_const(ee_u32 N, MATRES *C, MATDAT *A, MATDAT val) {
-	ee_u32 i,j;
-	for (i=0; i<N; i++) {
-		for (j=0; j<N; j++) {
-			C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
-		}
-	}
-}
-
-/* Function: matrix_add_const
-	Add a constant value to all elements of a matrix.
-*/
-void matrix_add_const(ee_u32 N, MATDAT *A, MATDAT val) {
-	ee_u32 i,j;
-	for (i=0; i<N; i++) {
-		for (j=0; j<N; j++) {
-			A[i*N+j] += val;
-		}
-	}
-}
-
-/* Function: matrix_mul_vect
-	Multiply a matrix by a vector.
-	This is common in many simple filters (e.g. fir where a vector of coefficients is applied to the matrix.)
-*/
-void matrix_mul_vect(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {
-	ee_u32 i,j;
-	for (i=0; i<N; i++) {
-		C[i]=0;
-		for (j=0; j<N; j++) {
-			C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
-		}
-	}
-}
-
-/* Function: matrix_mul_matrix
-	Multiply a matrix by a matrix.
-	Basic code is used in many algorithms, mostly with minor changes such as scaling.
-*/
-void matrix_mul_matrix(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {
-	ee_u32 i,j,k;
-	for (i=0; i<N; i++) {
-		for (j=0; j<N; j++) {
-			C[i*N+j]=0;
-			for(k=0;k<N;k++)
-			{
-				C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
-			}
-		}
-	}
-}
-
-/* Function: matrix_mul_matrix_bitextract
-	Multiply a matrix by a matrix, and extract some bits from the result.
-	Basic code is used in many algorithms, mostly with minor changes such as scaling.
-*/
-void matrix_mul_matrix_bitextract(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {
-	ee_u32 i,j,k;
-	for (i=0; i<N; i++) {
-		for (j=0; j<N; j++) {
-			C[i*N+j]=0;
-			for(k=0;k<N;k++)
-			{
-				MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
-				C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
-			}
-		}
-	}
-}
diff --git a/tests/coremark/core_portme.c b/tests/coremark/core_portme.c
deleted file mode 100755
index 2f07490..0000000
--- a/tests/coremark/core_portme.c
+++ /dev/null
@@ -1,327 +0,0 @@
-/* 
-	File: core_portme.c
-*/
-/*
-	Author : Shay Gal-On, EEMBC
-	Legal : TODO!
-*/ 
-#include <stdio.h>
-#include <stdlib.h>
-#include "coremark.h"
-#if CALLGRIND_RUN
-#include <valgrind/callgrind.h>
-#endif
-
-#if (MEM_METHOD==MEM_MALLOC)
-#include <malloc.h>
-/* Function: portable_malloc
-	Provide malloc() functionality in a platform specific way.
-*/
-void *portable_malloc(size_t size) {
-	return malloc(size);
-}
-/* Function: portable_free
-	Provide free() functionality in a platform specific way.
-*/
-void portable_free(void *p) {
-	free(p);
-}
-#else
-void *portable_malloc(size_t size) {
-	return NULL;
-}
-void portable_free(void *p) {
-	p=NULL;
-}
-#endif
-
-#if (SEED_METHOD==SEED_VOLATILE)
-#if VALIDATION_RUN
-	volatile ee_s32 seed1_volatile=0x3415;
-	volatile ee_s32 seed2_volatile=0x3415;
-	volatile ee_s32 seed3_volatile=0x66;
-#endif
-#if PERFORMANCE_RUN
-	volatile ee_s32 seed1_volatile=0x0;
-	volatile ee_s32 seed2_volatile=0x0;
-	volatile ee_s32 seed3_volatile=0x66;
-#endif
-#if PROFILE_RUN
-	volatile ee_s32 seed1_volatile=0x8;
-	volatile ee_s32 seed2_volatile=0x8;
-	volatile ee_s32 seed3_volatile=0x8;
-#endif
-	volatile ee_s32 seed4_volatile=ITERATIONS;
-	volatile ee_s32 seed5_volatile=0;
-#endif
-/* Porting: Timing functions
-	How to capture time and convert to seconds must be ported to whatever is supported by the platform.
-	e.g. Read value from on board RTC, read value from cpu clock cycles performance counter etc. 
-	Sample implementation for standard time.h and windows.h definitions included.
-*/
-/* Define: TIMER_RES_DIVIDER
-	Divider to trade off timer resolution and total time that can be measured.
-
-	Use lower values to increase resolution, but make sure that overflow does not occur.
-	If there are issues with the return value overflowing, increase this value.
-	*/
-#if USE_CLOCK
-	#define NSECS_PER_SEC CLOCKS_PER_SEC
-	#define EE_TIMER_TICKER_RATE 1000
-	#define CORETIMETYPE clock_t 
-	#define GETMYTIME(_t) (*_t=clock())
-	#define MYTIMEDIFF(fin,ini) ((fin)-(ini))
-	#define TIMER_RES_DIVIDER 1
-	#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif defined(_MSC_VER)
-	#define NSECS_PER_SEC 10000000
-	#define EE_TIMER_TICKER_RATE 1000
-	#define CORETIMETYPE FILETIME
-	#define GETMYTIME(_t) GetSystemTimeAsFileTime(_t)
-	#define MYTIMEDIFF(fin,ini) (((*(__int64*)&fin)-(*(__int64*)&ini))/TIMER_RES_DIVIDER)
-	/* setting to millisces resolution by default with MSDEV */
-	#ifndef TIMER_RES_DIVIDER
-	#define TIMER_RES_DIVIDER 1000
-	#endif
-	#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif HAS_TIME_H
-	#define NSECS_PER_SEC 1000000000
-	#define EE_TIMER_TICKER_RATE 1000
-	#define CORETIMETYPE struct timespec 
-	#define GETMYTIME(_t) clock_gettime(CLOCK_REALTIME,_t)
-	#define MYTIMEDIFF(fin,ini) ((fin.tv_sec-ini.tv_sec)*(NSECS_PER_SEC/TIMER_RES_DIVIDER)+(fin.tv_nsec-ini.tv_nsec)/TIMER_RES_DIVIDER)
-	/* setting to 1/1000 of a second resolution by default with linux */
-	#ifndef TIMER_RES_DIVIDER
-	#define TIMER_RES_DIVIDER 1000000
-	#endif
-	#define SAMPLE_TIME_IMPLEMENTATION 1
-#else
-	#define SAMPLE_TIME_IMPLEMENTATION 0
-#endif
-#define EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)
-
-#if SAMPLE_TIME_IMPLEMENTATION
-/** Define Host specific (POSIX), or target specific global time variables. */
-static CORETIMETYPE start_time_val, stop_time_val;
-
-/* Function: start_time
-	This function will be called right before starting the timed portion of the benchmark.
-
-	Implementation may be capturing a system timer (as implemented in the example code) 
-	or zeroing some system parameters - e.g. setting the cpu clocks cycles to 0.
-*/
-void start_time(void) {
-	GETMYTIME(&start_time_val );      
-#if CALLGRIND_RUN
-	CALLGRIND_START_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3");/*1 */
-#endif
-}
-/* Function: stop_time
-	This function will be called right after ending the timed portion of the benchmark.
-
-	Implementation may be capturing a system timer (as implemented in the example code) 
-	or other system parameters - e.g. reading the current value of cpu cycles counter.
-*/
-void stop_time(void) {
-#if CALLGRIND_RUN
-	 CALLGRIND_STOP_INSTRUMENTATION 
-#endif
-#if MICA
-    asm volatile("int3");/*1 */
-#endif
-	GETMYTIME(&stop_time_val );      
-}
-/* Function: get_time
-	Return an abstract "ticks" number that signifies time on the system.
-	
-	Actual value returned may be cpu cycles, milliseconds or any other value,
-	as long as it can be converted to seconds by <time_in_secs>.
-	This methodology is taken to accomodate any hardware or simulated platform.
-	The sample implementation returns millisecs by default, 
-	and the resolution is controlled by <TIMER_RES_DIVIDER>
-*/
-CORE_TICKS get_time(void) {
-	CORE_TICKS elapsed=(CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
-	return elapsed;
-}
-/* Function: time_in_secs
-	Convert the value returned by get_time to seconds.
-
-	The <secs_ret> type is used to accomodate systems with no support for floating point.
-	Default implementation implemented by the EE_TICKS_PER_SEC macro above.
-*/
-secs_ret time_in_secs(CORE_TICKS ticks) {
-	secs_ret retval=((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
-	return retval;
-}
-#else 
-#error "Please implement timing functionality in core_portme.c"
-#endif /* SAMPLE_TIME_IMPLEMENTATION */
-
-ee_u32 default_num_contexts=MULTITHREAD;
-
-/* Function: portable_init
-	Target specific initialization code 
-	Test for some common mistakes.
-*/
-void portable_init(core_portable *p, int *argc, char *argv[])
-{
-#if PRINT_ARGS
-	int i;
-	for (i=0; i<*argc; i++) {
-		ee_printf("Arg[%d]=%s\n",i,argv[i]);
-	}
-#endif
-	if (sizeof(ee_ptr_int) != sizeof(ee_u8 *)) {
-		ee_printf("ERROR! Please define ee_ptr_int to a type that holds a pointer!\n");
-	}
-	if (sizeof(ee_u32) != 4) {
-		ee_printf("ERROR! Please define ee_u32 to a 32b unsigned type!\n");
-	}
-#if (MAIN_HAS_NOARGC && (SEED_METHOD==SEED_ARG))
-	ee_printf("ERROR! Main has no argc, but SEED_METHOD defined to SEED_ARG!\n");
-#endif
-	
-#if (MULTITHREAD>1) && (SEED_METHOD==SEED_ARG)
-	{
-		int nargs=*argc,i;
-		if ((nargs>1) && (*argv[1]=='M')) {
-			default_num_contexts=parseval(argv[1]+1);
-			if (default_num_contexts>MULTITHREAD)
-				default_num_contexts=MULTITHREAD;
-			/* Shift args since first arg is directed to the portable part and not to coremark main */
-			--nargs;
-			for (i=1; i<nargs; i++)
-				argv[i]=argv[i+1];
-			*argc=nargs;
-		}
-	}
-#endif /* sample of potential platform specific init via command line, reset the number of contexts being used if first argument is M<n>*/
-	p->portable_id=1;
-}
-/* Function: portable_fini
-	Target specific final code 
-*/
-void portable_fini(core_portable *p)
-{
-	p->portable_id=0;
-}
-
-#if (MULTITHREAD>1)
-
-/* Function: core_start_parallel
-	Start benchmarking in a parallel context.
-	
-	Three implementations are provided, one using pthreads, one using fork and shared mem, and one using fork and sockets.
-	Other implementations using MCAPI or other standards can easily be devised.
-*/
-/* Function: core_stop_parallel
-	Stop a parallel context execution of coremark, and gather the results.
-	
-	Three implementations are provided, one using pthreads, one using fork and shared mem, and one using fork and sockets.
-	Other implementations using MCAPI or other standards can easily be devised.
-*/
-#if USE_PTHREAD
-ee_u8 core_start_parallel(core_results *res) {
-	return (ee_u8)pthread_create(&(res->port.thread),NULL,iterate,(void *)res);
-}
-ee_u8 core_stop_parallel(core_results *res) {
-	void *retval;
-	return (ee_u8)pthread_join(res->port.thread,&retval);
-}
-#elif USE_FORK
-static int key_id=0;
-ee_u8 core_start_parallel(core_results *res) {
-	key_t key=4321+key_id;
-	key_id++;
-	res->port.pid=fork();
-	res->port.shmid=shmget(key, 8, IPC_CREAT | 0666);
-	if (res->port.shmid<0) {
-		ee_printf("ERROR in shmget!\n");
-	}
-	if (res->port.pid==0) {
-		iterate(res);
-		res->port.shm=shmat(res->port.shmid, NULL, 0);
-		/* copy the validation values to the shared memory area  and quit*/
-		if (res->port.shm == (char *) -1) {
-			ee_printf("ERROR in child shmat!\n");
-		} else {
-			memcpy(res->port.shm,&(res->crc),8);
-			shmdt(res->port.shm);
-		}
-		exit(0);
-	}
-	return 1;
-}
-ee_u8 core_stop_parallel(core_results *res) {
-	int status;
-	pid_t wpid = waitpid(res->port.pid,&status,WUNTRACED);
-	if (wpid != res->port.pid) {
-		ee_printf("ERROR waiting for child.\n");
-		if (errno == ECHILD) ee_printf("errno=No such child %d\n",res->port.pid);
-		if (errno == EINTR) ee_printf("errno=Interrupted\n");
-		return 0;
-	}
-	/* after process is done, get the values from the shared memory area */
-	res->port.shm=shmat(res->port.shmid, NULL, 0);
-	if (res->port.shm == (char *) -1) {
-		ee_printf("ERROR in parent shmat!\n");
-		return 0;
-	} 
-	memcpy(&(res->crc),res->port.shm,8);
-	shmdt(res->port.shm);
-	return 1;
-}
-#elif USE_SOCKET
-static int key_id=0;
-ee_u8 core_start_parallel(core_results *res) {
-	int bound, buffer_length=8;
-	res->port.sa.sin_family = AF_INET;
-	res->port.sa.sin_addr.s_addr = htonl(0x7F000001);
-	res->port.sa.sin_port = htons(7654+key_id);
-	key_id++;
-	res->port.pid=fork();
-	if (res->port.pid==0) { /* benchmark child */
-		iterate(res);
-		res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-		if (-1 == res->port.sock) /* if socket failed to initialize, exit */   {
-			ee_printf("Error Creating Socket");
-		} else {
-			int bytes_sent = sendto(res->port.sock, &(res->crc), buffer_length, 0,(struct sockaddr*)&(res->port.sa), sizeof (struct sockaddr_in));
-			if (bytes_sent < 0)
-				ee_printf("Error sending packet: %s\n", strerror(errno));
-			close(res->port.sock); /* close the socket */
-		}
-		exit(0);
-	} 
-	/* parent process, open the socket */
-	res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-	bound = bind(res->port.sock,(struct sockaddr*)&(res->port.sa), sizeof(struct sockaddr));
-	if (bound < 0)
-		ee_printf("bind(): %s\n",strerror(errno));
-	return 1;
-}
-ee_u8 core_stop_parallel(core_results *res) {
-	int status;
-	int fromlen=sizeof(struct sockaddr);
-	int recsize = recvfrom(res->port.sock, &(res->crc), 8, 0, (struct sockaddr*)&(res->port.sa), &fromlen);
-	if (recsize < 0) {
-		ee_printf("Error in receive: %s\n", strerror(errno));
-		return 0;
-	}
-	pid_t wpid = waitpid(res->port.pid,&status,WUNTRACED);
-	if (wpid != res->port.pid) {
-		ee_printf("ERROR waiting for child.\n");
-		if (errno == ECHILD) ee_printf("errno=No such child %d\n",res->port.pid);
-		if (errno == EINTR) ee_printf("errno=Interrupted\n");
-		return 0;
-	}
-	return 1;
-}
-#else /* no standard multicore implementation */
-#error "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* multithread implementations */
-#endif
diff --git a/tests/coremark/core_portme.h b/tests/coremark/core_portme.h
deleted file mode 100755
index a7642bc..0000000
--- a/tests/coremark/core_portme.h
+++ /dev/null
@@ -1,281 +0,0 @@
-/* File: core_portme.h */
-
-/*
-	Author : Shay Gal-On, EEMBC
-	Legal : TODO!
-*/ 
-/* Topic: Description
-	This file contains configuration constants required to execute on different platforms
-*/
-#ifndef CORE_PORTME_H
-#define CORE_PORTME_H
-/************************/
-/* Data types and settings */
-/************************/
-/* Configuration: HAS_FLOAT 
-	Define to 1 if the platform supports floating point.
-*/
-#ifndef HAS_FLOAT 
-#define HAS_FLOAT 1
-#endif
-/* Configuration: HAS_TIME_H
-	Define to 1 if platform has the time.h header file,
-	and implementation of functions thereof.
-*/
-#ifndef HAS_TIME_H
-#define HAS_TIME_H 1
-#endif
-/* Configuration: USE_CLOCK
-	Define to 1 if platform has the time.h header file,
-	and implementation of functions thereof.
-*/
-#ifndef USE_CLOCK
-#define USE_CLOCK 0
-#endif
-/* Configuration: HAS_STDIO
-	Define to 1 if the platform has stdio.h.
-*/
-#ifndef HAS_STDIO
-#define HAS_STDIO 1
-#endif
-/* Configuration: HAS_PRINTF
-	Define to 1 if the platform has stdio.h and implements the printf function.
-*/
-#ifndef HAS_PRINTF
-#define HAS_PRINTF 1
-#endif
-
-/* Configuration: CORE_TICKS
-	Define type of return from the timing functions.
- */
-#if defined(_MSC_VER)
-#include <windows.h>
-typedef size_t CORE_TICKS;
-#elif HAS_TIME_H
-#include <time.h>
-typedef clock_t CORE_TICKS;
-#else
-#error "Please define type of CORE_TICKS and implement start_time, end_time get_time and time_in_secs functions!"
-#endif
-
-/* Definitions: COMPILER_VERSION, COMPILER_FLAGS, MEM_LOCATION
-	Initialize these strings per platform
-*/
-#ifndef COMPILER_VERSION 
- #ifdef __GNUC__
- #define COMPILER_VERSION "GCC"__VERSION__
- #else
- #define COMPILER_VERSION "Please put compiler version here (e.g. gcc 4.1)"
- #endif
-#endif
-#ifndef COMPILER_FLAGS 
- #define COMPILER_FLAGS FLAGS_STR /* "Please put compiler flags here (e.g. -o3)" */
-#endif
-#ifndef MEM_LOCATION 
- #define MEM_LOCATION "Please put data memory location here\n\t\t\t(e.g. code in flash, data on heap etc)"
- #define MEM_LOCATION_UNSPEC 1
-#endif
-
-/* Data Types:
-	To avoid compiler issues, define the data types that need ot be used for 8b, 16b and 32b in <core_portme.h>.
-	
-	*Imprtant*:
-	ee_ptr_int needs to be the data type used to hold pointers, otherwise coremark may fail!!!
-*/
-typedef signed short ee_s16;
-typedef unsigned short ee_u16;
-typedef signed int ee_s32;
-typedef double ee_f32;
-typedef unsigned char ee_u8;
-typedef unsigned int ee_u32;
-typedef ee_u32 ee_ptr_int;
-typedef size_t ee_size_t;
-/* align_mem:
-	This macro is used to align an offset to point to a 32b value. It is used in the Matrix algorithm to initialize the input memory blocks.
-*/
-#define align_mem(x) (void *)(4 + (((ee_ptr_int)(x) - 1) & ~3))
-
-/* Configuration: SEED_METHOD
-	Defines method to get seed values that cannot be computed at compile time.
-	
-	Valid values:
-	SEED_ARG - from command line.
-	SEED_FUNC - from a system function.
-	SEED_VOLATILE - from volatile variables.
-*/
-#ifndef SEED_METHOD
-#define SEED_METHOD SEED_ARG
-#endif
-
-/* Configuration: MEM_METHOD
-	Defines method to get a block of memry.
-	
-	Valid values:
-	MEM_MALLOC - for platforms that implement malloc and have malloc.h.
-	MEM_STATIC - to use a static memory array.
-	MEM_STACK - to allocate the data block on the stack (NYI).
-*/
-#ifndef MEM_METHOD
-#define MEM_METHOD MEM_MALLOC
-#endif
-
-/* Configuration: MULTITHREAD
-	Define for parallel execution 
-	
-	Valid values:
-	1 - only one context (default).
-	N>1 - will execute N copies in parallel.
-	
-	Note: 
-	If this flag is defined to more then 1, an implementation for launching parallel contexts must be defined.
-	
-	Two sample implementations are provided. Use <USE_PTHREAD> or <USE_FORK> to enable them.
-	
-	It is valid to have a different implementation of <core_start_parallel> and <core_end_parallel> in <core_portme.c>,
-	to fit a particular architecture. 
-*/
-#ifndef MULTITHREAD
-#define MULTITHREAD 1
-#endif
-
-/* Configuration: USE_PTHREAD
-	Sample implementation for launching parallel contexts 
-	This implementation uses pthread_thread_create and pthread_join.
-	
-	Valid values:
-	0 - Do not use pthreads API.
-	1 - Use pthreads API
-	
-	Note: 
-	This flag only matters if MULTITHREAD has been defined to a value greater then 1.
-*/
-#ifndef USE_PTHREAD
-#define USE_PTHREAD 0
-#endif
-
-/* Configuration: USE_FORK
-	Sample implementation for launching parallel contexts 
-	This implementation uses fork, waitpid, shmget,shmat and shmdt.
-	
-	Valid values:
-	0 - Do not use fork API.
-	1 - Use fork API
-	
-	Note: 
-	This flag only matters if MULTITHREAD has been defined to a value greater then 1.
-*/
-#ifndef USE_FORK
-#define USE_FORK 0
-#endif
-
-/* Configuration: USE_SOCKET
-	Sample implementation for launching parallel contexts 
-	This implementation uses fork, socket, sendto and recvfrom
-	
-	Valid values:
-	0 - Do not use fork and sockets API.
-	1 - Use fork and sockets API
-	
-	Note: 
-	This flag only matters if MULTITHREAD has been defined to a value greater then 1.
-*/
-#ifndef USE_SOCKET
-#define USE_SOCKET 0
-#endif
-
-/* Configuration: MAIN_HAS_NOARGC
-	Needed if platform does not support getting arguments to main. 
-	
-	Valid values:
-	0 - argc/argv to main is supported
-	1 - argc/argv to main is not supported
-*/
-#ifndef MAIN_HAS_NOARGC 
-#define MAIN_HAS_NOARGC 0
-#endif
-
-/* Configuration: MAIN_HAS_NORETURN
-	Needed if platform does not support returning a value from main. 
-	
-	Valid values:
-	0 - main returns an int, and return value will be 0.
-	1 - platform does not support returning a value from main
-*/
-#ifndef MAIN_HAS_NORETURN
-#define MAIN_HAS_NORETURN 0
-#endif
-
-/* Variable: default_num_contexts
-	Number of contexts to spawn in multicore context.
-	Override this global value to change number of contexts used.
-	
-	Note:
-	This value may not be set higher then the <MULTITHREAD> define.
-	
-	To experiment, you can set the <MULTITHREAD> define to the highest value expected, and use argc/argv in the <portable_init> to set this value from the command line.
-*/
-extern ee_u32 default_num_contexts;
-
-#if (MULTITHREAD>1)
-#if USE_PTHREAD
-	#include <pthread.h>
-	#define PARALLEL_METHOD "PThreads"
-#elif USE_FORK
-	#include <unistd.h>
-	#include <errno.h>
-	#include <sys/wait.h>
-	#include <sys/shm.h>
-	#include <string.h> /* for memcpy */
-	#define PARALLEL_METHOD "Fork"
-#elif USE_SOCKET
-	#include <sys/types.h>
-	#include <sys/socket.h>
-	#include <netinet/in.h>
-	#include <arpa/inet.h>
-	#include <sys/wait.h>
-	#include <stdio.h>
-	#include <stdlib.h>
-	#include <string.h>
-	#include <unistd.h>
-	#include <errno.h>
-	#define PARALLEL_METHOD "Sockets"
-#else
-	#define PARALLEL_METHOD "Proprietary"
-	#error "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD > 1 */
-
-typedef struct CORE_PORTABLE_S {
-#if (MULTITHREAD>1)
-	#if USE_PTHREAD
-	pthread_t thread;
-	#elif USE_FORK
-	pid_t pid;
-	int shmid;
-	void *shm;
-	#elif USE_SOCKET
-	pid_t pid;
-	int sock;
-	struct sockaddr_in sa;
-	#endif /* Method for multithreading */
-#endif /* MULTITHREAD>1 */
-	ee_u8	portable_id;
-} core_portable;
-
-/* target specific init/fini */
-void portable_init(core_portable *p, int *argc, char *argv[]);
-void portable_fini(core_portable *p);
-
-#if (SEED_METHOD==SEED_VOLATILE)
- #if (VALIDATION_RUN || PERFORMANCE_RUN || PROFILE_RUN)
-  #define RUN_TYPE_FLAG 1
- #else
-  #if (TOTAL_DATA_SIZE==1200)
-   #define PROFILE_RUN 1
-  #else
-   #define PERFORMANCE_RUN 1
-  #endif
- #endif
-#endif /* SEED_METHOD==SEED_VOLATILE */
-
-#endif /* CORE_PORTME_H */
diff --git a/tests/coremark/core_state.c b/tests/coremark/core_state.c
deleted file mode 100644
index 2cb02a9..0000000
--- a/tests/coremark/core_state.c
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
-Author : Shay Gal-On, EEMBC
-
-This file is part of  EEMBC(R) and CoreMark(TM), which are Copyright (C) 2009 
-All rights reserved.                            
-
-EEMBC CoreMark Software is a product of EEMBC and is provided under the terms of the
-CoreMark License that is distributed with the official EEMBC COREMARK Software release. 
-If you received this EEMBC CoreMark Software without the accompanying CoreMark License, 
-you must discontinue use and download the official release from www.coremark.org.  
-
-Also, if you are publicly displaying scores generated from the EEMBC CoreMark software, 
-make sure that you are in compliance with Run and Reporting rules specified in the accompanying readme.txt file.
-
-EEMBC 
-4354 Town Center Blvd. Suite 114-200
-El Dorado Hills, CA, 95762 
-*/ 
-#include "coremark.h"
-/* local functions */
-enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count);
-
-/*
-Topic: Description
-	Simple state machines like this one are used in many embedded products.
-	
-	For more complex state machines, sometimes a state transition table implementation is used instead, 
-	trading speed of direct coding for ease of maintenance.
-	
-	Since the main goal of using a state machine in CoreMark is to excercise the switch/if behaviour,
-	we are using a small moore machine. 
-	
-	In particular, this machine tests type of string input,
-	trying to determine whether the input is a number or something else.
-	(see core_state.png).
-*/
-
-/* Function: core_bench_state
-	Benchmark function
-
-	Go over the input twice, once direct, and once after introducing some corruption. 
-*/
-ee_u16 core_bench_state(ee_u32 blksize, ee_u8 *memblock, 
-		ee_s16 seed1, ee_s16 seed2, ee_s16 step, ee_u16 crc) 
-{
-	ee_u32 final_counts[NUM_CORE_STATES];
-	ee_u32 track_counts[NUM_CORE_STATES];
-	ee_u8 *p=memblock;
-	ee_u32 i;
-
-
-#if CORE_DEBUG
-	ee_printf("State Bench: %d,%d,%d,%04x\n",seed1,seed2,step,crc);
-#endif
-	for (i=0; i<NUM_CORE_STATES; i++) {
-		final_counts[i]=track_counts[i]=0;
-	}
-	/* run the state machine over the input */
-	while (*p!=0) {
-		enum CORE_STATE fstate=core_state_transition(&p,track_counts);
-		final_counts[fstate]++;
-#if CORE_DEBUG
-	ee_printf("%d,",fstate);
-	}
-	ee_printf("\n");
-#else
-	}
-#endif
-	p=memblock;
-	while (p < (memblock+blksize)) { /* insert some corruption */
-		if (*p!=',')
-			*p^=(ee_u8)seed1;
-		p+=step;
-	}
-	p=memblock;
-	/* run the state machine over the input again */
-	while (*p!=0) {
-		enum CORE_STATE fstate=core_state_transition(&p,track_counts);
-		final_counts[fstate]++;
-#if CORE_DEBUG
-	ee_printf("%d,",fstate);
-	}
-	ee_printf("\n");
-#else
-	}
-#endif
-	p=memblock;
-	while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
-		if (*p!=',')
-			*p^=(ee_u8)seed2;
-		p+=step;
-	}
-	/* end timing */
-	for (i=0; i<NUM_CORE_STATES; i++) {
-		crc=crcu32(final_counts[i],crc);
-		crc=crcu32(track_counts[i],crc);
-	}
-	return crc;
-}
-
-/* Default initialization patterns */
-static ee_u8 *intpat[4]  ={(ee_u8 *)"5012",(ee_u8 *)"1234",(ee_u8 *)"-874",(ee_u8 *)"+122"};
-static ee_u8 *floatpat[4]={(ee_u8 *)"35.54400",(ee_u8 *)".1234500",(ee_u8 *)"-110.700",(ee_u8 *)"+0.64400"};
-static ee_u8 *scipat[4]  ={(ee_u8 *)"5.500e+3",(ee_u8 *)"-.123e-2",(ee_u8 *)"-87e+832",(ee_u8 *)"+0.6e-12"};
-static ee_u8 *errpat[4]  ={(ee_u8 *)"T0.3e-1F",(ee_u8 *)"-T.T++Tq",(ee_u8 *)"1T3.4e4z",(ee_u8 *)"34.0e-T^"};
-
-/* Function: core_init_state
-	Initialize the input data for the state machine.
-
-	Populate the input with several predetermined strings, interspersed.
-	Actual patterns chosen depend on the seed parameter.
-	
-	Note:
-	The seed parameter MUST be supplied from a source that cannot be determined at compile time
-*/
-void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p) {
-	ee_u32 total=0,next=0,i;
-	ee_u8 *buf=0;
-#if CORE_DEBUG
-	ee_u8 *start=p;
-	ee_printf("State: %d,%d\n",size,seed);
-#endif
-	size--;
-	next=0;
-	while ((total+next+1)<size) {
-		if (next>0) {
-			for(i=0;i<next;i++)
-				*(p+total+i)=buf[i];
-			*(p+total+i)=',';
-			total+=next+1;
-		}
-		seed++;
-		switch (seed & 0x7) {
-			case 0: /* int */
-			case 1: /* int */
-			case 2: /* int */
-				buf=intpat[(seed>>3) & 0x3];
-				next=4;
-			break;
-			case 3: /* float */
-			case 4: /* float */
-				buf=floatpat[(seed>>3) & 0x3];
-				next=8;
-			break;
-			case 5: /* scientific */
-			case 6: /* scientific */
-				buf=scipat[(seed>>3) & 0x3];
-				next=8;
-			break;
-			case 7: /* invalid */
-				buf=errpat[(seed>>3) & 0x3];
-				next=8;
-			break;
-			default: /* Never happen, just to make some compilers happy */
-			break;
-		}
-	}
-	size++;
-	while (total<size) { /* fill the rest with 0 */
-		*(p+total)=0;
-		total++;
-	}
-#if CORE_DEBUG
-	ee_printf("State Input: %s\n",start);
-#endif
-}
-
-static ee_u8 ee_isdigit(ee_u8 c) {
-	ee_u8 retval;
-	retval = ((c>='0') & (c<='9')) ? 1 : 0;
-	return retval;
-}
-
-/* Function: core_state_transition
-	Actual state machine.
-
-	The state machine will continue scanning until either:
-	1 - an invalid input is detcted.
-	2 - a valid number has been detected.
-	
-	The input pointer is updated to point to the end of the token, and the end state is returned (either specific format determined or invalid).
-*/
-
-enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count) {
-	ee_u8 *str=*instr;
-	ee_u8 NEXT_SYMBOL;
-	enum CORE_STATE state=CORE_START;
-	for( ; *str && state != CORE_INVALID; str++ ) {
-		NEXT_SYMBOL = *str;
-		if (NEXT_SYMBOL==',') /* end of this input */ {
-			str++;
-			break;
-		}
-		switch(state) {
-		case CORE_START:
-			if(ee_isdigit(NEXT_SYMBOL)) {
-				state = CORE_INT;
-			}
-			else if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
-				state = CORE_S1;
-			}
-			else if( NEXT_SYMBOL == '.' ) {
-				state = CORE_FLOAT;
-			}
-			else {
-				state = CORE_INVALID;
-				transition_count[CORE_INVALID]++;
-			}
-			transition_count[CORE_START]++;
-			break;
-		case CORE_S1:
-			if(ee_isdigit(NEXT_SYMBOL)) {
-				state = CORE_INT;
-				transition_count[CORE_S1]++;
-			}
-			else if( NEXT_SYMBOL == '.' ) {
-				state = CORE_FLOAT;
-				transition_count[CORE_S1]++;
-			}
-			else {
-				state = CORE_INVALID;
-				transition_count[CORE_S1]++;
-			}
-			break;
-		case CORE_INT:
-			if( NEXT_SYMBOL == '.' ) {
-				state = CORE_FLOAT;
-				transition_count[CORE_INT]++;
-			}
-			else if(!ee_isdigit(NEXT_SYMBOL)) {
-				state = CORE_INVALID;
-				transition_count[CORE_INT]++;
-			}
-			break;
-		case CORE_FLOAT:
-			if( NEXT_SYMBOL == 'E' || NEXT_SYMBOL == 'e' ) {
-				state = CORE_S2;
-				transition_count[CORE_FLOAT]++;
-			}
-			else if(!ee_isdigit(NEXT_SYMBOL)) {
-				state = CORE_INVALID;
-				transition_count[CORE_FLOAT]++;
-			}
-			break;
-		case CORE_S2:
-			if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
-				state = CORE_EXPONENT;
-				transition_count[CORE_S2]++;
-			}
-			else {
-				state = CORE_INVALID;
-				transition_count[CORE_S2]++;
-			}
-			break;
-		case CORE_EXPONENT:
-			if(ee_isdigit(NEXT_SYMBOL)) {
-				state = CORE_SCIENTIFIC;
-				transition_count[CORE_EXPONENT]++;
-			}
-			else {
-				state = CORE_INVALID;
-				transition_count[CORE_EXPONENT]++;
-			}
-			break;
-		case CORE_SCIENTIFIC:
-			if(!ee_isdigit(NEXT_SYMBOL)) {
-				state = CORE_INVALID;
-				transition_count[CORE_INVALID]++;
-			}
-			break;
-		default:
-			break;
-		}
-	}
-	*instr=str;
-	return state;
-}
diff --git a/tests/coremark/core_util.c b/tests/coremark/core_util.c
deleted file mode 100644
index 0b95bfe..0000000
--- a/tests/coremark/core_util.c
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
-Author : Shay Gal-On, EEMBC
-
-This file is part of  EEMBC(R) and CoreMark(TM), which are Copyright (C) 2009 
-All rights reserved.                            
-
-EEMBC CoreMark Software is a product of EEMBC and is provided under the terms of the
-CoreMark License that is distributed with the official EEMBC COREMARK Software release. 
-If you received this EEMBC CoreMark Software without the accompanying CoreMark License, 
-you must discontinue use and download the official release from www.coremark.org.  
-
-Also, if you are publicly displaying scores generated from the EEMBC CoreMark software, 
-make sure that you are in compliance with Run and Reporting rules specified in the accompanying readme.txt file.
-
-EEMBC 
-4354 Town Center Blvd. Suite 114-200
-El Dorado Hills, CA, 95762 
-*/ 
-#include "coremark.h"
-/* Function: get_seed
-	Get a values that cannot be determined at compile time.
-
-	Since different embedded systems and compilers are used, 3 different methods are provided:
-	1 - Using a volatile variable. This method is only valid if the compiler is forced to generate code that
-	reads the value of a volatile variable from memory at run time. 
-	Please note, if using this method, you would need to modify core_portme.c to generate training profile.
-	2 - Command line arguments. This is the preferred method if command line arguments are supported.
-	3 - System function. If none of the first 2 methods is available on the platform,
-	a system function which is not a stub can be used.
-	
-	e.g. read the value on GPIO pins connected to switches, or invoke special simulator functions.
-*/
-#if (SEED_METHOD==SEED_VOLATILE)
-	extern volatile ee_s32 seed1_volatile;
-	extern volatile ee_s32 seed2_volatile;
-	extern volatile ee_s32 seed3_volatile;
-	extern volatile ee_s32 seed4_volatile;
-	extern volatile ee_s32 seed5_volatile;
-	ee_s32 get_seed_32(int i) {
-		ee_s32 retval;
-		switch (i) {
-			case 1:
-				retval=seed1_volatile;
-				break;
-			case 2:
-				retval=seed2_volatile;
-				break;
-			case 3:
-				retval=seed3_volatile;
-				break;
-			case 4:
-				retval=seed4_volatile;
-				break;
-			case 5:
-				retval=seed5_volatile;
-				break;
-			default:
-				retval=0;
-				break;
-		}
-		return retval;
-	}
-#elif (SEED_METHOD==SEED_ARG)
-ee_s32 parseval(char *valstring) {
-	ee_s32 retval=0;
-	ee_s32 neg=1;
-	int hexmode=0;
-	if (*valstring == '-') {
-		neg=-1;
-		valstring++;
-	}
-	if ((valstring[0] == '0') && (valstring[1] == 'x')) {
-		hexmode=1;
-		valstring+=2;
-	}
-		/* first look for digits */
-	if (hexmode) {
-		while (((*valstring >= '0') && (*valstring <= '9')) || ((*valstring >= 'a') && (*valstring <= 'f'))) {
-			ee_s32 digit=*valstring-'0';
-			if (digit>9)
-				digit=10+*valstring-'a';
-			retval*=16;
-			retval+=digit;
-			valstring++;
-		}
-	} else {
-		while ((*valstring >= '0') && (*valstring <= '9')) {
-			ee_s32 digit=*valstring-'0';
-			retval*=10;
-			retval+=digit;
-			valstring++;
-		}
-	}
-	/* now add qualifiers */
-	if (*valstring=='K')
-		retval*=1024;
-	if (*valstring=='M')
-		retval*=1024*1024;
-
-	retval*=neg;
-	return retval;
-}
-
-ee_s32 get_seed_args(int i, int argc, char *argv[]) {
-	if (argc>i)
-		return parseval(argv[i]);
-	return 0;
-}
-
-#elif (SEED_METHOD==SEED_FUNC)
-/* If using OS based function, you must define and implement the functions below in core_portme.h and core_portme.c ! */
-ee_s32 get_seed_32(int i) {
-	ee_s32 retval;
-	switch (i) {
-		case 1:
-			retval=portme_sys1();
-			break;
-		case 2:
-			retval=portme_sys2();
-			break;
-		case 3:
-			retval=portme_sys3();
-			break;
-		case 4:
-			retval=portme_sys4();
-			break;
-		case 5:
-			retval=portme_sys5();
-			break;
-		default:
-			retval=0;
-			break;
-	}
-	return retval;
-}
-#endif
-
-/* Function: crc*
-	Service functions to calculate 16b CRC code.
-
-*/
-ee_u16 crcu8(ee_u8 data, ee_u16 crc )
-{
-	ee_u8 i=0,x16=0,carry=0;
-
-	for (i = 0; i < 8; i++)
-    {
-		x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
-		data >>= 1;
-
-		if (x16 == 1)
-		{
-		   crc ^= 0x4002;
-		   carry = 1;
-		}
-		else 
-			carry = 0;
-		crc >>= 1;
-		if (carry)
-		   crc |= 0x8000;
-		else
-		   crc &= 0x7fff;
-    }
-	return crc;
-} 
-ee_u16 crcu16(ee_u16 newval, ee_u16 crc) {
-	crc=crcu8( (ee_u8) (newval)				,crc);
-	crc=crcu8( (ee_u8) ((newval)>>8)	,crc);
-	return crc;
-}
-ee_u16 crcu32(ee_u32 newval, ee_u16 crc) {
-	crc=crc16((ee_s16) newval		,crc);
-	crc=crc16((ee_s16) (newval>>16)	,crc);
-	return crc;
-}
-ee_u16 crc16(ee_s16 newval, ee_u16 crc) {
-	return crcu16((ee_u16)newval, crc);
-}
-
-ee_u8 check_data_types() {
-	ee_u8 retval=0;
-	if (sizeof(ee_u8) != 1) {
-		ee_printf("ERROR: ee_u8 is not an 8b datatype!\n");
-		retval++;
-	}
-	if (sizeof(ee_u16) != 2) {
-		ee_printf("ERROR: ee_u16 is not a 16b datatype!\n");
-		retval++;
-	}
-	if (sizeof(ee_s16) != 2) {
-		ee_printf("ERROR: ee_s16 is not a 16b datatype!\n");
-		retval++;
-	}
-	if (sizeof(ee_s32) != 4) {
-		ee_printf("ERROR: ee_s32 is not a 32b datatype!\n");
-		retval++;
-	}
-	if (sizeof(ee_u32) != 4) {
-		ee_printf("ERROR: ee_u32 is not a 32b datatype!\n");
-		retval++;
-	}
-	if (sizeof(ee_ptr_int) != sizeof(int *)) {
-		ee_printf("ERROR: ee_ptr_int is not a datatype that holds an int pointer!\n");
-		retval++;
-	}
-	if (retval>0) {
-		ee_printf("ERROR: Please modify the datatypes in core_portme.h!\n");
-	}
-	return retval;
-}
diff --git a/tests/coremark/coremark.h b/tests/coremark/coremark.h
deleted file mode 100644
index 90c0f36..0000000
--- a/tests/coremark/coremark.h
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
-Author : Shay Gal-On, EEMBC
-
-This file is part of  EEMBC(R) and CoreMark(TM), which are Copyright (C) 2009 
-All rights reserved.                            
-
-EEMBC CoreMark Software is a product of EEMBC and is provided under the terms of the
-CoreMark License that is distributed with the official EEMBC COREMARK Software release. 
-If you received this EEMBC CoreMark Software without the accompanying CoreMark License, 
-you must discontinue use and download the official release from www.coremark.org.  
-
-Also, if you are publicly displaying scores generated from the EEMBC CoreMark software, 
-make sure that you are in compliance with Run and Reporting rules specified in the accompanying readme.txt file.
-
-EEMBC 
-4354 Town Center Blvd. Suite 114-200
-El Dorado Hills, CA, 95762 
-*/ 
-/* Topic: Description
-	This file contains  declarations of the various benchmark functions.
-*/
-
-/* Configuration: TOTAL_DATA_SIZE
-	Define total size for data algorithms will operate on
-*/
-#ifndef TOTAL_DATA_SIZE 
-#define TOTAL_DATA_SIZE 2*1000
-#endif
-
-#define SEED_ARG 0
-#define SEED_FUNC 1
-#define SEED_VOLATILE 2
-
-#define MEM_STATIC 0
-#define MEM_MALLOC 1
-#define MEM_STACK 2
-
-#include "core_portme.h"
-
-#if HAS_STDIO
-#include <stdio.h>
-#endif
-#if HAS_PRINTF
-#define ee_printf printf
-#endif
-
-/* Actual benchmark execution in iterate */
-void *iterate(void *pres);
-
-/* Typedef: secs_ret
-	For machines that have floating point support, get number of seconds as a double. 
-	Otherwise an unsigned int.
-*/
-#if HAS_FLOAT
-typedef double secs_ret;
-#else
-typedef ee_u32 secs_ret;
-#endif
-
-#if MAIN_HAS_NORETURN
-#define MAIN_RETURN_VAL 
-#define MAIN_RETURN_TYPE void
-#else
-#define MAIN_RETURN_VAL 0
-#define MAIN_RETURN_TYPE int
-#endif 
-
-void start_time(void);
-void stop_time(void);
-CORE_TICKS get_time(void);
-secs_ret time_in_secs(CORE_TICKS ticks);
-
-/* Misc useful functions */
-ee_u16 crcu8(ee_u8 data, ee_u16 crc);
-ee_u16 crc16(ee_s16 newval, ee_u16 crc);
-ee_u16 crcu16(ee_u16 newval, ee_u16 crc);
-ee_u16 crcu32(ee_u32 newval, ee_u16 crc);
-ee_u8 check_data_types();
-void *portable_malloc(ee_size_t size);
-void portable_free(void *p);
-ee_s32 parseval(char *valstring);
-
-/* Algorithm IDS */
-#define ID_LIST 	(1<<0)
-#define ID_MATRIX 	(1<<1)
-#define ID_STATE 	(1<<2)
-#define ALL_ALGORITHMS_MASK (ID_LIST|ID_MATRIX|ID_STATE)
-#define NUM_ALGORITHMS 3
-
-/* list data structures */
-typedef struct list_data_s {
-	ee_s16 data16;
-	ee_s16 idx;
-} list_data;
-
-typedef struct list_head_s {
-	struct list_head_s *next;
-	struct list_data_s *info;
-} list_head;
-
-
-/*matrix benchmark related stuff */
-#define MATDAT_INT 1
-#if MATDAT_INT
-typedef ee_s16 MATDAT;
-typedef ee_s32 MATRES;
-#else
-typedef ee_f16 MATDAT;
-typedef ee_f32 MATRES;
-#endif
-
-typedef struct MAT_PARAMS_S {
-	int N;
-	MATDAT *A;
-	MATDAT *B;
-	MATRES *C;
-} mat_params;
-
-/* state machine related stuff */
-/* List of all the possible states for the FSM */
-typedef enum CORE_STATE {
-	CORE_START=0,
-	CORE_INVALID,
-	CORE_S1,
-	CORE_S2,
-	CORE_INT,
-	CORE_FLOAT,
-	CORE_EXPONENT,
-	CORE_SCIENTIFIC,
-	NUM_CORE_STATES
-} core_state_e ;
-
-		
-/* Helper structure to hold results */
-typedef struct RESULTS_S {
-	/* inputs */
-	ee_s16	seed1;		/* Initializing seed */
-	ee_s16	seed2;		/* Initializing seed */
-	ee_s16	seed3;		/* Initializing seed */
-	void	*memblock[4];	/* Pointer to safe memory location */
-	ee_u32	size;		/* Size of the data */
-	ee_u32 iterations;		/* Number of iterations to execute */
-	ee_u32	execs;		/* Bitmask of operations to execute */
-	struct list_head_s *list;
-	mat_params mat;
-	/* outputs */
-	ee_u16	crc;
-	ee_u16	crclist;
-	ee_u16	crcmatrix;
-	ee_u16	crcstate;
-	ee_s16	err;
-	/* ultithread specific */
-	core_portable port;
-} core_results;
-
-/* Multicore execution handling */
-#if (MULTITHREAD>1)
-ee_u8 core_start_parallel(core_results *res);
-ee_u8 core_stop_parallel(core_results *res);
-#endif
-
-/* list benchmark functions */
-list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed);
-ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx);
-
-/* state benchmark functions */
-void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p);
-ee_u16 core_bench_state(ee_u32 blksize, ee_u8 *memblock, 
-		ee_s16 seed1, ee_s16 seed2, ee_s16 step, ee_u16 crc);
-
-/* matrix benchmark functions */
-ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p);
-ee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc);
-
diff --git a/u8500.mk b/u8500.mk
index da39aaa..9bfebe5 100644
--- a/u8500.mk
+++ b/u8500.mk
@@ -6,6 +6,8 @@ $(call inherit-product, hardware/u8500/audio/libasound/alsa-lib-products.mk)
 # STE Display 
 PRODUCT_PACKAGES += \
    lights.montblanc \
+   libgralloc-shim \
+   libUMP-shim \
    hwcomposer.montblanc \
    copybit.montblanc \
    libblt_hw
